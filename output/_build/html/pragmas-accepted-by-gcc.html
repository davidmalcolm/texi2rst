

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Pragmas Accepted by GCC &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="Extensions to the C Language Family" href="extensions-to-the-c-language-family.html" />
    <link rel="next" title="Unnamed Structure and Union Fields" href="unnamed-structure-and-union-fields.html" />
    <link rel="prev" title="Format Checks Specific to Particular Target Machines" href="format-checks-specific-to-particular-target-machines.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="unnamed-structure-and-union-fields.html" title="Unnamed Structure and Union Fields"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="format-checks-specific-to-particular-target-machines.html" title="Format Checks Specific to Particular Target Machines"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" accesskey="U">Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Pragmas Accepted by GCC</a><ul>
<li><a class="reference internal" href="#arm-pragmas">ARM Pragmas</a></li>
<li><a class="reference internal" href="#m32c-pragmas">M32C Pragmas</a></li>
<li><a class="reference internal" href="#mep-pragmas">MeP Pragmas</a></li>
<li><a class="reference internal" href="#rs-6000-and-powerpc-pragmas">RS/6000 and PowerPC Pragmas</a></li>
<li><a class="reference internal" href="#darwin-pragmas">Darwin Pragmas</a></li>
<li><a class="reference internal" href="#solaris-pragmas">Solaris Pragmas</a></li>
<li><a class="reference internal" href="#symbol-renaming-pragmas">Symbol-Renaming Pragmas</a></li>
<li><a class="reference internal" href="#structure-packing-pragmas">Structure-Packing Pragmas</a></li>
<li><a class="reference internal" href="#weak-pragmas">Weak Pragmas</a></li>
<li><a class="reference internal" href="#diagnostic-pragmas">Diagnostic Pragmas</a></li>
<li><a class="reference internal" href="#visibility-pragmas">Visibility Pragmas</a></li>
<li><a class="reference internal" href="#push-pop-macro-pragmas">Push/Pop Macro Pragmas</a></li>
<li><a class="reference internal" href="#function-specific-option-pragmas">Function Specific Option Pragmas</a></li>
<li><a class="reference internal" href="#loop-specific-pragmas">Loop-Specific Pragmas</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="format-checks-specific-to-particular-target-machines.html"
                        title="previous chapter">Format Checks Specific to Particular Target Machines</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="unnamed-structure-and-union-fields.html"
                        title="next chapter">Unnamed Structure and Union Fields</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/pragmas-accepted-by-gcc.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pragmas-accepted-by-gcc">
<h1>Pragmas Accepted by GCC<a class="headerlink" href="#pragmas-accepted-by-gcc" title="Permalink to this headline">¶</a></h1>
<p id="index-0"><tt class="docutils literal"><span class="pre">#pragma</span></tt></p>
<p>GCC supports several types of pragmas, primarily in order to compile
code originally written for other compilers.  Note that in general
we do not recommend the use of pragmas; Function Attributes,
for further explanation.</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<p>:: _arm-pragmas:</p>
<div class="section" id="arm-pragmas">
<h2>ARM Pragmas<a class="headerlink" href="#arm-pragmas" title="Permalink to this headline">¶</a></h2>
<p>The ARM target defines pragmas for controlling the default addition of
<tt class="docutils literal"><span class="pre">long_call</span></tt> and <tt class="docutils literal"><span class="pre">short_call</span></tt> attributes to functions.
Function Attributes, for information about the effects of these
attributes.</p>
<p>long_calls</p>
<blockquote>
<div><p id="index-1">Set all subsequent functions to have the <tt class="docutils literal"><span class="pre">long_call</span></tt> attribute.</p>
</div></blockquote>
<p>no_long_calls</p>
<blockquote>
<div><p id="index-2">Set all subsequent functions to have the <tt class="docutils literal"><span class="pre">short_call</span></tt> attribute.</p>
</div></blockquote>
<p>long_calls_off</p>
<blockquote>
<div><p id="index-3">Do not affect the <tt class="docutils literal"><span class="pre">long_call</span></tt> or <tt class="docutils literal"><span class="pre">short_call</span></tt> attributes of
subsequent functions.</p>
</div></blockquote>
<p>:: _m32c-pragmas:</p>
</div>
<div class="section" id="m32c-pragmas">
<h2>M32C Pragmas<a class="headerlink" href="#m32c-pragmas" title="Permalink to this headline">¶</a></h2>
<p>GCC memregs <tt class="docutils literal"><span class="pre">number</span></tt></p>
<blockquote>
<div><p id="index-4">Overrides the command-line option <tt class="docutils literal"><span class="pre">-memregs=</span></tt> for the current
file.  Use with care!  This pragma must be before any function in the
file, and mixing different memregs values in different objects may
make them incompatible.  This pragma is useful when a
performance-critical function uses a memreg for temporary values,
as it may allow you to reduce the number of memregs used.</p>
</div></blockquote>
<p>ADDRESS <tt class="docutils literal"><span class="pre">name````address</span></tt></p>
<blockquote>
<div><p id="index-5">For any declared symbols matching <tt class="docutils literal"><span class="pre">name</span></tt>, this does three things
to that symbol: it forces the symbol to be located at the given
address (a number), it forces the symbol to be volatile, and it
changes the symbol&#8217;s scope to be static.  This pragma exists for
compatibility with other compilers, but note that the common
<tt class="docutils literal"><span class="pre">1234H</span></tt> numeric syntax is not supported (use <tt class="docutils literal"><span class="pre">0x1234</span></tt>
instead).  Example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#pragma ADDRESS port3 0x103</span>
<span class="kt">char</span> <span class="n">port3</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>:: _mep-pragmas:</p>
</div>
<div class="section" id="mep-pragmas">
<h2>MeP Pragmas<a class="headerlink" href="#mep-pragmas" title="Permalink to this headline">¶</a></h2>
<p>custom io_volatile (on|off)</p>
<blockquote>
<div><p id="index-6">Overrides the command-line option <tt class="docutils literal"><span class="pre">-mio-volatile</span></tt> for the current
file.  Note that for compatibility with future GCC releases, this
option should only be used once before any <tt class="docutils literal"><span class="pre">io</span></tt> variables in each
file.</p>
</div></blockquote>
<p>GCC coprocessor available <tt class="docutils literal"><span class="pre">registers</span></tt></p>
<blockquote>
<div><p id="index-7">Specifies which coprocessor registers are available to the register
allocator.  <tt class="docutils literal"><span class="pre">registers</span></tt> may be a single register, register range
separated by ellipses, or comma-separated list of those.  Example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#pragma GCC coprocessor available $c0...$c10, $c28</span>
</pre></div>
</div>
</div></blockquote>
<p>GCC coprocessor call_saved <tt class="docutils literal"><span class="pre">registers</span></tt></p>
<blockquote>
<div><p id="index-8">Specifies which coprocessor registers are to be saved and restored by
any function using them.  <tt class="docutils literal"><span class="pre">registers</span></tt> may be a single register,
register range separated by ellipses, or comma-separated list of
those.  Example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#pragma GCC coprocessor call_saved $c4...$c6, $c31</span>
</pre></div>
</div>
</div></blockquote>
<p>GCC coprocessor subclass &#8216;(A|B|C|D)&#8217; = <tt class="docutils literal"><span class="pre">registers</span></tt></p>
<blockquote>
<div><p id="index-9">Creates and defines a register class.  These register classes can be
used by inline <tt class="docutils literal"><span class="pre">asm</span></tt> constructs.  <tt class="docutils literal"><span class="pre">registers</span></tt> may be a single
register, register range separated by ellipses, or comma-separated
list of those.  Example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#pragma GCC coprocessor subclass &#39;B&#39; = $c2, $c4, $c6</span>

<span class="k">asm</span> <span class="p">(</span><span class="s">&quot;cpfoo %0&quot;</span> <span class="o">:</span> <span class="s">&quot;=B&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
<p>GCC disinterrupt <tt class="docutils literal"><span class="pre">name</span></tt> , <tt class="docutils literal"><span class="pre">name</span></tt> ...</p>
<blockquote>
<div><p id="index-10">For the named functions, the compiler adds code to disable interrupts
for the duration of those functions.  If any functions so named
are not encountered in the source, a warning is emitted that the pragma is
not used.  Examples:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#pragma disinterrupt foo</span>
<span class="cp">#pragma disinterrupt bar, grill</span>
<span class="kt">int</span> <span class="nf">foo</span> <span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>GCC call <tt class="docutils literal"><span class="pre">name</span></tt> , <tt class="docutils literal"><span class="pre">name</span></tt> ...</p>
<blockquote>
<div><p id="index-11">For the named functions, the compiler always uses a register-indirect
call model when calling the named functions.  Examples:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="nf">foo</span> <span class="p">();</span>
<span class="cp">#pragma call foo</span>
</pre></div>
</div>
</div></blockquote>
<p>:: _rs/6000-and-powerpc-pragmas:</p>
</div>
<div class="section" id="rs-6000-and-powerpc-pragmas">
<h2>RS/6000 and PowerPC Pragmas<a class="headerlink" href="#rs-6000-and-powerpc-pragmas" title="Permalink to this headline">¶</a></h2>
<p>The RS/6000 and PowerPC targets define one pragma for controlling
whether or not the <tt class="docutils literal"><span class="pre">longcall</span></tt> attribute is added to function
declarations by default.  This pragma overrides the <a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-mlongcall"><em class="xref std std-option">-mlongcall</em></a>
option, but not the <tt class="docutils literal"><span class="pre">longcall</span></tt> and <tt class="docutils literal"><span class="pre">shortcall</span></tt> attributes.
RS/6000 and PowerPC Options, for more information about when long
calls are and are not necessary.</p>
<p>longcall (1)</p>
<blockquote>
<div><p id="index-12">Apply the <tt class="docutils literal"><span class="pre">longcall</span></tt> attribute to all subsequent function
declarations.</p>
</div></blockquote>
<dl class="docutils">
<dt>longcall (0)</dt>
<dd>Do not apply the <tt class="docutils literal"><span class="pre">longcall</span></tt> attribute to subsequent function
declarations.</dd>
</dl>
<p>:: _darwin-pragmas:</p>
</div>
<div class="section" id="darwin-pragmas">
<h2>Darwin Pragmas<a class="headerlink" href="#darwin-pragmas" title="Permalink to this headline">¶</a></h2>
<p>The following pragmas are available for all architectures running the
Darwin operating system.  These are useful for compatibility with other
Mac OS compilers.</p>
<p>mark <tt class="docutils literal"><span class="pre">tokens</span></tt>...</p>
<blockquote>
<div><p id="index-13">This pragma is accepted, but has no effect.</p>
</div></blockquote>
<p>options align=``alignment``</p>
<blockquote>
<div><p id="index-14">This pragma sets the alignment of fields in structures.  The values of
<tt class="docutils literal"><span class="pre">alignment</span></tt> may be <tt class="docutils literal"><span class="pre">mac68k</span></tt>, to emulate m68k alignment, or
<tt class="docutils literal"><span class="pre">power</span></tt>, to emulate PowerPC alignment.  Uses of this pragma nest
properly; to restore the previous setting, use <tt class="docutils literal"><span class="pre">reset</span></tt> for the
<tt class="docutils literal"><span class="pre">alignment</span></tt>.</p>
</div></blockquote>
<p>segment <tt class="docutils literal"><span class="pre">tokens</span></tt>...</p>
<blockquote>
<div><p id="index-15">This pragma is accepted, but has no effect.</p>
</div></blockquote>
<p>unused (<tt class="docutils literal"><span class="pre">var</span></tt> [, <tt class="docutils literal"><span class="pre">var</span></tt>]...)</p>
<blockquote>
<div><p id="index-16">This pragma declares variables to be possibly unused.  GCC does not
produce warnings for the listed variables.  The effect is similar to
that of the <tt class="docutils literal"><span class="pre">unused</span></tt> attribute, except that this pragma may appear
anywhere within the variables&#8217; scopes.</p>
</div></blockquote>
<p>:: _solaris-pragmas:</p>
</div>
<div class="section" id="solaris-pragmas">
<h2>Solaris Pragmas<a class="headerlink" href="#solaris-pragmas" title="Permalink to this headline">¶</a></h2>
<p>The Solaris target supports <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">redefine_extname</span></tt>
(Symbol-Renaming Pragmas).  It also supports additional
<tt class="docutils literal"><span class="pre">#pragma</span></tt> directives for compatibility with the system compiler.</p>
<p>align <tt class="docutils literal"><span class="pre">alignment</span></tt> (<tt class="docutils literal"><span class="pre">variable</span></tt> [, <tt class="docutils literal"><span class="pre">variable</span></tt>]...)</p>
<blockquote>
<div><p id="index-17">Increase the minimum alignment of each <tt class="docutils literal"><span class="pre">variable</span></tt> to <tt class="docutils literal"><span class="pre">alignment</span></tt>.
This is the same as GCC&#8217;s <tt class="docutils literal"><span class="pre">aligned</span></tt> attribute Variable
Attributes).  Macro expansion occurs on the arguments to this pragma
when compiling C and Objective-C.  It does not currently occur when
compiling C++, but this is a bug which may be fixed in a future
release.</p>
</div></blockquote>
<p>fini (<tt class="docutils literal"><span class="pre">function</span></tt> [, <tt class="docutils literal"><span class="pre">function</span></tt>]...)</p>
<blockquote>
<div><p id="index-18">This pragma causes each listed <tt class="docutils literal"><span class="pre">function</span></tt> to be called after
main, or during shared module unloading, by adding a call to the
<tt class="docutils literal"><span class="pre">.fini</span></tt> section.</p>
</div></blockquote>
<p>init (<tt class="docutils literal"><span class="pre">function</span></tt> [, <tt class="docutils literal"><span class="pre">function</span></tt>]...)</p>
<blockquote>
<div><p id="index-19">This pragma causes each listed <tt class="docutils literal"><span class="pre">function</span></tt> to be called during
initialization (before <tt class="docutils literal"><span class="pre">main</span></tt>) or during shared module loading, by
adding a call to the <tt class="docutils literal"><span class="pre">.init</span></tt> section.</p>
</div></blockquote>
<p>:: _symbol-renaming-pragmas:</p>
</div>
<div class="section" id="symbol-renaming-pragmas">
<h2>Symbol-Renaming Pragmas<a class="headerlink" href="#symbol-renaming-pragmas" title="Permalink to this headline">¶</a></h2>
<p>GCC supports a <tt class="docutils literal"><span class="pre">#pragma</span></tt> directive that changes the name used in
assembly for a given declaration. While this pragma is supported on all
platforms, it is intended primarily to provide compatibility with the
Solaris system headers. This effect can also be achieved using the asm
labels extension (Asm Labels).</p>
<p>redefine_extname <tt class="docutils literal"><span class="pre">oldname````newname</span></tt></p>
<blockquote>
<div><p id="index-20">This pragma gives the C function <tt class="docutils literal"><span class="pre">oldname</span></tt> the assembly symbol
<tt class="docutils literal"><span class="pre">newname</span></tt>.  The preprocessor macro <tt class="docutils literal"><span class="pre">__PRAGMA_REDEFINE_EXTNAME</span></tt>
is defined if this pragma is available (currently on all platforms).</p>
</div></blockquote>
<p>This pragma and the asm labels extension interact in a complicated
manner.  Here are some corner cases you may want to be aware of:</p>
<ul>
<li><p class="first">This pragma silently applies only to declarations with external
linkage.  Asm labels do not have this restriction.</p>
<ul class="simple">
<li>In C++, this pragma silently applies only to declarations with</li>
</ul>
<p>&#8216;C&#8217; linkage.  Again, asm labels do not have this restriction.</p>
<ul class="simple">
<li>If either of the ways of changing the assembly name of a</li>
</ul>
<p>declaration are applied to a declaration whose assembly name has
already been determined (either by a previous use of one of these
features, or because the compiler needed the assembly name in order to
generate code), and the new name is different, a warning issues and
the name does not change.</p>
<ul class="simple">
<li>The <tt class="docutils literal"><span class="pre">oldname</span></tt> used by <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">redefine_extname</span></tt> is</li>
</ul>
<p>always the C-language name.</p>
</li>
</ul>
<p>:: _structure-packing-pragmas:</p>
</div>
<div class="section" id="structure-packing-pragmas">
<h2>Structure-Packing Pragmas<a class="headerlink" href="#structure-packing-pragmas" title="Permalink to this headline">¶</a></h2>
<p>For compatibility with Microsoft Windows compilers, GCC supports a
set of <tt class="docutils literal"><span class="pre">#pragma</span></tt> directives that change the maximum alignment of
members of structures (other than zero-width bit-fields), unions, and
classes subsequently defined. The <tt class="docutils literal"><span class="pre">n</span></tt> value below always is required
to be a small power of two and specifies the new alignment in bytes.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack(``n</span></tt>)`` simply sets the new alignment.
* <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack()</span></tt> sets the alignment to the one that was in
effect when compilation started (see also command-line option
<em class="xref std std-option">-fpack-struct[=``n`</em>]` Code Gen Options).
* <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack(push[,``n</span></tt>])`` pushes the current alignment
setting on an internal stack and then optionally sets the new alignment.
* <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack(pop)</span></tt> restores the alignment setting to the one
saved at the top of the internal stack (and removes that stack entry).
Note that <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack([``n</span></tt>])`` does not influence this internal
stack; thus it is possible to have <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack(push)</span></tt> followed by
multiple <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack(``n</span></tt>)`` instances and finalized by a single
<tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack(pop)</span></tt>.</li>
</ul>
<p>Some targets, e.g. x86 and PowerPC, support the <tt class="docutils literal"><span class="pre">ms_struct</span></tt>
<tt class="docutils literal"><span class="pre">#pragma</span></tt> which lays out a structure as the documented
<tt class="docutils literal"><span class="pre">__attribute__</span> <span class="pre">((ms_struct))</span></tt>.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">ms_struct</span> <span class="pre">on</span></tt> turns on the layout for structures
declared.
* <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">ms_struct</span> <span class="pre">off</span></tt> turns off the layout for structures
declared.
* <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">ms_struct</span> <span class="pre">reset</span></tt> goes back to the default layout.</li>
</ul>
<p>:: _weak-pragmas:</p>
</div>
<div class="section" id="weak-pragmas">
<h2>Weak Pragmas<a class="headerlink" href="#weak-pragmas" title="Permalink to this headline">¶</a></h2>
<p>For compatibility with SVR4, GCC supports a set of <tt class="docutils literal"><span class="pre">#pragma</span></tt>
directives for declaring symbols to be weak, and defining weak
aliases.</p>
<p>#pragma weak <tt class="docutils literal"><span class="pre">symbol</span></tt></p>
<blockquote>
<div><p id="index-21">This pragma declares <tt class="docutils literal"><span class="pre">symbol</span></tt> to be weak, as if the declaration
had the attribute of the same name.  The pragma may appear before
or after the declaration of <tt class="docutils literal"><span class="pre">symbol</span></tt>.  It is not an error for
<tt class="docutils literal"><span class="pre">symbol</span></tt> to never be defined at all.</p>
</div></blockquote>
<dl class="docutils">
<dt>#pragma weak <tt class="docutils literal"><span class="pre">symbol1</span></tt> = <tt class="docutils literal"><span class="pre">symbol2</span></tt></dt>
<dd>This pragma declares <tt class="docutils literal"><span class="pre">symbol1</span></tt> to be a weak alias of <tt class="docutils literal"><span class="pre">symbol2</span></tt>.
It is an error if <tt class="docutils literal"><span class="pre">symbol2</span></tt> is not defined in the current
translation unit.</dd>
</dl>
<p>:: _diagnostic-pragmas:</p>
</div>
<div class="section" id="diagnostic-pragmas">
<h2>Diagnostic Pragmas<a class="headerlink" href="#diagnostic-pragmas" title="Permalink to this headline">¶</a></h2>
<p>GCC allows the user to selectively enable or disable certain types of
diagnostics, and change the kind of the diagnostic.  For example, a
project&#8217;s policy might require that all sources compile with
<a class="reference internal" href="options-to-request-or-suppress-warnings.html#cmdoption-Werror"><em class="xref std std-option">-Werror</em></a> but certain files might have exceptions allowing
specific types of warnings.  Or, a project might selectively enable
diagnostics and treat them as errors depending on which preprocessor
macros are defined.</p>
<p>#pragma GCC diagnostic <tt class="docutils literal"><span class="pre">kind````option</span></tt></p>
<blockquote>
<div><p id="index-22">Modifies the disposition of a diagnostic.  Note that not all
diagnostics are modifiable; at the moment only warnings (normally
controlled by -W...) can be controlled, and not all of them.
Use <em class="xref std std-option">-fdiagnostics-show-option</em> to determine which diagnostics
are controllable and which option controls them.</p>
<p><tt class="docutils literal"><span class="pre">kind</span></tt> is error to treat this diagnostic as an error,
warning to treat it like a warning (even if <a class="reference internal" href="options-to-request-or-suppress-warnings.html#cmdoption-Werror"><em class="xref std std-option">-Werror</em></a> is
in effect), or ignored if the diagnostic is to be ignored.
<tt class="docutils literal"><span class="pre">option</span></tt> is a double quoted string that matches the command-line
option.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#pragma GCC diagnostic warning &quot;-Wformat&quot;</span>
<span class="cp">#pragma GCC diagnostic error &quot;-Wformat&quot;</span>
<span class="cp">#pragma GCC diagnostic ignored &quot;-Wformat&quot;</span>
</pre></div>
</div>
<p>Note that these pragmas override any command-line options.  GCC keeps
track of the location of each pragma, and issues diagnostics according
to the state as of that point in the source file.  Thus, pragmas occurring
after a line do not affect diagnostics caused by that line.</p>
</div></blockquote>
<p>#pragma GCC diagnostic push#pragma GCC diagnostic pop</p>
<blockquote>
<div><p>Causes GCC to remember the state of the diagnostics as of each
<tt class="docutils literal"><span class="pre">push</span></tt>, and restore to that point at each <tt class="docutils literal"><span class="pre">pop</span></tt>.  If a
<tt class="docutils literal"><span class="pre">pop</span></tt> has no matching <tt class="docutils literal"><span class="pre">push</span></tt>, the command-line options are
restored.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#pragma GCC diagnostic error &quot;-Wuninitialized&quot;</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>                       <span class="cm">/* error is given for this one */</span>
<span class="cp">#pragma GCC diagnostic push</span>
<span class="cp">#pragma GCC diagnostic ignored &quot;-Wuninitialized&quot;</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>                       <span class="cm">/* no diagnostic for this one */</span>
<span class="cp">#pragma GCC diagnostic pop</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>                       <span class="cm">/* error is given for this one */</span>
<span class="cp">#pragma GCC diagnostic pop</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>                       <span class="cm">/* depends on command-line options */</span>
</pre></div>
</div>
</div></blockquote>
<p>GCC also offers a simple mechanism for printing messages during
compilation.</p>
<p>#pragma message <tt class="docutils literal"><span class="pre">string</span></tt></p>
<blockquote>
<div><p id="index-23">Prints <tt class="docutils literal"><span class="pre">string</span></tt> as a compiler message on compilation.  The message
is informational only, and is neither a compilation warning nor an error.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#pragma message &quot;Compiling &quot; __FILE__ &quot;...&quot;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">string</span></tt> may be parenthesized, and is printed with location
information.  For example,</p>
<div class="highlight-fortran"><pre>#define DO_PRAGMA(x) _Pragma (#x)
#define TODO(x) DO_PRAGMA(message ("TODO - " #x))

TODO(Remember to fix this)</pre>
</div>
<p>prints /tmp/file.c:4: note: #pragma message:
TODO - Remember to fix this.</p>
</div></blockquote>
<p>:: _visibility-pragmas:</p>
</div>
<div class="section" id="visibility-pragmas">
<h2>Visibility Pragmas<a class="headerlink" href="#visibility-pragmas" title="Permalink to this headline">¶</a></h2>
<p>#pragma GCC visibility push(<tt class="docutils literal"><span class="pre">visibility</span></tt>)#pragma GCC visibility pop</p>
<blockquote>
<div><p id="index-24">This pragma allows the user to set the visibility for multiple
declarations without having to give each a visibility attribute
(Function Attributes).</p>
<p>In C++, #pragma GCC visibility affects only namespace-scope
declarations.  Class members and template specializations are not
affected; if you want to override the visibility for a particular
member or instantiation, you must use an attribute.</p>
</div></blockquote>
<p>:: _push/pop-macro-pragmas:</p>
</div>
<div class="section" id="push-pop-macro-pragmas">
<h2>Push/Pop Macro Pragmas<a class="headerlink" href="#push-pop-macro-pragmas" title="Permalink to this headline">¶</a></h2>
<p>For compatibility with Microsoft Windows compilers, GCC supports
#pragma push_macro(<tt class="docutils literal"><span class="pre">&quot;macro_name&quot;</span></tt>)
and #pragma pop_macro(<tt class="docutils literal"><span class="pre">&quot;macro_name&quot;</span></tt>).</p>
<p>#pragma push_macro(<tt class="docutils literal"><span class="pre">&quot;macro_name&quot;</span></tt>)</p>
<blockquote>
<div><p id="index-25">This pragma saves the value of the macro named as <tt class="docutils literal"><span class="pre">macro_name</span></tt> to
the top of the stack for this macro.</p>
</div></blockquote>
<p>#pragma pop_macro(<tt class="docutils literal"><span class="pre">&quot;macro_name&quot;</span></tt>)</p>
<blockquote>
<div><p id="index-26">This pragma sets the value of the macro named as <tt class="docutils literal"><span class="pre">macro_name</span></tt> to
the value on top of the stack for this macro. If the stack for
<tt class="docutils literal"><span class="pre">macro_name</span></tt> is empty, the value of the macro remains unchanged.</p>
</div></blockquote>
<p>For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define X  1</span>
<span class="cp">#pragma push_macro(&quot;X&quot;)</span>
<span class="cp">#undef X</span>
<span class="cp">#define X -1</span>
<span class="cp">#pragma pop_macro(&quot;X&quot;)</span>
<span class="kt">int</span> <span class="n">x</span> <span class="p">[</span><span class="n">X</span><span class="p">];</span>
</pre></div>
</div>
<p>In this example, the definition of X as 1 is saved by <tt class="docutils literal"><span class="pre">#pragma</span>
<span class="pre">push_macro</span></tt> and restored by <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pop_macro</span></tt>.</p>
<p>:: _function-specific-option-pragmas:</p>
</div>
<div class="section" id="function-specific-option-pragmas">
<h2>Function Specific Option Pragmas<a class="headerlink" href="#function-specific-option-pragmas" title="Permalink to this headline">¶</a></h2>
<p>#pragma GCC target (<tt class="docutils literal"><span class="pre">&quot;string&quot;</span></tt>...)</p>
<blockquote>
<div><p id="index-27">This pragma allows you to set target specific options for functions
defined later in the source file.  One or more strings can be
specified.  Each function that is defined after this point is as
if <tt class="docutils literal"><span class="pre">attribute((target(&quot;STRING&quot;)))</span></tt> was specified for that
function.  The parenthesis around the options is optional.
Function Attributes, for more information about the
<tt class="docutils literal"><span class="pre">target</span></tt> attribute and the attribute syntax.</p>
<p>The <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">GCC</span> <span class="pre">target</span></tt> pragma is presently implemented for
x86, PowerPC, and Nios II targets only.</p>
</div></blockquote>
<p>#pragma GCC optimize (<tt class="docutils literal"><span class="pre">&quot;string&quot;</span></tt>...)</p>
<blockquote>
<div><p id="index-28">This pragma allows you to set global optimization options for functions
defined later in the source file.  One or more strings can be
specified.  Each function that is defined after this point is as
if <tt class="docutils literal"><span class="pre">attribute((optimize(&quot;STRING&quot;)))</span></tt> was specified for that
function.  The parenthesis around the options is optional.
Function Attributes, for more information about the
<tt class="docutils literal"><span class="pre">optimize</span></tt> attribute and the attribute syntax.</p>
</div></blockquote>
<p>#pragma GCC push_options#pragma GCC pop_options</p>
<blockquote>
<div><span class="target" id="index-29"></span><p id="index-30">These pragmas maintain a stack of the current target and optimization
options.  It is intended for include files where you temporarily want
to switch to using a different #pragma GCC target or
#pragma GCC optimize and then to pop back to the previous
options.</p>
</div></blockquote>
<p>#pragma GCC reset_options</p>
<blockquote>
<div><p id="index-31">This pragma clears the current <tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">GCC</span> <span class="pre">target</span></tt> and
<tt class="docutils literal"><span class="pre">#pragma</span> <span class="pre">GCC</span> <span class="pre">optimize</span></tt> to use the default switches as specified
on the command line.</p>
</div></blockquote>
<p>:: _loop-specific-pragmas:</p>
</div>
<div class="section" id="loop-specific-pragmas">
<h2>Loop-Specific Pragmas<a class="headerlink" href="#loop-specific-pragmas" title="Permalink to this headline">¶</a></h2>
<p>#pragma GCC ivdep</p>
<blockquote>
<div></div></blockquote>
<p id="index-32">With this pragma, the programmer asserts that there are no loop-carried
dependencies which would prevent consecutive iterations of
the following loop from executing concurrently with SIMD
(single instruction multiple data) instructions.</p>
<p>For example, the compiler can only unconditionally vectorize the following
loop with the pragma:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">foo</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
<span class="cp">#pragma GCC ivdep</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, using the <tt class="docutils literal"><span class="pre">restrict</span></tt> qualifier had the same
effect. In the following example, that would not be possible. Assume
k &lt; -m or k &gt;= m. Only with the pragma, the compiler knows
that it can unconditionally vectorize the following loop:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">ignore_vec_dep</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#pragma GCC ivdep</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="unnamed-structure-and-union-fields.html" title="Unnamed Structure and Union Fields"
             >next</a> |</li>
        <li class="right" >
          <a href="format-checks-specific-to-particular-target-machines.html" title="Format Checks Specific to Particular Target Machines"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" >Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>