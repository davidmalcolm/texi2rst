

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Options That Control Optimization &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="GCC Command Options" href="gcc-command-options.html" />
    <link rel="next" title="Options Controlling the Preprocessor" href="options-controlling-the-preprocessor.html" />
    <link rel="prev" title="Options for Debugging Your Program or GCC" href="options-for-debugging-your-program-or-gcc.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="options-controlling-the-preprocessor.html" title="Options Controlling the Preprocessor"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="options-for-debugging-your-program-or-gcc.html" title="Options for Debugging Your Program or GCC"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="gcc-command-options.html" accesskey="U">GCC Command Options</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="options-for-debugging-your-program-or-gcc.html"
                        title="previous chapter">Options for Debugging Your Program or GCC</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="options-controlling-the-preprocessor.html"
                        title="next chapter">Options Controlling the Preprocessor</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/options-that-control-optimization.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="options-that-control-optimization">
<span id="optimize-options"></span><h1>Options That Control Optimization<a class="headerlink" href="#options-that-control-optimization" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><p id="index-1">These options control various sorts of optimizations.</p>
<p>Without any optimization option, the compiler&#8217;s goal is to reduce the
cost of compilation and to make debugging produce the expected
results.  Statements are independent: if you stop the program with a
breakpoint between statements, you can then assign a new value to any
variable or change the program counter to any other statement in the
function and get exactly the results you expect from the source
code.</p>
<p>Turning on optimization flags makes the compiler attempt to improve
the performance and/or code size at the expense of compilation time
and possibly the ability to debug the program.</p>
<p>The compiler performs optimization based on the knowledge it has of the
program.  Compiling multiple files at once to a single output file mode allows
the compiler to use information gained from all of the files when compiling
each of them.</p>
<p>Not all optimizations are controlled directly by a flag.  Only
optimizations that have a flag are listed in this section.</p>
<p>Most optimizations are only enabled if an <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> level is set on
the command line.  Otherwise they are disabled, even if individual
optimization flags are specified.</p>
<p>Depending on the target and how GCC was configured, a slightly different
set of optimizations may be enabled at each <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> level than
those listed here.  You can invoke GCC with <em class="xref std std-option">-Q --help=optimizers</em>
to find out the exact set of optimizations that are enabled at each level.
See <a class="reference internal" href="options-controlling-the-kind-of-output.html#overall-options"><em>Options Controlling the Kind of Output</em></a>, for examples.</p>
<dl class="option">
<dt id="cmdoption-O">
<tt class="descname">-O</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">-O1</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-O" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize.  Optimizing compilation takes somewhat more time, and a lot
more memory for a large function.</p>
<p>With <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, the compiler tries to reduce code size and execution
time, without performing any optimizations that take a great deal of
compilation time.</p>
<p><a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> turns on the following optimization flags:</p>
<p><a class="reference internal" href="#cmdoption-fauto-inc-dec"><em class="xref std std-option">-fauto-inc-dec</em></a>
<em class="xref std std-option">-fbranch-count-reg</em>
<a class="reference internal" href="#cmdoption-fcombine-stack-adjustments"><em class="xref std std-option">-fcombine-stack-adjustments</em></a>
<a class="reference internal" href="#cmdoption-fcompare-elim"><em class="xref std std-option">-fcompare-elim</em></a>
<a class="reference internal" href="#cmdoption-fcprop-registers"><em class="xref std std-option">-fcprop-registers</em></a>
<a class="reference internal" href="#cmdoption-fdce"><em class="xref std std-option">-fdce</em></a>
<em class="xref std std-option">-fdefer-pop</em>
<a class="reference internal" href="#cmdoption-fdelayed-branch"><em class="xref std std-option">-fdelayed-branch</em></a>
<a class="reference internal" href="#cmdoption-fdse"><em class="xref std std-option">-fdse</em></a>
<a class="reference internal" href="#cmdoption-fforward-propagate"><em class="xref std std-option">-fforward-propagate</em></a>
<em class="xref std std-option">-fguess-branch-probability</em>
<a class="reference internal" href="#cmdoption-fif-conversion2"><em class="xref std std-option">-fif-conversion2</em></a>
<a class="reference internal" href="#cmdoption-fif-conversion"><em class="xref std std-option">-fif-conversion</em></a>
<a class="reference internal" href="#cmdoption-finline-functions-called-once"><em class="xref std std-option">-finline-functions-called-once</em></a>
<a class="reference internal" href="#cmdoption-fipa-pure-const"><em class="xref std std-option">-fipa-pure-const</em></a>
<a class="reference internal" href="#cmdoption-fipa-profile"><em class="xref std std-option">-fipa-profile</em></a>
<a class="reference internal" href="#cmdoption-fipa-reference"><em class="xref std std-option">-fipa-reference</em></a>
<a class="reference internal" href="#cmdoption-fmerge-constants"><em class="xref std std-option">-fmerge-constants</em></a>
<a class="reference internal" href="#cmdoption-fmove-loop-invariants"><em class="xref std std-option">-fmove-loop-invariants</em></a>
<a class="reference internal" href="#cmdoption-fshrink-wrap"><em class="xref std std-option">-fshrink-wrap</em></a>
<a class="reference internal" href="#cmdoption-fsplit-wide-types"><em class="xref std std-option">-fsplit-wide-types</em></a>
<a class="reference internal" href="#cmdoption-ftree-bit-ccp"><em class="xref std std-option">-ftree-bit-ccp</em></a>
<a class="reference internal" href="#cmdoption-ftree-ccp"><em class="xref std std-option">-ftree-ccp</em></a>
<a class="reference internal" href="#cmdoption-fssa-phiopt"><em class="xref std std-option">-fssa-phiopt</em></a>
<a class="reference internal" href="#cmdoption-ftree-ch"><em class="xref std std-option">-ftree-ch</em></a>
<a class="reference internal" href="#cmdoption-ftree-copy-prop"><em class="xref std std-option">-ftree-copy-prop</em></a>
<a class="reference internal" href="#cmdoption-ftree-copyrename"><em class="xref std std-option">-ftree-copyrename</em></a>
<a class="reference internal" href="#cmdoption-ftree-dce"><em class="xref std std-option">-ftree-dce</em></a>
<a class="reference internal" href="#cmdoption-ftree-dominator-opts"><em class="xref std std-option">-ftree-dominator-opts</em></a>
<a class="reference internal" href="#cmdoption-ftree-dse"><em class="xref std std-option">-ftree-dse</em></a>
<a class="reference internal" href="#cmdoption-ftree-forwprop"><em class="xref std std-option">-ftree-forwprop</em></a>
<a class="reference internal" href="#cmdoption-ftree-fre"><em class="xref std std-option">-ftree-fre</em></a>
<a class="reference internal" href="#cmdoption-ftree-phiprop"><em class="xref std std-option">-ftree-phiprop</em></a>
<a class="reference internal" href="#cmdoption-ftree-sink"><em class="xref std std-option">-ftree-sink</em></a>
<a class="reference internal" href="#cmdoption-ftree-slsr"><em class="xref std std-option">-ftree-slsr</em></a>
<a class="reference internal" href="#cmdoption-ftree-sra"><em class="xref std std-option">-ftree-sra</em></a>
<a class="reference internal" href="#cmdoption-ftree-pta"><em class="xref std std-option">-ftree-pta</em></a>
<a class="reference internal" href="#cmdoption-ftree-ter"><em class="xref std std-option">-ftree-ter</em></a>
<a class="reference internal" href="#cmdoption-funit-at-a-time"><em class="xref std std-option">-funit-at-a-time</em></a>
<a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> also turns on <a class="reference internal" href="#cmdoption-fomit-frame-pointer"><em class="xref std std-option">-fomit-frame-pointer</em></a> on machines
where doing so does not interfere with debugging.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-O2">
<tt class="descname">-O2</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-O2" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize even more.  GCC performs nearly all supported optimizations
that do not involve a space-speed tradeoff.
As compared to <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, this option increases both compilation time
and the performance of the generated code.</p>
<p><a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> turns on all optimization flags specified by <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>.  It
also turns on the following optimization flags:</p>
<p><a class="reference internal" href="#cmdoption-fthread-jumps"><em class="xref std std-option">-fthread-jumps</em></a>
<a class="reference internal" href="#cmdoption-falign-functions"><em class="xref std std-option">-falign-functions</em></a>  <a class="reference internal" href="#cmdoption-falign-jumps"><em class="xref std std-option">-falign-jumps</em></a>
<a class="reference internal" href="#cmdoption-falign-loops"><em class="xref std std-option">-falign-loops</em></a>  <a class="reference internal" href="#cmdoption-falign-labels"><em class="xref std std-option">-falign-labels</em></a>
<a class="reference internal" href="#cmdoption-fcaller-saves"><em class="xref std std-option">-fcaller-saves</em></a>
<a class="reference internal" href="#cmdoption-fcrossjumping"><em class="xref std std-option">-fcrossjumping</em></a>
<a class="reference internal" href="#cmdoption-fcse-follow-jumps"><em class="xref std std-option">-fcse-follow-jumps</em></a>  <a class="reference internal" href="#cmdoption-fcse-skip-blocks"><em class="xref std std-option">-fcse-skip-blocks</em></a>
<a class="reference internal" href="#cmdoption-fdelete-null-pointer-checks"><em class="xref std std-option">-fdelete-null-pointer-checks</em></a>
<a class="reference internal" href="#cmdoption-fdevirtualize"><em class="xref std std-option">-fdevirtualize</em></a> <a class="reference internal" href="#cmdoption-fdevirtualize-speculatively"><em class="xref std std-option">-fdevirtualize-speculatively</em></a>
<a class="reference internal" href="#cmdoption-fexpensive-optimizations"><em class="xref std std-option">-fexpensive-optimizations</em></a>
<a class="reference internal" href="#cmdoption-fgcse"><em class="xref std std-option">-fgcse</em></a>  <a class="reference internal" href="#cmdoption-fgcse-lm"><em class="xref std std-option">-fgcse-lm</em></a>
<a class="reference internal" href="#cmdoption-fhoist-adjacent-loads"><em class="xref std std-option">-fhoist-adjacent-loads</em></a>
<a class="reference internal" href="#cmdoption-finline-small-functions"><em class="xref std std-option">-finline-small-functions</em></a>
<a class="reference internal" href="#cmdoption-findirect-inlining"><em class="xref std std-option">-findirect-inlining</em></a>
<a class="reference internal" href="#cmdoption-fipa-cp"><em class="xref std std-option">-fipa-cp</em></a>
<a class="reference internal" href="#cmdoption-fipa-cp-alignment"><em class="xref std std-option">-fipa-cp-alignment</em></a>
<a class="reference internal" href="#cmdoption-fipa-sra"><em class="xref std std-option">-fipa-sra</em></a>
<a class="reference internal" href="#cmdoption-fipa-icf"><em class="xref std std-option">-fipa-icf</em></a>
<a class="reference internal" href="#cmdoption-fisolate-erroneous-paths-dereference"><em class="xref std std-option">-fisolate-erroneous-paths-dereference</em></a>
<a class="reference internal" href="#cmdoption-flra-remat"><em class="xref std std-option">-flra-remat</em></a>
<a class="reference internal" href="#cmdoption-foptimize-sibling-calls"><em class="xref std std-option">-foptimize-sibling-calls</em></a>
<a class="reference internal" href="#cmdoption-foptimize-strlen"><em class="xref std std-option">-foptimize-strlen</em></a>
<a class="reference internal" href="#cmdoption-fpartial-inlining"><em class="xref std std-option">-fpartial-inlining</em></a>
<em class="xref std std-option">-fpeephole2</em>
<a class="reference internal" href="#cmdoption-freorder-blocks"><em class="xref std std-option">-freorder-blocks</em></a> <a class="reference internal" href="#cmdoption-freorder-blocks-and-partition"><em class="xref std std-option">-freorder-blocks-and-partition</em></a> <a class="reference internal" href="#cmdoption-freorder-functions"><em class="xref std std-option">-freorder-functions</em></a>
<a class="reference internal" href="#cmdoption-frerun-cse-after-loop"><em class="xref std std-option">-frerun-cse-after-loop</em></a>
<em class="xref std std-option">-fsched-interblock</em>  <em class="xref std std-option">-fsched-spec</em>
<a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a>  <a class="reference internal" href="#cmdoption-fschedule-insns2"><em class="xref std std-option">-fschedule-insns2</em></a>
<a class="reference internal" href="#cmdoption-fstrict-aliasing"><em class="xref std std-option">-fstrict-aliasing</em></a> <a class="reference internal" href="#cmdoption-fstrict-overflow"><em class="xref std std-option">-fstrict-overflow</em></a>
<a class="reference internal" href="#cmdoption-ftree-builtin-call-dce"><em class="xref std std-option">-ftree-builtin-call-dce</em></a>
<a class="reference internal" href="#cmdoption-ftree-switch-conversion"><em class="xref std std-option">-ftree-switch-conversion</em></a> <a class="reference internal" href="#cmdoption-ftree-tail-merge"><em class="xref std std-option">-ftree-tail-merge</em></a>
<a class="reference internal" href="#cmdoption-ftree-pre"><em class="xref std std-option">-ftree-pre</em></a>
<a class="reference internal" href="#cmdoption-ftree-vrp"><em class="xref std std-option">-ftree-vrp</em></a>
<a class="reference internal" href="#cmdoption-fipa-ra"><em class="xref std std-option">-fipa-ra</em></a>
Please note the warning under <a class="reference internal" href="#cmdoption-fgcse"><em class="xref std std-option">-fgcse</em></a> about
invoking <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> on programs that use computed gotos.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-O3">
<tt class="descname">-O3</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-O3" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize yet more.  <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a> turns on all optimizations specified
by <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> and also turns on the <a class="reference internal" href="#cmdoption-finline-functions"><em class="xref std std-option">-finline-functions</em></a>,
<a class="reference internal" href="#cmdoption-funswitch-loops"><em class="xref std std-option">-funswitch-loops</em></a>, <a class="reference internal" href="#cmdoption-fpredictive-commoning"><em class="xref std std-option">-fpredictive-commoning</em></a>,
<a class="reference internal" href="#cmdoption-fgcse-after-reload"><em class="xref std std-option">-fgcse-after-reload</em></a>, <a class="reference internal" href="#cmdoption-ftree-loop-vectorize"><em class="xref std std-option">-ftree-loop-vectorize</em></a>,
<a class="reference internal" href="#cmdoption-ftree-loop-distribute-patterns"><em class="xref std std-option">-ftree-loop-distribute-patterns</em></a>,
<a class="reference internal" href="#cmdoption-ftree-slp-vectorize"><em class="xref std std-option">-ftree-slp-vectorize</em></a>, <a class="reference internal" href="#cmdoption-fvect-cost-model"><em class="xref std std-option">-fvect-cost-model</em></a>,
<a class="reference internal" href="#cmdoption-ftree-partial-pre"><em class="xref std std-option">-ftree-partial-pre</em></a> and <a class="reference internal" href="#cmdoption-fipa-cp-clone"><em class="xref std std-option">-fipa-cp-clone</em></a> options.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-O0">
<tt class="descname">-O0</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-O0" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce compilation time and make debugging produce the expected
results.  This is the default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-Os">
<tt class="descname">-Os</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-Os" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize for size.  <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a> enables all <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> optimizations that
do not typically increase code size.  It also performs further
optimizations designed to reduce code size.</p>
<p><a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a> disables the following optimization flags:</p>
<p><a class="reference internal" href="#cmdoption-falign-functions"><em class="xref std std-option">-falign-functions</em></a>  <a class="reference internal" href="#cmdoption-falign-jumps"><em class="xref std std-option">-falign-jumps</em></a>  <a class="reference internal" href="#cmdoption-falign-loops"><em class="xref std std-option">-falign-loops</em></a>
<a class="reference internal" href="#cmdoption-falign-labels"><em class="xref std std-option">-falign-labels</em></a>  <a class="reference internal" href="#cmdoption-freorder-blocks"><em class="xref std std-option">-freorder-blocks</em></a>  <a class="reference internal" href="#cmdoption-freorder-blocks-and-partition"><em class="xref std std-option">-freorder-blocks-and-partition</em></a>
<a class="reference internal" href="#cmdoption-fprefetch-loop-arrays"><em class="xref std std-option">-fprefetch-loop-arrays</em></a></p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-Ofast">
<tt class="descname">-Ofast</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-Ofast" title="Permalink to this definition">¶</a></dt>
<dd><p>Disregard strict standards compliance.  <a class="reference internal" href="#cmdoption-Ofast"><em class="xref std std-option">-Ofast</em></a> enables all
<a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a> optimizations.  It also enables optimizations that are not
valid for all standard-compliant programs.
It turns on <a class="reference internal" href="#cmdoption-ffast-math"><em class="xref std std-option">-ffast-math</em></a> and the Fortran-specific
<em class="xref std std-option">-fno-protect-parens</em> and <em class="xref std std-option">-fstack-arrays</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-Og">
<tt class="descname">-Og</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-Og" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize debugging experience.  <a class="reference internal" href="#cmdoption-Og"><em class="xref std std-option">-Og</em></a> enables optimizations
that do not interfere with debugging. It should be the optimization
level of choice for the standard edit-compile-debug cycle, offering
a reasonable level of optimization while maintaining fast compilation
and a good debugging experience.</p>
<p>If you use multiple <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> options, with or without level numbers,
the last such option is the one that is effective.</p>
</dd></dl>

<p>Options of the form <em class="xref std std-option">-f``flag``</em> specify machine-independent
flags.  Most flags have both positive and negative forms; the negative
form of <em class="xref std std-option">-ffoo</em> is <em class="xref std std-option">-fno-foo</em>.  In the table
below, only one of the forms is listed-the one you typically
use.  You can figure out the other form by either removing no-
or adding it.</p>
<p>The following options control specific optimizations.  They are either
activated by <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> options or are related to ones that are.  You
can use the following flags in the rare cases when &#8216;fine-tuning&#8217; of
optimizations to be performed is desired.</p>
<dl class="option">
<dt id="cmdoption-fno-defer-pop">
<tt class="descname">-fno-defer-pop</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-defer-pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Always pop the arguments to each function call as soon as that function
returns.  For machines that must pop arguments after a function call,
the compiler normally lets arguments accumulate on the stack for several
function calls and pops them all at once.</p>
<p>Disabled at levels <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fforward-propagate">
<tt class="descname">-fforward-propagate</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fforward-propagate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a forward propagation pass on RTL.  The pass tries to combine two
instructions and checks if the result can be simplified.  If loop unrolling
is active, two passes are performed and the second is scheduled after
loop unrolling.</p>
<p>This option is enabled by default at optimization levels <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>,
<a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ffp-contract">
<tt class="descname">-ffp-contract</tt><tt class="descclassname">=style</tt><a class="headerlink" href="#cmdoption-ffp-contract" title="Permalink to this definition">¶</a></dt>
<dd><p><em class="xref std std-option">-ffp-contract=off</em> disables floating-point expression contraction.
<em class="xref std std-option">-ffp-contract=fast</em> enables floating-point expression contraction
such as forming of fused multiply-add operations if the target has
native support for them.
<em class="xref std std-option">-ffp-contract=on</em> enables floating-point expression contraction
if allowed by the language standard.  This is currently not implemented
and treated equal to <em class="xref std std-option">-ffp-contract=off</em>.</p>
<p>The default is <em class="xref std std-option">-ffp-contract=fast</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fomit-frame-pointer">
<tt class="descname">-fomit-frame-pointer</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fomit-frame-pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Don&#8217;t keep the frame pointer in a register for functions that
don&#8217;t need one.  This avoids the instructions to save, set up and
restore frame pointers; it also makes an extra register available
in many functions.  It also makes debugging impossible on
some machines.</p>
<p>On some machines, such as the VAX, this flag has no effect, because
the standard calling sequence automatically handles the frame pointer
and nothing is saved by pretending it doesn&#8217;t exist.  The
machine-description macro <tt class="docutils literal"><span class="pre">FRAME_POINTER_REQUIRED</span></tt> controls
whether a target machine supports this flag.  See <em class="xref std std-ref">Register
Usage</em>.</p>
<p>The default setting (when not optimizing for
size) for 32-bit GNU/Linux x86 and 32-bit Darwin x86 targets is
<a class="reference internal" href="#cmdoption-fomit-frame-pointer"><em class="xref std std-option">-fomit-frame-pointer</em></a>.  You can configure GCC with the
<em class="xref std std-option">--enable-frame-pointer</em> configure option to change the default.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-foptimize-sibling-calls">
<tt class="descname">-foptimize-sibling-calls</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-foptimize-sibling-calls" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize sibling and tail recursive calls.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-foptimize-strlen">
<tt class="descname">-foptimize-strlen</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-foptimize-strlen" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize various standard C string functions (e.g. <tt class="docutils literal"><span class="pre">strlen</span></tt>,
<tt class="docutils literal"><span class="pre">strchr</span></tt> or <tt class="docutils literal"><span class="pre">strcpy</span></tt>) and
their <tt class="docutils literal"><span class="pre">_FORTIFY_SOURCE</span></tt> counterparts into faster alternatives.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-inline">
<tt class="descname">-fno-inline</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-inline" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not expand any functions inline apart from those marked with
the <tt class="docutils literal"><span class="pre">always_inline</span></tt> attribute.  This is the default when not
optimizing.</p>
<p>Single functions can be exempted from inlining by marking them
with the <tt class="docutils literal"><span class="pre">noinline</span></tt> attribute.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-finline-small-functions">
<tt class="descname">-finline-small-functions</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-finline-small-functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate functions into their callers when their body is smaller than expected
function call code (so overall size of program gets smaller).  The compiler
heuristically decides which functions are simple enough to be worth integrating
in this way.  This inlining applies to all functions, even those not declared
inline.</p>
<p>Enabled at level <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-findirect-inlining">
<tt class="descname">-findirect-inlining</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-findirect-inlining" title="Permalink to this definition">¶</a></dt>
<dd><p>Inline also indirect calls that are discovered to be known at compile
time thanks to previous inlining.  This option has any effect only
when inlining itself is turned on by the <a class="reference internal" href="#cmdoption-finline-functions"><em class="xref std std-option">-finline-functions</em></a>
or <a class="reference internal" href="#cmdoption-finline-small-functions"><em class="xref std std-option">-finline-small-functions</em></a> options.</p>
<p>Enabled at level <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-finline-functions">
<tt class="descname">-finline-functions</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-finline-functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Consider all functions for inlining, even if they are not declared inline.
The compiler heuristically decides which functions are worth integrating
in this way.</p>
<p>If all calls to a given function are integrated, and the function is
declared <tt class="docutils literal"><span class="pre">static</span></tt>, then the function is normally not output as
assembler code in its own right.</p>
<p>Enabled at level <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-finline-functions-called-once">
<tt class="descname">-finline-functions-called-once</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-finline-functions-called-once" title="Permalink to this definition">¶</a></dt>
<dd><p>Consider all <tt class="docutils literal"><span class="pre">static</span></tt> functions called once for inlining into their
caller even if they are not marked <tt class="docutils literal"><span class="pre">inline</span></tt>.  If a call to a given
function is integrated, then the function is not output as assembler code
in its own right.</p>
<p>Enabled at levels <em class="xref std std-option">-O1</em>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a> and <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fearly-inlining">
<tt class="descname">-fearly-inlining</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fearly-inlining" title="Permalink to this definition">¶</a></dt>
<dd><p>Inline functions marked by <tt class="docutils literal"><span class="pre">always_inline</span></tt> and functions whose body seems
smaller than the function call overhead early before doing
<a class="reference internal" href="#cmdoption-fprofile-generate"><em class="xref std std-option">-fprofile-generate</em></a> instrumentation and real inlining pass.  Doing so
makes profiling significantly cheaper and usually inlining faster on programs
having large chains of nested wrapper functions.</p>
<p>Enabled by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fipa-sra">
<tt class="descname">-fipa-sra</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fipa-sra" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform interprocedural scalar replacement of aggregates, removal of
unused parameters and replacement of parameters passed by reference
by parameters passed by value.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a> and <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-finline-limit">
<tt class="descname">-finline-limit</tt><tt class="descclassname">=n</tt><a class="headerlink" href="#cmdoption-finline-limit" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, GCC limits the size of functions that can be inlined.  This flag
allows coarse control of this limit.  <tt class="docutils literal"><span class="pre">n</span></tt> is the size of functions that
can be inlined in number of pseudo instructions.</p>
<p>Inlining is actually controlled by a number of parameters, which may be
specified individually by using <em class="xref std std-option">--param ``name``=``value``</em>.
The <em class="xref std std-option">-finline-limit=``n``</em> option sets some of these parameters
as follows:</p>
<dl class="docutils">
<dt>max-inline-insns-single</dt>
<dd>is set to <tt class="docutils literal"><span class="pre">n</span></tt>/2.</dd>
<dt>max-inline-insns-auto</dt>
<dd><p class="first">is set to <tt class="docutils literal"><span class="pre">n</span></tt>/2.</p>
<p class="last">See below for a documentation of the individual</p>
</dd>
</dl>
<p>parameters controlling inlining and for the defaults of these parameters.</p>
<p>Note: there may be no value to <a class="reference internal" href="#cmdoption-finline-limit"><em class="xref std std-option">-finline-limit</em></a> that results
in default behavior.</p>
<p>Note: pseudo instruction represents, in this particular context, an
abstract measurement of function&#8217;s size.  In no way does it represent a count
of assembly instructions and as such its exact meaning might change from one
release to an another.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-keep-inline-dllexport">
<tt class="descname">-fno-keep-inline-dllexport</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-keep-inline-dllexport" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a more fine-grained version of <a class="reference internal" href="#cmdoption-fkeep-inline-functions"><em class="xref std std-option">-fkeep-inline-functions</em></a>,
which applies only to functions that are declared using the <tt class="docutils literal"><span class="pre">dllexport</span></tt>
attribute or declspec (See <a class="reference internal" href="declaring-attributes-of-functions.html#function-attributes"><em>Declaring Attributes of
Functions</em></a>.)</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fkeep-inline-functions">
<tt class="descname">-fkeep-inline-functions</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fkeep-inline-functions" title="Permalink to this definition">¶</a></dt>
<dd><p>In C, emit <tt class="docutils literal"><span class="pre">static</span></tt> functions that are declared <tt class="docutils literal"><span class="pre">inline</span></tt>
into the object file, even if the function has been inlined into all
of its callers.  This switch does not affect functions using the
<tt class="docutils literal"><span class="pre">extern</span> <span class="pre">inline</span></tt> extension in GNU C90.  In C++, emit any and all
inline functions into the object file.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fkeep-static-consts">
<tt class="descname">-fkeep-static-consts</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fkeep-static-consts" title="Permalink to this definition">¶</a></dt>
<dd><p>Emit variables declared <tt class="docutils literal"><span class="pre">static</span> <span class="pre">const</span></tt> when optimization isn&#8217;t turned
on, even if the variables aren&#8217;t referenced.</p>
<p>GCC enables this option by default.  If you want to force the compiler to
check if a variable is referenced, regardless of whether or not
optimization is turned on, use the <em class="xref std std-option">-fno-keep-static-consts</em> option.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fmerge-constants">
<tt class="descname">-fmerge-constants</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fmerge-constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to merge identical constants (string constants and floating-point
constants) across compilation units.</p>
<p>This option is the default for optimized compilation if the assembler and
linker support it.  Use <em class="xref std std-option">-fno-merge-constants</em> to inhibit this
behavior.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fmerge-all-constants">
<tt class="descname">-fmerge-all-constants</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fmerge-all-constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to merge identical constants and identical variables.</p>
<p>This option implies <a class="reference internal" href="#cmdoption-fmerge-constants"><em class="xref std std-option">-fmerge-constants</em></a>.  In addition to
<a class="reference internal" href="#cmdoption-fmerge-constants"><em class="xref std std-option">-fmerge-constants</em></a> this considers e.g. even constant initialized
arrays or initialized constant variables with integral or floating-point
types.  Languages like C or C++ require each variable, including multiple
instances of the same variable in recursive calls, to have distinct locations,
so using this option results in non-conforming
behavior.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fmodulo-sched">
<tt class="descname">-fmodulo-sched</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fmodulo-sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform swing modulo scheduling immediately before the first scheduling
pass.  This pass looks at innermost loops and reorders their
instructions by overlapping different iterations.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fmodulo-sched-allow-regmoves">
<tt class="descname">-fmodulo-sched-allow-regmoves</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fmodulo-sched-allow-regmoves" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform more aggressive SMS-based modulo scheduling with register moves
allowed.  By setting this flag certain anti-dependences edges are
deleted, which triggers the generation of reg-moves based on the
life-range analysis.  This option is effective only with
<a class="reference internal" href="#cmdoption-fmodulo-sched"><em class="xref std std-option">-fmodulo-sched</em></a> enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-branch-count-reg">
<tt class="descname">-fno-branch-count-reg</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-branch-count-reg" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not use &#8216;decrement and branch&#8217; instructions on a count register,
but instead generate a sequence of instructions that decrement a
register, compare it against zero, then branch based upon the result.
This option is only meaningful on architectures that support such
instructions, which include x86, PowerPC, IA-64 and S/390.</p>
<p>Enabled by default at <em class="xref std std-option">-O1</em> and higher.</p>
<p>The default is <em class="xref std std-option">-fbranch-count-reg</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-function-cse">
<tt class="descname">-fno-function-cse</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-function-cse" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not put function addresses in registers; make each instruction that
calls a constant function contain the function&#8217;s address explicitly.</p>
<p>This option results in less efficient code, but some strange hacks
that alter the assembler output may be confused by the optimizations
performed when this option is not used.</p>
<p>The default is <em class="xref std std-option">-ffunction-cse</em></p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-zero-initialized-in-bss">
<tt class="descname">-fno-zero-initialized-in-bss</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-zero-initialized-in-bss" title="Permalink to this definition">¶</a></dt>
<dd><p>If the target supports a BSS section, GCC by default puts variables that
are initialized to zero into BSS.  This can save space in the resulting
code.</p>
<p>This option turns off this behavior because some programs explicitly
rely on variables going to the data section-e.g., so that the
resulting executable can find the beginning of that section and/or make
assumptions based on that.</p>
<p>The default is <em class="xref std std-option">-fzero-initialized-in-bss</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fthread-jumps">
<tt class="descname">-fthread-jumps</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fthread-jumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform optimizations that check to see if a jump branches to a
location where another comparison subsumed by the first is found.  If
so, the first branch is redirected to either the destination of the
second branch or a point immediately following it, depending on whether
the condition is known to be true or false.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsplit-wide-types">
<tt class="descname">-fsplit-wide-types</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsplit-wide-types" title="Permalink to this definition">¶</a></dt>
<dd><p>When using a type that occupies multiple registers, such as <tt class="docutils literal"><span class="pre">long</span>
<span class="pre">long</span></tt> on a 32-bit system, split the registers apart and allocate them
independently.  This normally generates better code for those types,
but may make debugging more difficult.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>,
<a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fcse-follow-jumps">
<tt class="descname">-fcse-follow-jumps</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fcse-follow-jumps" title="Permalink to this definition">¶</a></dt>
<dd><p>In common subexpression elimination (CSE), scan through jump instructions
when the target of the jump is not reached by any other path.  For
example, when CSE encounters an <tt class="docutils literal"><span class="pre">if</span></tt> statement with an
<tt class="docutils literal"><span class="pre">else</span></tt> clause, CSE follows the jump when the condition
tested is false.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fcse-skip-blocks">
<tt class="descname">-fcse-skip-blocks</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fcse-skip-blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>This is similar to <a class="reference internal" href="#cmdoption-fcse-follow-jumps"><em class="xref std std-option">-fcse-follow-jumps</em></a>, but causes CSE to
follow jumps that conditionally skip over blocks.  When CSE
encounters a simple <tt class="docutils literal"><span class="pre">if</span></tt> statement with no else clause,
<a class="reference internal" href="#cmdoption-fcse-skip-blocks"><em class="xref std std-option">-fcse-skip-blocks</em></a> causes CSE to follow the jump around the
body of the <tt class="docutils literal"><span class="pre">if</span></tt>.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-frerun-cse-after-loop">
<tt class="descname">-frerun-cse-after-loop</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-frerun-cse-after-loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-run common subexpression elimination after loop optimizations are
performed.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fgcse">
<tt class="descname">-fgcse</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fgcse" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a global common subexpression elimination pass.
This pass also performs global constant and copy propagation.</p>
<p>Note: When compiling a program using computed gotos, a GCC
extension, you may get better run-time performance if you disable
the global common subexpression elimination pass by adding
<em class="xref std std-option">-fno-gcse</em> to the command line.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fgcse-lm">
<tt class="descname">-fgcse-lm</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fgcse-lm" title="Permalink to this definition">¶</a></dt>
<dd><p>When <a class="reference internal" href="#cmdoption-fgcse-lm"><em class="xref std std-option">-fgcse-lm</em></a> is enabled, global common subexpression elimination
attempts to move loads that are only killed by stores into themselves.  This
allows a loop containing a load/store sequence to be changed to a load outside
the loop, and a copy/store within the loop.</p>
<p>Enabled by default when <a class="reference internal" href="#cmdoption-fgcse"><em class="xref std std-option">-fgcse</em></a> is enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fgcse-sm">
<tt class="descname">-fgcse-sm</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fgcse-sm" title="Permalink to this definition">¶</a></dt>
<dd><p>When <a class="reference internal" href="#cmdoption-fgcse-sm"><em class="xref std std-option">-fgcse-sm</em></a> is enabled, a store motion pass is run after
global common subexpression elimination.  This pass attempts to move
stores out of loops.  When used in conjunction with <a class="reference internal" href="#cmdoption-fgcse-lm"><em class="xref std std-option">-fgcse-lm</em></a>,
loops containing a load/store sequence can be changed to a load before
the loop and a store after the loop.</p>
<p>Not enabled at any optimization level.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fgcse-las">
<tt class="descname">-fgcse-las</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fgcse-las" title="Permalink to this definition">¶</a></dt>
<dd><p>When <a class="reference internal" href="#cmdoption-fgcse-las"><em class="xref std std-option">-fgcse-las</em></a> is enabled, the global common subexpression
elimination pass eliminates redundant loads that come after stores to the
same memory location (both partial and full redundancies).</p>
<p>Not enabled at any optimization level.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fgcse-after-reload">
<tt class="descname">-fgcse-after-reload</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fgcse-after-reload" title="Permalink to this definition">¶</a></dt>
<dd><p>When <a class="reference internal" href="#cmdoption-fgcse-after-reload"><em class="xref std std-option">-fgcse-after-reload</em></a> is enabled, a redundant load elimination
pass is performed after reload.  The purpose of this pass is to clean up
redundant spilling.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-faggressive-loop-optimizations">
<tt class="descname">-faggressive-loop-optimizations</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-faggressive-loop-optimizations" title="Permalink to this definition">¶</a></dt>
<dd><p>This option tells the loop optimizer to use language constraints to
derive bounds for the number of iterations of a loop.  This assumes that
loop code does not invoke undefined behavior by for example causing signed
integer overflows or out-of-bound array accesses.  The bounds for the
number of iterations of a loop are used to guide loop unrolling and peeling
and loop exit test optimizations.
This option is enabled by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-funsafe-loop-optimizations">
<tt class="descname">-funsafe-loop-optimizations</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-funsafe-loop-optimizations" title="Permalink to this definition">¶</a></dt>
<dd><p>This option tells the loop optimizer to assume that loop indices do not
overflow, and that loops with nontrivial exit condition are not
infinite.  This enables a wider range of loop optimizations even if
the loop optimizer itself cannot prove that these assumptions are valid.
If you use <a class="reference internal" href="options-to-request-or-suppress-warnings.html#cmdoption-Wunsafe-loop-optimizations"><em class="xref std std-option">-Wunsafe-loop-optimizations</em></a>, the compiler warns you
if it finds this kind of loop.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fcrossjumping">
<tt class="descname">-fcrossjumping</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fcrossjumping" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform cross-jumping transformation.
This transformation unifies equivalent code and saves code size.  The
resulting code may or may not perform better than without cross-jumping.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fauto-inc-dec">
<tt class="descname">-fauto-inc-dec</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fauto-inc-dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine increments or decrements of addresses with memory accesses.
This pass is always skipped on architectures that do not have
instructions to support this.  Enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and
higher on architectures that support this.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fdce">
<tt class="descname">-fdce</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fdce" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform dead code elimination (DCE) on RTL.
Enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fdse">
<tt class="descname">-fdse</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fdse" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform dead store elimination (DSE) on RTL.
Enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fif-conversion">
<tt class="descname">-fif-conversion</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fif-conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to transform conditional jumps into branch-less equivalents.  This
includes use of conditional moves, min, max, set flags and abs instructions, and
some tricks doable by standard arithmetics.  The use of conditional execution
on chips where it is available is controlled by <a class="reference internal" href="#cmdoption-fif-conversion2"><em class="xref std std-option">-fif-conversion2</em></a>.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fif-conversion2">
<tt class="descname">-fif-conversion2</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fif-conversion2" title="Permalink to this definition">¶</a></dt>
<dd><p>Use conditional execution (where available) to transform conditional jumps into
branch-less equivalents.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fdeclone-ctor-dtor">
<tt class="descname">-fdeclone-ctor-dtor</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fdeclone-ctor-dtor" title="Permalink to this definition">¶</a></dt>
<dd><p>The C++ ABI requires multiple entry points for constructors and
destructors: one for a base subobject, one for a complete object, and
one for a virtual destructor that calls operator delete afterwards.
For a hierarchy with virtual bases, the base and complete variants are
clones, which means two copies of the function.  With this option, the
base and complete variants are changed to be thunks that call a common
implementation.</p>
<p>Enabled by <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fdelete-null-pointer-checks">
<tt class="descname">-fdelete-null-pointer-checks</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fdelete-null-pointer-checks" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that programs cannot safely dereference null pointers, and that
no code or data element resides at address zero.
This option enables simple constant
folding optimizations at all optimization levels.  In addition, other
optimization passes in GCC use this flag to control global dataflow
analyses that eliminate useless checks for null pointers; these assume
that a memory access to address zero always results in a trap, so
that if a pointer is checked after it has already been dereferenced,
it cannot be null.</p>
<p>Note however that in some environments this assumption is not true.
Use <em class="xref std std-option">-fno-delete-null-pointer-checks</em> to disable this optimization
for programs that depend on that behavior.</p>
<p>This option is enabled by default on most targets.  On Nios II ELF, it
defaults to off.  On AVR and CR16, this option is completely disabled.</p>
<p>Passes that use the dataflow information
are enabled independently at different optimization levels.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fdevirtualize">
<tt class="descname">-fdevirtualize</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fdevirtualize" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to convert calls to virtual functions to direct calls.  This
is done both within a procedure and interprocedurally as part of
indirect inlining (<a class="reference internal" href="#cmdoption-findirect-inlining"><em class="xref std std-option">-findirect-inlining</em></a>) and interprocedural constant
propagation (<a class="reference internal" href="#cmdoption-fipa-cp"><em class="xref std std-option">-fipa-cp</em></a>).
Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fdevirtualize-speculatively">
<tt class="descname">-fdevirtualize-speculatively</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fdevirtualize-speculatively" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to convert calls to virtual functions to speculative direct calls.
Based on the analysis of the type inheritance graph, determine for a given call
the set of likely targets. If the set is small, preferably of size 1, change
the call into a conditional deciding between direct and indirect calls.  The
speculative calls enable more optimizations, such as inlining.  When they seem
useless after further optimization, they are converted back into original form.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fdevirtualize-at-ltrans">
<tt class="descname">-fdevirtualize-at-ltrans</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fdevirtualize-at-ltrans" title="Permalink to this definition">¶</a></dt>
<dd><p>Stream extra information needed for aggressive devirtualization when running
the link-time optimizer in local transformation mode.
This option enables more devirtualization but
significantly increases the size of streamed data. For this reason it is
disabled by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fexpensive-optimizations">
<tt class="descname">-fexpensive-optimizations</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fexpensive-optimizations" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a number of minor optimizations that are relatively expensive.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-free">
<tt class="descname">-free</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-free" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to remove redundant extension instructions.  This is especially
helpful for the x86-64 architecture, which implicitly zero-extends in 64-bit
registers after writing to their lower 32-bit half.</p>
<p>Enabled for Alpha, AArch64 and x86 at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>,
<a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-lifetime-dse">
<tt class="descname">-fno-lifetime-dse</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-lifetime-dse" title="Permalink to this definition">¶</a></dt>
<dd><p>In C++ the value of an object is only affected by changes within its
lifetime: when the constructor begins, the object has an indeterminate
value, and any changes during the lifetime of the object are dead when
the object is destroyed.  Normally dead store elimination will take
advantage of this; if your code relies on the value of the object
storage persisting beyond the lifetime of the object, you can use this
flag to disable this optimization.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-flive-range-shrinkage">
<tt class="descname">-flive-range-shrinkage</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-flive-range-shrinkage" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to decrease register pressure through register live range
shrinkage.  This is helpful for fast processors with small or moderate
size register sets.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fira-algorithm">
<tt class="descname">-fira-algorithm</tt><tt class="descclassname">=algorithm</tt><a class="headerlink" href="#cmdoption-fira-algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the specified coloring algorithm for the integrated register
allocator.  The <tt class="docutils literal"><span class="pre">algorithm</span></tt> argument can be priority, which
specifies Chow&#8217;s priority coloring, or CB, which specifies
Chaitin-Briggs coloring.  Chaitin-Briggs coloring is not implemented
for all architectures, but for those targets that do support it, it is
the default because it generates better code.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fira-region">
<tt class="descname">-fira-region</tt><tt class="descclassname">=region</tt><a class="headerlink" href="#cmdoption-fira-region" title="Permalink to this definition">¶</a></dt>
<dd><p>Use specified regions for the integrated register allocator.  The
<tt class="docutils literal"><span class="pre">region</span></tt> argument should be one of the following:</p>
<dl class="docutils">
<dt>all</dt>
<dd>Use all loops as register allocation regions.
This can give the best results for machines with a small and/or
irregular register set.</dd>
<dt>mixed</dt>
<dd>Use all loops except for loops with small register pressure
as the regions.  This value usually gives
the best results in most cases and for most architectures,
and is enabled by default when compiling with optimization for speed
(<a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, ...).</dd>
<dt>one</dt>
<dd>Use all functions as a single region.
This typically results in the smallest code size, and is enabled by default for
<a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a> or <a class="reference internal" href="#cmdoption-O0"><em class="xref std std-option">-O0</em></a>.</dd>
</dl>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fira-hoist-pressure">
<tt class="descname">-fira-hoist-pressure</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fira-hoist-pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Use IRA to evaluate register pressure in the code hoisting pass for
decisions to hoist expressions.  This option usually results in smaller
code, but it can slow the compiler down.</p>
<p>This option is enabled at level <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a> for all targets.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fira-loop-pressure">
<tt class="descname">-fira-loop-pressure</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fira-loop-pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Use IRA to evaluate register pressure in loops for decisions to move
loop invariants.  This option usually results in generation
of faster and smaller code on machines with large register files (&gt;= 32
registers), but it can slow the compiler down.</p>
<p>This option is enabled at level <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a> for some targets.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-ira-share-save-slots">
<tt class="descname">-fno-ira-share-save-slots</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-ira-share-save-slots" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable sharing of stack slots used for saving call-used hard
registers living through a call.  Each hard register gets a
separate stack slot, and as a result function stack frames are
larger.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-ira-share-spill-slots">
<tt class="descname">-fno-ira-share-spill-slots</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-ira-share-spill-slots" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable sharing of stack slots allocated for pseudo-registers.  Each
pseudo-register that does not get a hard register gets a separate
stack slot, and as a result function stack frames are larger.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fira-verbose">
<tt class="descname">-fira-verbose</tt><tt class="descclassname">=n</tt><a class="headerlink" href="#cmdoption-fira-verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>Control the verbosity of the dump file for the integrated register allocator.
The default value is 5.  If the value <tt class="docutils literal"><span class="pre">n</span></tt> is greater or equal to 10,
the dump output is sent to stderr using the same format as <tt class="docutils literal"><span class="pre">n</span></tt> minus 10.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-flra-remat">
<tt class="descname">-flra-remat</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-flra-remat" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable CFG-sensitive rematerialization in LRA.  Instead of loading
values of spilled pseudos, LRA tries to rematerialize (recalculate)
values if it is profitable.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fdelayed-branch">
<tt class="descname">-fdelayed-branch</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fdelayed-branch" title="Permalink to this definition">¶</a></dt>
<dd><p>If supported for the target machine, attempt to reorder instructions
to exploit instruction slots available after delayed branch
instructions.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fschedule-insns">
<tt class="descname">-fschedule-insns</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fschedule-insns" title="Permalink to this definition">¶</a></dt>
<dd><p>If supported for the target machine, attempt to reorder instructions to
eliminate execution stalls due to required data being unavailable.  This
helps machines that have slow floating point or memory load instructions
by allowing other instructions to be issued until the result of the load
or floating-point instruction is required.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fschedule-insns2">
<tt class="descname">-fschedule-insns2</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fschedule-insns2" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a>, but requests an additional pass of
instruction scheduling after register allocation has been done.  This is
especially useful on machines with a relatively small number of
registers and where memory load instructions take more than one cycle.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-sched-interblock">
<tt class="descname">-fno-sched-interblock</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-sched-interblock" title="Permalink to this definition">¶</a></dt>
<dd><p>Don&#8217;t schedule instructions across basic blocks.  This is normally
enabled by default when scheduling before register allocation, i.e.
with <a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a> or at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-sched-spec">
<tt class="descname">-fno-sched-spec</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-sched-spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Don&#8217;t allow speculative motion of non-load instructions.  This is normally
enabled by default when scheduling before register allocation, i.e.
with <a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a> or at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched-pressure">
<tt class="descname">-fsched-pressure</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched-pressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable register pressure sensitive insn scheduling before register
allocation.  This only makes sense when scheduling before register
allocation is enabled, i.e. with <a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a> or at
<a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.  Usage of this option can improve the
generated code and decrease its size by preventing register pressure
increase above the number of available hard registers and subsequent
spills in register allocation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched-spec-load">
<tt class="descname">-fsched-spec-load</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched-spec-load" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow speculative motion of some load instructions.  This only makes
sense when scheduling before register allocation, i.e. with
<a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a> or at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched-spec-load-dangerous">
<tt class="descname">-fsched-spec-load-dangerous</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched-spec-load-dangerous" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow speculative motion of more load instructions.  This only makes
sense when scheduling before register allocation, i.e. with
<a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a> or at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched-stalled-insns">
<tt class="descname">-fsched-stalled-insns</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched-stalled-insns" title="Permalink to this definition">¶</a></dt>
<dd><p>Define how many insns (if any) can be moved prematurely from the queue
of stalled insns into the ready list during the second scheduling pass.
<em class="xref std std-option">-fno-sched-stalled-insns</em> means that no insns are moved
prematurely, <em class="xref std std-option">-fsched-stalled-insns=0</em> means there is no limit
on how many queued insns can be moved prematurely.
<a class="reference internal" href="#cmdoption-fsched-stalled-insns"><em class="xref std std-option">-fsched-stalled-insns</em></a> without a value is equivalent to
<em class="xref std std-option">-fsched-stalled-insns=1</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched-stalled-insns-dep">
<tt class="descname">-fsched-stalled-insns-dep</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched-stalled-insns-dep" title="Permalink to this definition">¶</a></dt>
<dd><p>Define how many insn groups (cycles) are examined for a dependency
on a stalled insn that is a candidate for premature removal from the queue
of stalled insns.  This has an effect only during the second scheduling pass,
and only if <a class="reference internal" href="#cmdoption-fsched-stalled-insns"><em class="xref std std-option">-fsched-stalled-insns</em></a> is used.
<em class="xref std std-option">-fno-sched-stalled-insns-dep</em> is equivalent to
<em class="xref std std-option">-fsched-stalled-insns-dep=0</em>.
<a class="reference internal" href="#cmdoption-fsched-stalled-insns-dep"><em class="xref std std-option">-fsched-stalled-insns-dep</em></a> without a value is equivalent to
<em class="xref std std-option">-fsched-stalled-insns-dep=1</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched2-use-superblocks">
<tt class="descname">-fsched2-use-superblocks</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched2-use-superblocks" title="Permalink to this definition">¶</a></dt>
<dd><p>When scheduling after register allocation, use superblock scheduling.
This allows motion across basic block boundaries,
resulting in faster schedules.  This option is experimental, as not all machine
descriptions used by GCC model the CPU closely enough to avoid unreliable
results from the algorithm.</p>
<p>This only makes sense when scheduling after register allocation, i.e. with
<a class="reference internal" href="#cmdoption-fschedule-insns2"><em class="xref std std-option">-fschedule-insns2</em></a> or at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched-group-heuristic">
<tt class="descname">-fsched-group-heuristic</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched-group-heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the group heuristic in the scheduler.  This heuristic favors
the instruction that belongs to a schedule group.  This is enabled
by default when scheduling is enabled, i.e. with <a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a>
or <a class="reference internal" href="#cmdoption-fschedule-insns2"><em class="xref std std-option">-fschedule-insns2</em></a> or at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched-critical-path-heuristic">
<tt class="descname">-fsched-critical-path-heuristic</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched-critical-path-heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the critical-path heuristic in the scheduler.  This heuristic favors
instructions on the critical path.  This is enabled by default when
scheduling is enabled, i.e. with <a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a>
or <a class="reference internal" href="#cmdoption-fschedule-insns2"><em class="xref std std-option">-fschedule-insns2</em></a> or at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched-spec-insn-heuristic">
<tt class="descname">-fsched-spec-insn-heuristic</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched-spec-insn-heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the speculative instruction heuristic in the scheduler.  This
heuristic favors speculative instructions with greater dependency weakness.
This is enabled by default when scheduling is enabled, i.e.
with <a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a> or <a class="reference internal" href="#cmdoption-fschedule-insns2"><em class="xref std std-option">-fschedule-insns2</em></a>
or at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched-rank-heuristic">
<tt class="descname">-fsched-rank-heuristic</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched-rank-heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the rank heuristic in the scheduler.  This heuristic favors
the instruction belonging to a basic block with greater size or frequency.
This is enabled by default when scheduling is enabled, i.e.
with <a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a> or <a class="reference internal" href="#cmdoption-fschedule-insns2"><em class="xref std std-option">-fschedule-insns2</em></a> or
at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched-last-insn-heuristic">
<tt class="descname">-fsched-last-insn-heuristic</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched-last-insn-heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the last-instruction heuristic in the scheduler.  This heuristic
favors the instruction that is less dependent on the last instruction
scheduled.  This is enabled by default when scheduling is enabled,
i.e. with <a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a> or <a class="reference internal" href="#cmdoption-fschedule-insns2"><em class="xref std std-option">-fschedule-insns2</em></a> or
at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsched-dep-count-heuristic">
<tt class="descname">-fsched-dep-count-heuristic</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsched-dep-count-heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the dependent-count heuristic in the scheduler.  This heuristic
favors the instruction that has more instructions depending on it.
This is enabled by default when scheduling is enabled, i.e.
with <a class="reference internal" href="#cmdoption-fschedule-insns"><em class="xref std std-option">-fschedule-insns</em></a> or <a class="reference internal" href="#cmdoption-fschedule-insns2"><em class="xref std std-option">-fschedule-insns2</em></a> or
at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-freschedule-modulo-scheduled-loops">
<tt class="descname">-freschedule-modulo-scheduled-loops</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-freschedule-modulo-scheduled-loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Modulo scheduling is performed before traditional scheduling.  If a loop
is modulo scheduled, later scheduling passes may change its schedule.
Use this option to control that behavior.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fselective-scheduling">
<tt class="descname">-fselective-scheduling</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fselective-scheduling" title="Permalink to this definition">¶</a></dt>
<dd><p>Schedule instructions using selective scheduling algorithm.  Selective
scheduling runs instead of the first scheduler pass.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fselective-scheduling2">
<tt class="descname">-fselective-scheduling2</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fselective-scheduling2" title="Permalink to this definition">¶</a></dt>
<dd><p>Schedule instructions using selective scheduling algorithm.  Selective
scheduling runs instead of the second scheduler pass.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsel-sched-pipelining">
<tt class="descname">-fsel-sched-pipelining</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsel-sched-pipelining" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable software pipelining of innermost loops during selective scheduling.
This option has no effect unless one of <a class="reference internal" href="#cmdoption-fselective-scheduling"><em class="xref std std-option">-fselective-scheduling</em></a> or
<a class="reference internal" href="#cmdoption-fselective-scheduling2"><em class="xref std std-option">-fselective-scheduling2</em></a> is turned on.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsel-sched-pipelining-outer-loops">
<tt class="descname">-fsel-sched-pipelining-outer-loops</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsel-sched-pipelining-outer-loops" title="Permalink to this definition">¶</a></dt>
<dd><p>When pipelining loops during selective scheduling, also pipeline outer loops.
This option has no effect unless <a class="reference internal" href="#cmdoption-fsel-sched-pipelining"><em class="xref std std-option">-fsel-sched-pipelining</em></a> is turned on.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsemantic-interposition">
<tt class="descname">-fsemantic-interposition</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsemantic-interposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Some object formats, like ELF, allow interposing of symbols by the
dynamic linker.
This means that for symbols exported from the DSO, the compiler cannot perform
interprocedural propagation, inlining and other optimizations in anticipation
that the function or variable in question may change. While this feature is
useful, for example, to rewrite memory allocation functions by a debugging
implementation, it is expensive in the terms of code quality.
With <em class="xref std std-option">-fno-semantic-interposition</em> the compiler assumes that
if interposition happens for functions the overwriting function will have
precisely the same semantics (and side effects).
Similarly if interposition happens
for variables, the constructor of the variable will be the same. The flag
has no effect for functions explicitly declared inline
(where it is never allowed for interposition to change semantics)
and for symbols explicitly declared weak.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fshrink-wrap">
<tt class="descname">-fshrink-wrap</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fshrink-wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Emit function prologues only before parts of the function that need it,
rather than at the top of the function.  This flag is enabled by default at
<a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fcaller-saves">
<tt class="descname">-fcaller-saves</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fcaller-saves" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable allocation of values to registers that are clobbered by
function calls, by emitting extra instructions to save and restore the
registers around such calls.  Such allocation is done only when it
seems to result in better code.</p>
<p>This option is always enabled by default on certain machines, usually
those which have no call-preserved registers to use instead.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fcombine-stack-adjustments">
<tt class="descname">-fcombine-stack-adjustments</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fcombine-stack-adjustments" title="Permalink to this definition">¶</a></dt>
<dd><p>Tracks stack adjustments (pushes and pops) and stack memory references
and then tries to find ways to combine them.</p>
<p>Enabled by default at <em class="xref std std-option">-O1</em> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fipa-ra">
<tt class="descname">-fipa-ra</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fipa-ra" title="Permalink to this definition">¶</a></dt>
<dd><p>Use caller save registers for allocation if those registers are not used by
any called function.  In that case it is not necessary to save and restore
them around calls.  This is only possible if called functions are part of
same compilation unit as current function and they are compiled before it.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fconserve-stack">
<tt class="descname">-fconserve-stack</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fconserve-stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to minimize stack usage.  The compiler attempts to use less
stack space, even if that makes the program slower.  This option
implies setting the large-stack-frame parameter to 100
and the large-stack-frame-growth parameter to 400.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-reassoc">
<tt class="descname">-ftree-reassoc</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-reassoc" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform reassociation on trees.  This flag is enabled by default
at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-pre">
<tt class="descname">-ftree-pre</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-pre" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform partial redundancy elimination (PRE) on trees.  This flag is
enabled by default at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> and <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-partial-pre">
<tt class="descname">-ftree-partial-pre</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-partial-pre" title="Permalink to this definition">¶</a></dt>
<dd><p>Make partial redundancy elimination (PRE) more aggressive.  This flag is
enabled by default at <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-forwprop">
<tt class="descname">-ftree-forwprop</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-forwprop" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform forward propagation on trees.  This flag is enabled by default
at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-fre">
<tt class="descname">-ftree-fre</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-fre" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform full redundancy elimination (FRE) on trees.  The difference
between FRE and PRE is that FRE only considers expressions
that are computed on all paths leading to the redundant computation.
This analysis is faster than PRE, though it exposes fewer redundancies.
This flag is enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-phiprop">
<tt class="descname">-ftree-phiprop</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-phiprop" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform hoisting of loads from conditional pointers on trees.  This
pass is enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fhoist-adjacent-loads">
<tt class="descname">-fhoist-adjacent-loads</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fhoist-adjacent-loads" title="Permalink to this definition">¶</a></dt>
<dd><p>Speculatively hoist loads from both branches of an if-then-else if the
loads are from adjacent locations in the same structure and the target
architecture has a conditional move instruction.  This flag is enabled
by default at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-copy-prop">
<tt class="descname">-ftree-copy-prop</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-copy-prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform copy propagation on trees.  This pass eliminates unnecessary
copy operations.  This flag is enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and
higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fipa-pure-const">
<tt class="descname">-fipa-pure-const</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fipa-pure-const" title="Permalink to this definition">¶</a></dt>
<dd><p>Discover which functions are pure or constant.
Enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fipa-reference">
<tt class="descname">-fipa-reference</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fipa-reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Discover which static variables do not escape the
compilation unit.
Enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fipa-pta">
<tt class="descname">-fipa-pta</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fipa-pta" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform interprocedural pointer analysis and interprocedural modification
and reference analysis.  This option can cause excessive memory and
compile-time usage on large compilation units.  It is not enabled by
default at any optimization level.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fipa-profile">
<tt class="descname">-fipa-profile</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fipa-profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform interprocedural profile propagation.  The functions called only from
cold functions are marked as cold. Also functions executed once (such as
<tt class="docutils literal"><span class="pre">cold</span></tt>, <tt class="docutils literal"><span class="pre">noreturn</span></tt>, static constructors or destructors) are identified. Cold
functions and loop less parts of functions executed once are then optimized for
size.
Enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fipa-cp">
<tt class="descname">-fipa-cp</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fipa-cp" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform interprocedural constant propagation.
This optimization analyzes the program to determine when values passed
to functions are constants and then optimizes accordingly.
This optimization can substantially increase performance
if the application has constants passed to functions.
This flag is enabled by default at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a> and <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fipa-cp-clone">
<tt class="descname">-fipa-cp-clone</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fipa-cp-clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform function cloning to make interprocedural constant propagation stronger.
When enabled, interprocedural constant propagation performs function cloning
when externally visible function can be called with constant arguments.
Because this optimization can create multiple copies of functions,
it may significantly increase code size
(see <em class="xref std std-option">--param ipcp-unit-growth=``value``</em>).
This flag is enabled by default at <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fipa-cp-alignment">
<tt class="descname">-fipa-cp-alignment</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fipa-cp-alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>When enabled, this optimization propagates alignment of function
parameters to support better vectorization and string operations.</p>
<p>This flag is enabled by default at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> and <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.  It
requires that <a class="reference internal" href="#cmdoption-fipa-cp"><em class="xref std std-option">-fipa-cp</em></a> is enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fipa-icf">
<tt class="descname">-fipa-icf</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fipa-icf" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Identical Code Folding for functions and read-only variables.
The optimization reduces code size and may disturb unwind stacks by replacing
a function by equivalent one with a different name. The optimization works
more effectively with link time optimization enabled.</p>
<p>Nevertheless the behavior is similar to Gold Linker ICF optimization, GCC ICF
works on different levels and thus the optimizations are not same - there are
equivalences that are found only by GCC and equivalences found only by Gold.</p>
<p>This flag is enabled by default at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> and <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fisolate-erroneous-paths-dereference">
<tt class="descname">-fisolate-erroneous-paths-dereference</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fisolate-erroneous-paths-dereference" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect paths that trigger erroneous or undefined behavior due to
dereferencing a null pointer.  Isolate those paths from the main control
flow and turn the statement with erroneous or undefined behavior into a trap.
This flag is enabled by default at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> and higher and depends on
<a class="reference internal" href="#cmdoption-fdelete-null-pointer-checks"><em class="xref std std-option">-fdelete-null-pointer-checks</em></a> also being enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fisolate-erroneous-paths-attribute">
<tt class="descname">-fisolate-erroneous-paths-attribute</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fisolate-erroneous-paths-attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect paths that trigger erroneous or undefined behavior due a null value
being used in a way forbidden by a <tt class="docutils literal"><span class="pre">returns_nonnull</span></tt> or <tt class="docutils literal"><span class="pre">nonnull</span></tt>
attribute.  Isolate those paths from the main control flow and turn the
statement with erroneous or undefined behavior into a trap.  This is not
currently enabled, but may be enabled by <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> in the future.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-sink">
<tt class="descname">-ftree-sink</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-sink" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform forward store motion  on trees.  This flag is
enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-bit-ccp">
<tt class="descname">-ftree-bit-ccp</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-bit-ccp" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sparse conditional bit constant propagation on trees and propagate
pointer alignment information.
This pass only operates on local scalar variables and is enabled by default
at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.  It requires that <a class="reference internal" href="#cmdoption-ftree-ccp"><em class="xref std std-option">-ftree-ccp</em></a> is enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-ccp">
<tt class="descname">-ftree-ccp</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-ccp" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sparse conditional constant propagation (CCP) on trees.  This
pass only operates on local scalar variables and is enabled by default
at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fssa-phiopt">
<tt class="descname">-fssa-phiopt</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fssa-phiopt" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform pattern matching on SSA PHI nodes to optimize conditional
code.  This pass is enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-switch-conversion">
<tt class="descname">-ftree-switch-conversion</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-switch-conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform conversion of simple initializations in a switch to
initializations from a scalar array.  This flag is enabled by default
at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-tail-merge">
<tt class="descname">-ftree-tail-merge</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-tail-merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Look for identical code sequences.  When found, replace one with a jump to the
other.  This optimization is known as tail merging or cross jumping.  This flag
is enabled by default at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> and higher.  The compilation time
in this pass can
be limited using max-tail-merge-comparisons parameter and
max-tail-merge-iterations parameter.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-dce">
<tt class="descname">-ftree-dce</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-dce" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform dead code elimination (DCE) on trees.  This flag is enabled by
default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-builtin-call-dce">
<tt class="descname">-ftree-builtin-call-dce</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-builtin-call-dce" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform conditional dead code elimination (DCE) for calls to built-in functions
that may set <tt class="docutils literal"><span class="pre">errno</span></tt> but are otherwise side-effect free.  This flag is
enabled by default at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> and higher if <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a> is not also
specified.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-dominator-opts">
<tt class="descname">-ftree-dominator-opts</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-dominator-opts" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a variety of simple scalar cleanups (constant/copy
propagation, redundancy elimination, range propagation and expression
simplification) based on a dominator tree traversal.  This also
performs jump threading (to reduce jumps to jumps). This flag is
enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-dse">
<tt class="descname">-ftree-dse</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-dse" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform dead store elimination (DSE) on trees.  A dead store is a store into
a memory location that is later overwritten by another store without
any intervening loads.  In this case the earlier store can be deleted.  This
flag is enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-ch">
<tt class="descname">-ftree-ch</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-ch" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform loop header copying on trees.  This is beneficial since it increases
effectiveness of code motion optimizations.  It also saves one jump.  This flag
is enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.  It is not enabled
for <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>, since it usually increases code size.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-loop-optimize">
<tt class="descname">-ftree-loop-optimize</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-loop-optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform loop optimizations on trees.  This flag is enabled by default
at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-loop-linear">
<tt class="descname">-ftree-loop-linear</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-loop-linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform loop interchange transformations on tree.  Same as
<a class="reference internal" href="#cmdoption-floop-interchange"><em class="xref std std-option">-floop-interchange</em></a>.  To use this code transformation, GCC has
to be configured with <em class="xref std std-option">--with-isl</em> to enable the Graphite loop
transformation infrastructure.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-floop-interchange">
<tt class="descname">-floop-interchange</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-floop-interchange" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform loop interchange transformations on loops.  Interchanging two
nested loops switches the inner and outer loops.  For example, given a
loop like:</p>
<div class="highlight-fortran"><div class="highlight"><pre><span class="k">DO </span><span class="nv">J</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">M</span>
  <span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span>
    <span class="nv">A</span><span class="p">(</span><span class="nv">J</span><span class="p">,</span> <span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">A</span><span class="p">(</span><span class="nv">J</span><span class="p">,</span> <span class="nv">I</span><span class="p">)</span> <span class="o">*</span> <span class="nv">C</span>
  <span class="nv">ENDDO</span>
<span class="nv">ENDDO</span>
</pre></div>
</div>
<p>loop interchange transforms the loop as if it were written:</p>
<div class="highlight-fortran"><div class="highlight"><pre><span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span>
  <span class="k">DO </span><span class="nv">J</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">M</span>
    <span class="nv">A</span><span class="p">(</span><span class="nv">J</span><span class="p">,</span> <span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">A</span><span class="p">(</span><span class="nv">J</span><span class="p">,</span> <span class="nv">I</span><span class="p">)</span> <span class="o">*</span> <span class="nv">C</span>
  <span class="nv">ENDDO</span>
<span class="nv">ENDDO</span>
</pre></div>
</div>
<p>which can be beneficial when <tt class="docutils literal"><span class="pre">N</span></tt> is larger than the caches,
because in Fortran, the elements of an array are stored in memory
contiguously by column, and the original loop iterates over rows,
potentially creating at each access a cache miss.  This optimization
applies to all the languages supported by GCC and is not limited to
Fortran.  To use this code transformation, GCC has to be configured
with <em class="xref std std-option">--with-isl</em> to enable the Graphite loop transformation
infrastructure.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-floop-strip-mine">
<tt class="descname">-floop-strip-mine</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-floop-strip-mine" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform loop strip mining transformations on loops.  Strip mining
splits a loop into two nested loops.  The outer loop has strides
equal to the strip size and the inner loop has strides of the
original loop within a strip.  The strip length can be changed
using the loop-block-tile-size parameter.  For example,
given a loop like:</p>
<div class="highlight-fortran"><div class="highlight"><pre><span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span>
  <span class="nv">A</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">A</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">+</span> <span class="nv">C</span>
<span class="nv">ENDDO</span>
</pre></div>
</div>
<p>loop strip mining transforms the loop as if it were written:</p>
<div class="highlight-fortran"><div class="highlight"><pre><span class="k">DO </span><span class="nv">II</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="mi">51</span>
  <span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="nv">II</span><span class="p">,</span> <span class="nb">min</span> <span class="p">(</span><span class="nv">II</span> <span class="o">+</span> <span class="mi">50</span><span class="p">,</span> <span class="nv">N</span><span class="p">)</span>
    <span class="nv">A</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">A</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">+</span> <span class="nv">C</span>
  <span class="nv">ENDDO</span>
<span class="nv">ENDDO</span>
</pre></div>
</div>
<p>This optimization applies to all the languages supported by GCC and is
not limited to Fortran.  To use this code transformation, GCC has to
be configured with <em class="xref std std-option">--with-isl</em> to enable the Graphite loop
transformation infrastructure.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-floop-block">
<tt class="descname">-floop-block</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-floop-block" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform loop blocking transformations on loops.  Blocking strip mines
each loop in the loop nest such that the memory accesses of the
element loops fit inside caches.  The strip length can be changed
using the loop-block-tile-size parameter.  For example, given
a loop like:</p>
<div class="highlight-fortran"><div class="highlight"><pre><span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span>
  <span class="k">DO </span><span class="nv">J</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">M</span>
    <span class="nv">A</span><span class="p">(</span><span class="nv">J</span><span class="p">,</span> <span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">B</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">+</span> <span class="nv">C</span><span class="p">(</span><span class="nv">J</span><span class="p">)</span>
  <span class="nv">ENDDO</span>
<span class="nv">ENDDO</span>
</pre></div>
</div>
<p>loop blocking transforms the loop as if it were written:</p>
<div class="highlight-fortran"><div class="highlight"><pre><span class="k">DO </span><span class="nv">II</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="mi">51</span>
  <span class="k">DO </span><span class="nv">JJ</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">M</span><span class="p">,</span> <span class="mi">51</span>
    <span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="nv">II</span><span class="p">,</span> <span class="nb">min</span> <span class="p">(</span><span class="nv">II</span> <span class="o">+</span> <span class="mi">50</span><span class="p">,</span> <span class="nv">N</span><span class="p">)</span>
      <span class="k">DO </span><span class="nv">J</span> <span class="o">=</span> <span class="nv">JJ</span><span class="p">,</span> <span class="nb">min</span> <span class="p">(</span><span class="nv">JJ</span> <span class="o">+</span> <span class="mi">50</span><span class="p">,</span> <span class="nv">M</span><span class="p">)</span>
        <span class="nv">A</span><span class="p">(</span><span class="nv">J</span><span class="p">,</span> <span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">B</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">+</span> <span class="nv">C</span><span class="p">(</span><span class="nv">J</span><span class="p">)</span>
      <span class="nv">ENDDO</span>
    <span class="nv">ENDDO</span>
  <span class="nv">ENDDO</span>
<span class="nv">ENDDO</span>
</pre></div>
</div>
<p>which can be beneficial when <tt class="docutils literal"><span class="pre">M</span></tt> is larger than the caches,
because the innermost loop iterates over a smaller amount of data
which can be kept in the caches.  This optimization applies to all the
languages supported by GCC and is not limited to Fortran.  To use this
code transformation, GCC has to be configured with <em class="xref std std-option">--with-isl</em>
to enable the Graphite loop transformation infrastructure.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fgraphite-identity">
<tt class="descname">-fgraphite-identity</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fgraphite-identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the identity transformation for graphite.  For every SCoP we generate
the polyhedral representation and transform it back to gimple.  Using
<a class="reference internal" href="#cmdoption-fgraphite-identity"><em class="xref std std-option">-fgraphite-identity</em></a> we can check the costs or benefits of the
GIMPLE -&gt; GRAPHITE -&gt; GIMPLE transformation.  Some minimal optimizations
are also performed by the code generator ISL, like index splitting and
dead code elimination in loops.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-floop-nest-optimize">
<tt class="descname">-floop-nest-optimize</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-floop-nest-optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the ISL based loop nest optimizer.  This is a generic loop nest
optimizer based on the Pluto optimization algorithms.  It calculates a loop
structure optimized for data-locality and parallelism.  This option
is experimental.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-floop-unroll-and-jam">
<tt class="descname">-floop-unroll-and-jam</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-floop-unroll-and-jam" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable unroll and jam for the ISL based loop nest optimizer.  The unroll
factor can be changed using the loop-unroll-jam-size parameter.
The unrolled dimension (counting from the most inner one) can be changed
using the loop-unroll-jam-depth parameter.                 .</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-floop-parallelize-all">
<tt class="descname">-floop-parallelize-all</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-floop-parallelize-all" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the Graphite data dependence analysis to identify loops that can
be parallelized.  Parallelize all the loops that can be analyzed to
not contain loop carried dependences without checking that it is
profitable to parallelize the loops.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fcheck-data-deps">
<tt class="descname">-fcheck-data-deps</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fcheck-data-deps" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the results of several data dependence analyzers.  This option
is used for debugging the data dependence analyzers.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-loop-if-convert">
<tt class="descname">-ftree-loop-if-convert</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-loop-if-convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to transform conditional jumps in the innermost loops to
branch-less equivalents.  The intent is to remove control-flow from
the innermost loops in order to improve the ability of the
vectorization pass to handle these loops.  This is enabled by default
if vectorization is enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-loop-if-convert-stores">
<tt class="descname">-ftree-loop-if-convert-stores</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-loop-if-convert-stores" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to also if-convert conditional jumps containing memory writes.
This transformation can be unsafe for multi-threaded programs as it
transforms conditional memory writes into unconditional memory writes.
For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cond</span><span class="p">)</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span><span class="p">;</span>
</pre></div>
</div>
<p>is transformed to</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">?</span> <span class="n">expr</span> <span class="o">:</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<p>potentially producing data races.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-loop-distribution">
<tt class="descname">-ftree-loop-distribution</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-loop-distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform loop distribution.  This flag can improve cache performance on
big loop bodies and allow further loop optimizations, like
parallelization or vectorization, to take place.  For example, the loop</p>
<div class="highlight-fortran"><div class="highlight"><pre><span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span>
  <span class="nv">A</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">B</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">+</span> <span class="nv">C</span>
  <span class="nv">D</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">E</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">*</span> <span class="nv">F</span>
<span class="nv">ENDDO</span>
</pre></div>
</div>
<p>is transformed to</p>
<div class="highlight-fortran"><div class="highlight"><pre><span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span>
   <span class="nv">A</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">B</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">+</span> <span class="nv">C</span>
<span class="nv">ENDDO</span>
<span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span>
   <span class="nv">D</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">E</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">*</span> <span class="nv">F</span>
<span class="nv">ENDDO</span>
</pre></div>
</div>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-loop-distribute-patterns">
<tt class="descname">-ftree-loop-distribute-patterns</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-loop-distribute-patterns" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform loop distribution of patterns that can be code generated with
calls to a library.  This flag is enabled by default at <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
<p>This pass distributes the initialization loops and generates a call to
memset zero.  For example, the loop</p>
<div class="highlight-fortran"><div class="highlight"><pre><span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span>
  <span class="nv">A</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nv">B</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">A</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">+</span> <span class="nv">I</span>
<span class="nv">ENDDO</span>
</pre></div>
</div>
<p>is transformed to</p>
<div class="highlight-fortran"><div class="highlight"><pre><span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span>
   <span class="nv">A</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nv">ENDDO</span>
<span class="k">DO </span><span class="nv">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">N</span>
   <span class="nv">B</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">=</span> <span class="nv">A</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">+</span> <span class="nv">I</span>
<span class="nv">ENDDO</span>
</pre></div>
</div>
<p>and the initialization loop is transformed into a call to memset zero.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-loop-im">
<tt class="descname">-ftree-loop-im</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-loop-im" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform loop invariant motion on trees.  This pass moves only invariants that
are hard to handle at RTL level (function calls, operations that expand to
nontrivial sequences of insns).  With <a class="reference internal" href="#cmdoption-funswitch-loops"><em class="xref std std-option">-funswitch-loops</em></a> it also moves
operands of conditions that are invariant out of the loop, so that we can use
just trivial invariantness analysis in loop unswitching.  The pass also includes
store motion.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-loop-ivcanon">
<tt class="descname">-ftree-loop-ivcanon</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-loop-ivcanon" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a canonical counter for number of iterations in loops for which
determining number of iterations requires complicated analysis.  Later
optimizations then may determine the number easily.  Useful especially
in connection with unrolling.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fivopts">
<tt class="descname">-fivopts</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fivopts" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform induction variable optimizations (strength reduction, induction
variable merging and induction variable elimination) on trees.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-parallelize-loops">
<tt class="descname">-ftree-parallelize-loops</tt><tt class="descclassname">=n</tt><a class="headerlink" href="#cmdoption-ftree-parallelize-loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallelize loops, i.e., split their iteration space to run in n threads.
This is only possible for loops whose iterations are independent
and can be arbitrarily reordered.  The optimization is only
profitable on multiprocessor machines, for loops that are CPU-intensive,
rather than constrained e.g. by memory bandwidth.  This option
implies <a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-pthread"><em class="xref std std-option">-pthread</em></a>, and thus is only supported on targets
that have support for <a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-pthread"><em class="xref std std-option">-pthread</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-pta">
<tt class="descname">-ftree-pta</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-pta" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform function-local points-to analysis on trees.  This flag is
enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-sra">
<tt class="descname">-ftree-sra</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-sra" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform scalar replacement of aggregates.  This pass replaces structure
references with scalars to prevent committing structures to memory too
early.  This flag is enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-copyrename">
<tt class="descname">-ftree-copyrename</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-copyrename" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform copy renaming on trees.  This pass attempts to rename compiler
temporaries to other variables at copy locations, usually resulting in
variable names which more closely resemble the original variables.  This flag
is enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-coalesce-inlined-vars">
<tt class="descname">-ftree-coalesce-inlined-vars</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-coalesce-inlined-vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell the copyrename pass (see <a class="reference internal" href="#cmdoption-ftree-copyrename"><em class="xref std std-option">-ftree-copyrename</em></a>) to attempt to
combine small user-defined variables too, but only if they are inlined
from other functions.  It is a more limited form of
<a class="reference internal" href="#cmdoption-ftree-coalesce-vars"><em class="xref std std-option">-ftree-coalesce-vars</em></a>.  This may harm debug information of such
inlined variables, but it keeps variables of the inlined-into
function apart from each other, such that they are more likely to
contain the expected values in a debugging session.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-coalesce-vars">
<tt class="descname">-ftree-coalesce-vars</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-coalesce-vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell the copyrename pass (see <a class="reference internal" href="#cmdoption-ftree-copyrename"><em class="xref std std-option">-ftree-copyrename</em></a>) to attempt to
combine small user-defined variables too, instead of just compiler
temporaries.  This may severely limit the ability to debug an optimized
program compiled with <em class="xref std std-option">-fno-var-tracking-assignments</em>.  In the
negated form, this flag prevents SSA coalescing of user variables,
including inlined ones.  This option is enabled by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-ter">
<tt class="descname">-ftree-ter</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-ter" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform temporary expression replacement during the SSA-&gt;normal phase.  Single
use/single def temporaries are replaced at their use location with their
defining expression.  This results in non-GIMPLE code, but gives the expanders
much more complex trees to work on resulting in better RTL generation.  This is
enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-slsr">
<tt class="descname">-ftree-slsr</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-slsr" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform straight-line strength reduction on trees.  This recognizes related
expressions involving multiplications and replaces them by less expensive
calculations when possible.  This is enabled by default at <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> and
higher.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-vectorize">
<tt class="descname">-ftree-vectorize</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-vectorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform vectorization on trees. This flag enables <a class="reference internal" href="#cmdoption-ftree-loop-vectorize"><em class="xref std std-option">-ftree-loop-vectorize</em></a>
and <a class="reference internal" href="#cmdoption-ftree-slp-vectorize"><em class="xref std std-option">-ftree-slp-vectorize</em></a> if not explicitly specified.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-loop-vectorize">
<tt class="descname">-ftree-loop-vectorize</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-loop-vectorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform loop vectorization on trees. This flag is enabled by default at
<a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a> and when <a class="reference internal" href="#cmdoption-ftree-vectorize"><em class="xref std std-option">-ftree-vectorize</em></a> is enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-slp-vectorize">
<tt class="descname">-ftree-slp-vectorize</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-slp-vectorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform basic block vectorization on trees. This flag is enabled by default at
<a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a> and when <a class="reference internal" href="#cmdoption-ftree-vectorize"><em class="xref std std-option">-ftree-vectorize</em></a> is enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fvect-cost-model">
<tt class="descname">-fvect-cost-model</tt><tt class="descclassname">=model</tt><a class="headerlink" href="#cmdoption-fvect-cost-model" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the cost model used for vectorization.  The <tt class="docutils literal"><span class="pre">model</span></tt> argument
should be one of unlimited, dynamic or cheap.
With the unlimited model the vectorized code-path is assumed
to be profitable while with the dynamic model a runtime check
guards the vectorized code-path to enable it only for iteration
counts that will likely execute faster than when executing the original
scalar loop.  The cheap model disables vectorization of
loops where doing so would be cost prohibitive for example due to
required runtime checks for data dependence or alignment but otherwise
is equal to the dynamic model.
The default cost model depends on other optimization flags and is
either dynamic or cheap.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsimd-cost-model">
<tt class="descname">-fsimd-cost-model</tt><tt class="descclassname">=model</tt><a class="headerlink" href="#cmdoption-fsimd-cost-model" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the cost model used for vectorization of loops marked with the OpenMP
or Cilk Plus simd directive.  The <tt class="docutils literal"><span class="pre">model</span></tt> argument should be one of
unlimited, dynamic, cheap.  All values of <tt class="docutils literal"><span class="pre">model</span></tt>
have the same meaning as described in <a class="reference internal" href="#cmdoption-fvect-cost-model"><em class="xref std std-option">-fvect-cost-model</em></a> and by
default a cost model defined with <a class="reference internal" href="#cmdoption-fvect-cost-model"><em class="xref std std-option">-fvect-cost-model</em></a> is used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftree-vrp">
<tt class="descname">-ftree-vrp</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftree-vrp" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Value Range Propagation on trees.  This is similar to the
constant propagation pass, but instead of values, ranges of values are
propagated.  This allows the optimizers to remove unnecessary range
checks like array bound checks and null pointer checks.  This is
enabled by default at <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> and higher.  Null pointer check
elimination is only done if <a class="reference internal" href="#cmdoption-fdelete-null-pointer-checks"><em class="xref std std-option">-fdelete-null-pointer-checks</em></a> is
enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsplit-ivs-in-unroller">
<tt class="descname">-fsplit-ivs-in-unroller</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsplit-ivs-in-unroller" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables expression of values of induction variables in later iterations
of the unrolled loop using the value in the first iteration.  This breaks
long dependency chains, thus improving efficiency of the scheduling passes.</p>
<p>A combination of <a class="reference internal" href="#cmdoption-fweb"><em class="xref std std-option">-fweb</em></a> and CSE is often sufficient to obtain the
same effect.  However, that is not reliable in cases where the loop body
is more complicated than a single basic block.  It also does not work at all
on some architectures due to restrictions in the CSE pass.</p>
<p>This optimization is enabled by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fvariable-expansion-in-unroller">
<tt class="descname">-fvariable-expansion-in-unroller</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fvariable-expansion-in-unroller" title="Permalink to this definition">¶</a></dt>
<dd><p>With this option, the compiler creates multiple copies of some
local variables when unrolling a loop, which can result in superior code.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fpartial-inlining">
<tt class="descname">-fpartial-inlining</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fpartial-inlining" title="Permalink to this definition">¶</a></dt>
<dd><p>Inline parts of functions.  This option has any effect only
when inlining itself is turned on by the <a class="reference internal" href="#cmdoption-finline-functions"><em class="xref std std-option">-finline-functions</em></a>
or <a class="reference internal" href="#cmdoption-finline-small-functions"><em class="xref std std-option">-finline-small-functions</em></a> options.</p>
<p>Enabled at level <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fpredictive-commoning">
<tt class="descname">-fpredictive-commoning</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fpredictive-commoning" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform predictive commoning optimization, i.e., reusing computations
(especially memory loads and stores) performed in previous
iterations of loops.</p>
<p>This option is enabled at level <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fprefetch-loop-arrays">
<tt class="descname">-fprefetch-loop-arrays</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fprefetch-loop-arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>If supported by the target machine, generate instructions to prefetch
memory to improve the performance of loops that access large arrays.</p>
<p>This option may generate better or worse code; results are highly
dependent on the structure of loops within the source code.</p>
<p>Disabled at level <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-peephole">
<tt class="descname">-fno-peephole</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">-fno-peephole2</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-peephole" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable any machine-specific peephole optimizations.  The difference
between <a class="reference internal" href="#cmdoption-fno-peephole"><em class="xref std std-option">-fno-peephole</em></a> and <em class="xref std std-option">-fno-peephole2</em> is in how they
are implemented in the compiler; some targets use one, some use the
other, a few use both.</p>
<p><em class="xref std std-option">-fpeephole</em> is enabled by default.
<em class="xref std std-option">-fpeephole2</em> enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-guess-branch-probability">
<tt class="descname">-fno-guess-branch-probability</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-guess-branch-probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not guess branch probabilities using heuristics.</p>
<p>GCC uses heuristics to guess branch probabilities if they are
not provided by profiling feedback (<a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-fprofile-arcs"><em class="xref std std-option">-fprofile-arcs</em></a>).  These
heuristics are based on the control flow graph.  If some branch probabilities
are specified by <tt class="docutils literal"><span class="pre">__builtin_expect</span></tt>, then the heuristics are
used to guess branch probabilities for the rest of the control flow graph,
taking the <tt class="docutils literal"><span class="pre">__builtin_expect</span></tt> info into account.  The interactions
between the heuristics and <tt class="docutils literal"><span class="pre">__builtin_expect</span></tt> can be complex, and in
some cases, it may be useful to disable the heuristics so that the effects
of <tt class="docutils literal"><span class="pre">__builtin_expect</span></tt> are easier to understand.</p>
<p>The default is <em class="xref std std-option">-fguess-branch-probability</em> at levels
<a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-freorder-blocks">
<tt class="descname">-freorder-blocks</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-freorder-blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder basic blocks in the compiled function in order to reduce number of
taken branches and improve code locality.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-freorder-blocks-and-partition">
<tt class="descname">-freorder-blocks-and-partition</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-freorder-blocks-and-partition" title="Permalink to this definition">¶</a></dt>
<dd><p>In addition to reordering basic blocks in the compiled function, in order
to reduce number of taken branches, partitions hot and cold basic blocks
into separate sections of the assembly and .o files, to improve
paging and cache locality performance.</p>
<p>This optimization is automatically turned off in the presence of
exception handling, for linkonce sections, for functions with a user-defined
section attribute and on any architecture that does not support named
sections.</p>
<p>Enabled for x86 at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-freorder-functions">
<tt class="descname">-freorder-functions</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-freorder-functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder functions in the object file in order to
improve code locality.  This is implemented by using special
subsections <tt class="docutils literal"><span class="pre">.text.hot</span></tt> for most frequently executed functions and
<tt class="docutils literal"><span class="pre">.text.unlikely</span></tt> for unlikely executed functions.  Reordering is done by
the linker so object file format must support named sections and linker must
place them in a reasonable way.</p>
<p>Also profile feedback must be available to make this option effective.  See
<a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-fprofile-arcs"><em class="xref std std-option">-fprofile-arcs</em></a> for details.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fstrict-aliasing">
<tt class="descname">-fstrict-aliasing</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fstrict-aliasing" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the compiler to assume the strictest aliasing rules applicable to
the language being compiled.  For C (and C++), this activates
optimizations based on the type of expressions.  In particular, an
object of one type is assumed never to reside at the same address as an
object of a different type, unless the types are almost the same.  For
example, an <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> can alias an <tt class="docutils literal"><span class="pre">int</span></tt>, but not a
<tt class="docutils literal"><span class="pre">void*</span></tt> or a <tt class="docutils literal"><span class="pre">double</span></tt>.  A character type may alias any other
type.</p>
<p>Pay special attention to code like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">union</span> <span class="n">a_union</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">union</span> <span class="n">a_union</span> <span class="n">t</span><span class="p">;</span>
  <span class="n">t</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The practice of reading from a different union member than the one most
recently written to (called &#8216;type-punning&#8217;) is common.  Even with
<a class="reference internal" href="#cmdoption-fstrict-aliasing"><em class="xref std std-option">-fstrict-aliasing</em></a>, type-punning is allowed, provided the memory
is accessed through the union type.  So, the code above works as
expected.  See <a class="reference internal" href="structures,-unions,-enumerations,-and-bit-fields.html#structures-unions-enumerations-and-bit-fields-implementation"><em>Structures, Unions, Enumerations, and Bit-Fields</em></a>.  However, this code might not:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">union</span> <span class="n">a_union</span> <span class="n">t</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">ip</span><span class="p">;</span>
  <span class="n">t</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
  <span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Similarly, access by taking the address, casting the resulting pointer
and dereferencing the result has undefined behavior, even if the cast
uses a union type, e.g.:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">((</span><span class="k">union</span> <span class="n">a_union</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#cmdoption-fstrict-aliasing"><em class="xref std std-option">-fstrict-aliasing</em></a> option is enabled at levels
<a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fstrict-overflow">
<tt class="descname">-fstrict-overflow</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fstrict-overflow" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the compiler to assume strict signed overflow rules, depending
on the language being compiled.  For C (and C++) this means that
overflow when doing arithmetic with signed numbers is undefined, which
means that the compiler may assume that it does not happen.  This
permits various optimizations.  For example, the compiler assumes
that an expression like <tt class="docutils literal"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">10</span> <span class="pre">&gt;</span> <span class="pre">i</span></tt> is always true for
signed <tt class="docutils literal"><span class="pre">i</span></tt>.  This assumption is only valid if signed overflow is
undefined, as the expression is false if <tt class="docutils literal"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">10</span></tt> overflows when
using twos complement arithmetic.  When this option is in effect any
attempt to determine whether an operation on signed numbers
overflows must be written carefully to not actually involve overflow.</p>
<p>This option also allows the compiler to assume strict pointer
semantics: given a pointer to an object, if adding an offset to that
pointer does not produce a pointer to the same object, the addition is
undefined.  This permits the compiler to conclude that <tt class="docutils literal"><span class="pre">p</span> <span class="pre">+</span> <span class="pre">u</span> <span class="pre">&gt;</span>
<span class="pre">p</span></tt> is always true for a pointer <tt class="docutils literal"><span class="pre">p</span></tt> and unsigned integer
<tt class="docutils literal"><span class="pre">u</span></tt>.  This assumption is only valid because pointer wraparound is
undefined, as the expression is false if <tt class="docutils literal"><span class="pre">p</span> <span class="pre">+</span> <span class="pre">u</span></tt> overflows using
twos complement arithmetic.</p>
<p>See also the <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fwrapv"><em class="xref std std-option">-fwrapv</em></a> option.  Using <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fwrapv"><em class="xref std std-option">-fwrapv</em></a> means
that integer signed overflow is fully defined: it wraps.  When
<a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fwrapv"><em class="xref std std-option">-fwrapv</em></a> is used, there is no difference between
<a class="reference internal" href="#cmdoption-fstrict-overflow"><em class="xref std std-option">-fstrict-overflow</em></a> and <em class="xref std std-option">-fno-strict-overflow</em> for
integers.  With <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fwrapv"><em class="xref std std-option">-fwrapv</em></a> certain types of overflow are
permitted.  For example, if the compiler gets an overflow when doing
arithmetic on constants, the overflowed value can still be used with
<a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fwrapv"><em class="xref std std-option">-fwrapv</em></a>, but not otherwise.</p>
<p>The <a class="reference internal" href="#cmdoption-fstrict-overflow"><em class="xref std std-option">-fstrict-overflow</em></a> option is enabled at levels
<a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-falign-functions">
<tt class="descname">-falign-functions</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-falign-functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Align the start of functions to the next power-of-two greater than
<tt class="docutils literal"><span class="pre">n</span></tt>, skipping up to <tt class="docutils literal"><span class="pre">n</span></tt> bytes.  For instance,
<em class="xref std std-option">-falign-functions=32</em> aligns functions to the next 32-byte
boundary, but <em class="xref std std-option">-falign-functions=24</em> aligns to the next
32-byte boundary only if this can be done by skipping 23 bytes or less.</p>
<p><em class="xref std std-option">-fno-align-functions</em> and <em class="xref std std-option">-falign-functions=1</em> are
equivalent and mean that functions are not aligned.</p>
<p>Some assemblers only support this flag when <tt class="docutils literal"><span class="pre">n</span></tt> is a power of two;
in that case, it is rounded up.</p>
<p>If <tt class="docutils literal"><span class="pre">n</span></tt> is not specified or is zero, use a machine-dependent default.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-falign-labels">
<tt class="descname">-falign-labels</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-falign-labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Align all branch targets to a power-of-two boundary, skipping up to
<tt class="docutils literal"><span class="pre">n</span></tt> bytes like <a class="reference internal" href="#cmdoption-falign-functions"><em class="xref std std-option">-falign-functions</em></a>.  This option can easily
make code slower, because it must insert dummy operations for when the
branch target is reached in the usual flow of the code.</p>
<p><em class="xref std std-option">-fno-align-labels</em> and <em class="xref std std-option">-falign-labels=1</em> are
equivalent and mean that labels are not aligned.</p>
<p>If <a class="reference internal" href="#cmdoption-falign-loops"><em class="xref std std-option">-falign-loops</em></a> or <a class="reference internal" href="#cmdoption-falign-jumps"><em class="xref std std-option">-falign-jumps</em></a> are applicable and
are greater than this value, then their values are used instead.</p>
<p>If <tt class="docutils literal"><span class="pre">n</span></tt> is not specified or is zero, use a machine-dependent default
which is very likely to be 1, meaning no alignment.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-falign-loops">
<tt class="descname">-falign-loops</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-falign-loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Align loops to a power-of-two boundary, skipping up to <tt class="docutils literal"><span class="pre">n</span></tt> bytes
like <a class="reference internal" href="#cmdoption-falign-functions"><em class="xref std std-option">-falign-functions</em></a>.  If the loops are
executed many times, this makes up for any execution of the dummy
operations.</p>
<p><em class="xref std std-option">-fno-align-loops</em> and <em class="xref std std-option">-falign-loops=1</em> are
equivalent and mean that loops are not aligned.</p>
<p>If <tt class="docutils literal"><span class="pre">n</span></tt> is not specified or is zero, use a machine-dependent default.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-falign-jumps">
<tt class="descname">-falign-jumps</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-falign-jumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Align branch targets to a power-of-two boundary, for branch targets
where the targets can only be reached by jumping, skipping up to <tt class="docutils literal"><span class="pre">n</span></tt>
bytes like <a class="reference internal" href="#cmdoption-falign-functions"><em class="xref std std-option">-falign-functions</em></a>.  In this case, no dummy operations
need be executed.</p>
<p><em class="xref std std-option">-fno-align-jumps</em> and <em class="xref std std-option">-falign-jumps=1</em> are
equivalent and mean that loops are not aligned.</p>
<p>If <tt class="docutils literal"><span class="pre">n</span></tt> is not specified or is zero, use a machine-dependent default.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-funit-at-a-time">
<tt class="descname">-funit-at-a-time</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-funit-at-a-time" title="Permalink to this definition">¶</a></dt>
<dd><p>This option is left for compatibility reasons. <a class="reference internal" href="#cmdoption-funit-at-a-time"><em class="xref std std-option">-funit-at-a-time</em></a>
has no effect, while <em class="xref std std-option">-fno-unit-at-a-time</em> implies
<a class="reference internal" href="#cmdoption-fno-toplevel-reorder"><em class="xref std std-option">-fno-toplevel-reorder</em></a> and <em class="xref std std-option">-fno-section-anchors</em>.</p>
<p>Enabled by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-toplevel-reorder">
<tt class="descname">-fno-toplevel-reorder</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-toplevel-reorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not reorder top-level functions, variables, and <tt class="docutils literal"><span class="pre">asm</span></tt>
statements.  Output them in the same order that they appear in the
input file.  When this option is used, unreferenced static variables
are not removed.  This option is intended to support existing code
that relies on a particular ordering.  For new code, it is better to
use attributes when possible.</p>
<p>Enabled at level <a class="reference internal" href="#cmdoption-O0"><em class="xref std std-option">-O0</em></a>.  When disabled explicitly, it also implies
<em class="xref std std-option">-fno-section-anchors</em>, which is otherwise enabled at <a class="reference internal" href="#cmdoption-O0"><em class="xref std std-option">-O0</em></a> on some
targets.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fweb">
<tt class="descname">-fweb</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fweb" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs webs as commonly used for register allocation purposes and assign
each web individual pseudo register.  This allows the register allocation pass
to operate on pseudos directly, but also strengthens several other optimization
passes, such as CSE, loop optimizer and trivial dead code remover.  It can,
however, make debugging impossible, since variables no longer stay in a
&#8216;home register&#8217;.</p>
<p>Enabled by default with <a class="reference internal" href="#cmdoption-funroll-loops"><em class="xref std std-option">-funroll-loops</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fwhole-program">
<tt class="descname">-fwhole-program</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fwhole-program" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume that the current compilation unit represents the whole program being
compiled.  All public functions and variables with the exception of <tt class="docutils literal"><span class="pre">main</span></tt>
and those merged by attribute <tt class="docutils literal"><span class="pre">externally_visible</span></tt> become static functions
and in effect are optimized more aggressively by interprocedural optimizers.</p>
<p>This option should not be used in combination with <a class="reference internal" href="#cmdoption-flto"><em class="xref std std-option">-flto</em></a>.
Instead relying on a linker plugin should provide safer and more precise
information.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-flto">
<tt class="descname">-flto</tt><tt class="descclassname">[=n]</tt><a class="headerlink" href="#cmdoption-flto" title="Permalink to this definition">¶</a></dt>
<dd><p>This option runs the standard link-time optimizer.  When invoked
with source code, it generates GIMPLE (one of GCC&#8217;s internal
representations) and writes it to special ELF sections in the object
file.  When the object files are linked together, all the function
bodies are read from these ELF sections and instantiated as if they
had been part of the same translation unit.</p>
<p>To use the link-time optimizer, <a class="reference internal" href="#cmdoption-flto"><em class="xref std std-option">-flto</em></a> and optimization
options should be specified at compile time and during the final link.
For example:</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -c -O2 -flto foo.c
gcc -c -O2 -flto bar.c
gcc -o myprog -flto -O2 foo.o bar.o
</pre></div>
</div>
<p>The first two invocations to GCC save a bytecode representation
of GIMPLE into special ELF sections inside foo.o and
bar.o.  The final invocation reads the GIMPLE bytecode from
foo.o and bar.o, merges the two files into a single
internal image, and compiles the result as usual.  Since both
foo.o and bar.o are merged into a single image, this
causes all the interprocedural analyses and optimizations in GCC to
work across the two files as if they were a single one.  This means,
for example, that the inliner is able to inline functions in
bar.o into functions in foo.o and vice-versa.</p>
<p>Another (simpler) way to enable link-time optimization is:</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o myprog -flto -O2 foo.c bar.c
</pre></div>
</div>
<p>The above generates bytecode for foo.c and bar.c,
merges them together into a single GIMPLE representation and optimizes
them as usual to produce myprog.</p>
<p>The only important thing to keep in mind is that to enable link-time
optimizations you need to use the GCC driver to perform the link-step.
GCC then automatically performs link-time optimization if any of the
objects involved were compiled with the <a class="reference internal" href="#cmdoption-flto"><em class="xref std std-option">-flto</em></a> command-line option.
You generally
should specify the optimization options to be used for link-time
optimization though GCC tries to be clever at guessing an
optimization level to use from the options used at compile-time
if you fail to specify one at link-time.  You can always override
the automatic decision to do link-time optimization at link-time
by passing <em class="xref std std-option">-fno-lto</em> to the link command.</p>
<p>To make whole program optimization effective, it is necessary to make
certain whole program assumptions.  The compiler needs to know
what functions and variables can be accessed by libraries and runtime
outside of the link-time optimized unit.  When supported by the linker,
the linker plugin (see <a class="reference internal" href="#cmdoption-fuse-linker-plugin"><em class="xref std std-option">-fuse-linker-plugin</em></a>) passes information
to the compiler about used and externally visible symbols.  When
the linker plugin is not available, <a class="reference internal" href="#cmdoption-fwhole-program"><em class="xref std std-option">-fwhole-program</em></a> should be
used to allow the compiler to make these assumptions, which leads
to more aggressive optimization decisions.</p>
<p>When <a class="reference internal" href="#cmdoption-fuse-linker-plugin"><em class="xref std std-option">-fuse-linker-plugin</em></a> is not enabled then, when a file is
compiled with <a class="reference internal" href="#cmdoption-flto"><em class="xref std std-option">-flto</em></a>, the generated object file is larger than
a regular object file because it contains GIMPLE bytecodes and the usual
final code (see <a class="reference internal" href="#cmdoption-ffat-lto-objects"><em class="xref std std-option">-ffat-lto-objects</em></a>.  This means that
object files with LTO information can be linked as normal object
files; if <em class="xref std std-option">-fno-lto</em> is passed to the linker, no
interprocedural optimizations are applied.  Note that when
<em class="xref std std-option">-fno-fat-lto-objects</em> is enabled the compile-stage is faster
but you cannot perform a regular, non-LTO link on them.</p>
<p>Additionally, the optimization flags used to compile individual files
are not necessarily related to those used at link time.  For instance,</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -c -O0 -ffat-lto-objects -flto foo.c
gcc -c -O0 -ffat-lto-objects -flto bar.c
gcc -o myprog -O3 foo.o bar.o
</pre></div>
</div>
<p>This produces individual object files with unoptimized assembler
code, but the resulting binary myprog is optimized at
<a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.  If, instead, the final binary is generated with
<em class="xref std std-option">-fno-lto</em>, then myprog is not optimized.</p>
<p>When producing the final binary, GCC only
applies link-time optimizations to those files that contain bytecode.
Therefore, you can mix and match object files and libraries with
GIMPLE bytecodes and final object code.  GCC automatically selects
which files to optimize in LTO mode and which files to link without
further processing.</p>
<p>There are some code generation flags preserved by GCC when
generating bytecodes, as they need to be used during the final link
stage.  Generally options specified at link-time override those
specified at compile-time.</p>
<p>If you do not specify an optimization level option <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> at
link-time then GCC computes one based on the optimization levels
used when compiling the object files.  The highest optimization
level wins here.</p>
<p>Currently, the following options and their setting are take from
the first object file that explicitely specified it:
<a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fPIC"><em class="xref std std-option">-fPIC</em></a>, <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fpic"><em class="xref std std-option">-fpic</em></a>, <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fpie"><em class="xref std std-option">-fpie</em></a>, <a class="reference internal" href="specifying-attributes-of-variables.html#cmdoption-fcommon"><em class="xref std std-option">-fcommon</em></a>,
<a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fexceptions"><em class="xref std std-option">-fexceptions</em></a>, <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fnon-call-exceptions"><em class="xref std std-option">-fnon-call-exceptions</em></a>, <a class="reference internal" href="options-controlling-c-dialect.html#cmdoption-fgnu-tm"><em class="xref std std-option">-fgnu-tm</em></a>
and all the <em class="xref std std-option">-m</em> target flags.</p>
<p>Certain ABI changing flags are required to match in all compilation-units
and trying to override this at link-time with a conflicting value
is ignored.  This includes options such as <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-freg-struct-return"><em class="xref std std-option">-freg-struct-return</em></a>
and <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fpcc-struct-return"><em class="xref std std-option">-fpcc-struct-return</em></a>.</p>
<p>Other options such as <a class="reference internal" href="#cmdoption-ffp-contract"><em class="xref std std-option">-ffp-contract</em></a>, <em class="xref std std-option">-fno-strict-overflow</em>,
<a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fwrapv"><em class="xref std std-option">-fwrapv</em></a>, <em class="xref std std-option">-fno-trapv</em> or <em class="xref std std-option">-fno-strict-aliasing</em>
are passed through to the link stage and merged conservatively for
conflicting translation units.  Specifically
<em class="xref std std-option">-fno-strict-overflow</em>, <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fwrapv"><em class="xref std std-option">-fwrapv</em></a> and <em class="xref std std-option">-fno-trapv</em> take
precedence and for example <em class="xref std std-option">-ffp-contract=off</em> takes precedence
over <em class="xref std std-option">-ffp-contract=fast</em>.  You can override them at linke-time.</p>
<p>It is recommended that you compile all the files participating in the
same link with the same options and also specify those options at
link time.</p>
<p>If LTO encounters objects with C linkage declared with incompatible
types in separate translation units to be linked together (undefined
behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be
issued.  The behavior is still undefined at run time.  Similar
diagnostics may be raised for other languages.</p>
<p>Another feature of LTO is that it is possible to apply interprocedural
optimizations on files written in different languages:</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -c -flto foo.c
g++ -c -flto bar.cc
gfortran -c -flto baz.f90
g++ -o myprog -flto -O3 foo.o bar.o baz.o -lgfortran
</pre></div>
</div>
<p>Notice that the final link is done with <strong class="command">g++</strong> to get the C++
runtime libraries and <em class="xref std std-option">-lgfortran</em> is added to get the Fortran
runtime libraries.  In general, when mixing languages in LTO mode, you
should use the same link command options as when mixing languages in a
regular (non-LTO) compilation.</p>
<p>If object files containing GIMPLE bytecode are stored in a library archive, say
libfoo.a, it is possible to extract and use them in an LTO link if you
are using a linker with plugin support.  To create static libraries suitable
for LTO, use <strong class="command">gcc-ar</strong> and <strong class="command">gcc-ranlib</strong> instead of <strong class="command">ar</strong>
and <strong class="command">ranlib</strong>;
to show the symbols of object files with GIMPLE bytecode, use
<strong class="command">gcc-nm</strong>.  Those commands require that <strong class="command">ar</strong>, <strong class="command">ranlib</strong>
and <strong class="command">nm</strong> have been compiled with plugin support.  At link time, use the the
flag <a class="reference internal" href="#cmdoption-fuse-linker-plugin"><em class="xref std std-option">-fuse-linker-plugin</em></a> to ensure that the library participates in
the LTO optimization process:</p>
<div class="highlight-bash"><div class="highlight"><pre>gcc -o myprog -O2 -flto -fuse-linker-plugin a.o b.o -lfoo
</pre></div>
</div>
<p>With the linker plugin enabled, the linker extracts the needed
GIMPLE files from libfoo.a and passes them on to the running GCC
to make them part of the aggregated GIMPLE image to be optimized.</p>
<p>If you are not using a linker with plugin support and/or do not
enable the linker plugin, then the objects inside libfoo.a
are extracted and linked as usual, but they do not participate
in the LTO optimization process.  In order to make a static library suitable
for both LTO optimization and usual linkage, compile its object files with
<a class="reference internal" href="#cmdoption-flto"><em class="xref std std-option">-flto</em></a> <a class="reference internal" href="#cmdoption-ffat-lto-objects"><em class="xref std std-option">-ffat-lto-objects</em></a>.</p>
<p>Link-time optimizations do not require the presence of the whole program to
operate.  If the program does not require any symbols to be exported, it is
possible to combine <a class="reference internal" href="#cmdoption-flto"><em class="xref std std-option">-flto</em></a> and <a class="reference internal" href="#cmdoption-fwhole-program"><em class="xref std std-option">-fwhole-program</em></a> to allow
the interprocedural optimizers to use more aggressive assumptions which may
lead to improved optimization opportunities.
Use of <a class="reference internal" href="#cmdoption-fwhole-program"><em class="xref std std-option">-fwhole-program</em></a> is not needed when linker plugin is
active (see <a class="reference internal" href="#cmdoption-fuse-linker-plugin"><em class="xref std std-option">-fuse-linker-plugin</em></a>).</p>
<p>The current implementation of LTO makes no
attempt to generate bytecode that is portable between different
types of hosts.  The bytecode files are versioned and there is a
strict version check, so bytecode files generated in one version of
GCC do not work with an older or newer version of GCC.</p>
<p>Link-time optimization does not work well with generation of debugging
information.  Combining <a class="reference internal" href="#cmdoption-flto"><em class="xref std std-option">-flto</em></a> with
<a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-g"><em class="xref std std-option">-g</em></a> is currently experimental and expected to produce unexpected
results.</p>
<p>If you specify the optional <tt class="docutils literal"><span class="pre">n</span></tt>, the optimization and code
generation done at link time is executed in parallel using <tt class="docutils literal"><span class="pre">n</span></tt>
parallel jobs by utilizing an installed <strong class="command">make</strong> program.  The
environment variable <span class="target" id="index-2"></span><tt class="xref std std-envvar docutils literal"><span class="pre">MAKE</span></tt> may be used to override the program
used.  The default value for <tt class="docutils literal"><span class="pre">n</span></tt> is 1.</p>
<p>You can also specify <em class="xref std std-option">-flto=jobserver</em> to use GNU make&#8217;s
job server mode to determine the number of parallel jobs. This
is useful when the Makefile calling GCC is already executing in parallel.
You must prepend a + to the command recipe in the parent Makefile
for this to work.  This option likely only works if <span class="target" id="index-3"></span><tt class="xref std std-envvar docutils literal"><span class="pre">MAKE</span></tt> is
GNU make.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-flto-partition">
<tt class="descname">-flto-partition</tt><tt class="descclassname">=alg</tt><a class="headerlink" href="#cmdoption-flto-partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify the partitioning algorithm used by the link-time optimizer.
The value is either 1to1 to specify a partitioning mirroring
the original source files or balanced to specify partitioning
into equally sized chunks (whenever possible) or max to create
new partition for every symbol where possible.  Specifying none
as an algorithm disables partitioning and streaming completely.
The default value is balanced. While 1to1 can be used
as an workaround for various code ordering issues, the max
partitioning is intended for internal testing only.
The value one specifies that exactly one partition should be
used while the value none bypasses partitioning and executes
the link-time optimization step directly from the WPA phase.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-flto-odr-type-merging">
<tt class="descname">-flto-odr-type-merging</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-flto-odr-type-merging" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable streaming of mangled types names of C++ types and their unification
at linktime.  This increases size of LTO object files, but enable
diagnostics about One Definition Rule violations.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-flto-compression-level">
<tt class="descname">-flto-compression-level</tt><tt class="descclassname">=n</tt><a class="headerlink" href="#cmdoption-flto-compression-level" title="Permalink to this definition">¶</a></dt>
<dd><p>This option specifies the level of compression used for intermediate
language written to LTO object files, and is only meaningful in
conjunction with LTO mode (<a class="reference internal" href="#cmdoption-flto"><em class="xref std std-option">-flto</em></a>).  Valid
values are 0 (no compression) to 9 (maximum compression).  Values
outside this range are clamped to either 0 or 9.  If the option is not
given, a default balanced compression setting is used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-flto-report">
<tt class="descname">-flto-report</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-flto-report" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a report with internal details on the workings of the link-time
optimizer.  The contents of this report vary from version to version.
It is meant to be useful to GCC developers when processing object
files in LTO mode (via <a class="reference internal" href="#cmdoption-flto"><em class="xref std std-option">-flto</em></a>).</p>
<p>Disabled by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-flto-report-wpa">
<tt class="descname">-flto-report-wpa</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-flto-report-wpa" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#cmdoption-flto-report"><em class="xref std std-option">-flto-report</em></a>, but only print for the WPA phase of Link
Time Optimization.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fuse-linker-plugin">
<tt class="descname">-fuse-linker-plugin</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fuse-linker-plugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables the use of a linker plugin during link-time optimization.  This
option relies on plugin support in the linker, which is available in gold
or in GNU ld 2.21 or newer.</p>
<p>This option enables the extraction of object files with GIMPLE bytecode out
of library archives. This improves the quality of optimization by exposing
more code to the link-time optimizer.  This information specifies what
symbols can be accessed externally (by non-LTO object or during dynamic
linking).  Resulting code quality improvements on binaries (and shared
libraries that use hidden visibility) are similar to <a class="reference internal" href="#cmdoption-fwhole-program"><em class="xref std std-option">-fwhole-program</em></a>.
See <a class="reference internal" href="#cmdoption-flto"><em class="xref std std-option">-flto</em></a> for a description of the effect of this flag and how to
use it.</p>
<p>This option is enabled by default when LTO support in GCC is enabled
and GCC was configured for use with
a linker supporting plugins (GNU ld 2.21 or newer or gold).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ffat-lto-objects">
<tt class="descname">-ffat-lto-objects</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ffat-lto-objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Fat LTO objects are object files that contain both the intermediate language
and the object code. This makes them usable for both LTO linking and normal
linking. This option is effective only when compiling with <a class="reference internal" href="#cmdoption-flto"><em class="xref std std-option">-flto</em></a>
and is ignored at link time.</p>
<p><em class="xref std std-option">-fno-fat-lto-objects</em> improves compilation time over plain LTO, but
requires the complete toolchain to be aware of LTO. It requires a linker with
linker plugin support for basic functionality.  Additionally,
<strong class="command">nm</strong>, <strong class="command">ar</strong> and <strong class="command">ranlib</strong>
need to support linker plugins to allow a full-featured build environment
(capable of building static libraries etc).  GCC provides the <strong class="command">gcc-ar</strong>,
<strong class="command">gcc-nm</strong>, <strong class="command">gcc-ranlib</strong> wrappers to pass the right options
to these tools. With non fat LTO makefiles need to be modified to use them.</p>
<p>The default is <em class="xref std std-option">-fno-fat-lto-objects</em> on targets with linker plugin
support.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fcompare-elim">
<tt class="descname">-fcompare-elim</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fcompare-elim" title="Permalink to this definition">¶</a></dt>
<dd><p>After register allocation and post-register allocation instruction splitting,
identify arithmetic instructions that compute processor flags similar to a
comparison operation based on that arithmetic.  If possible, eliminate the
explicit comparison operation.</p>
<p>This pass only applies to certain targets that cannot explicitly represent
the comparison operation before register allocation is complete.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fcprop-registers">
<tt class="descname">-fcprop-registers</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fcprop-registers" title="Permalink to this definition">¶</a></dt>
<dd><p>After register allocation and post-register allocation instruction splitting,
perform a copy-propagation pass to try to reduce scheduling dependencies
and occasionally eliminate the copy.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fprofile-correction">
<tt class="descname">-fprofile-correction</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fprofile-correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Profiles collected using an instrumented binary for multi-threaded programs may
be inconsistent due to missed counter updates. When this option is specified,
GCC uses heuristics to correct or smooth out such inconsistencies. By
default, GCC emits an error message when an inconsistent profile is detected.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fprofile-dir">
<tt class="descname">-fprofile-dir</tt><tt class="descclassname">=path</tt><a class="headerlink" href="#cmdoption-fprofile-dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the directory to search for the profile data files in to <tt class="docutils literal"><span class="pre">path</span></tt>.
This option affects only the profile data generated by
<a class="reference internal" href="#cmdoption-fprofile-generate"><em class="xref std std-option">-fprofile-generate</em></a>, <a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-ftest-coverage"><em class="xref std std-option">-ftest-coverage</em></a>, <a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-fprofile-arcs"><em class="xref std std-option">-fprofile-arcs</em></a>
and used by <a class="reference internal" href="#cmdoption-fprofile-use"><em class="xref std std-option">-fprofile-use</em></a> and <a class="reference internal" href="#cmdoption-fbranch-probabilities"><em class="xref std std-option">-fbranch-probabilities</em></a>
and its related options.  Both absolute and relative paths can be used.
By default, GCC uses the current directory as <tt class="docutils literal"><span class="pre">path</span></tt>, thus the
profile data file appears in the same directory as the object file.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fprofile-generate">
<tt class="descname">-fprofile-generate</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fprofile-generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable options usually used for instrumenting application to produce
profile useful for later recompilation with profile feedback based
optimization.  You must use <a class="reference internal" href="#cmdoption-fprofile-generate"><em class="xref std std-option">-fprofile-generate</em></a> both when
compiling and when linking your program.</p>
<p>The following options are enabled: <a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-fprofile-arcs"><em class="xref std std-option">-fprofile-arcs</em></a>, <a class="reference internal" href="#cmdoption-fprofile-values"><em class="xref std std-option">-fprofile-values</em></a>, <a class="reference internal" href="#cmdoption-fvpt"><em class="xref std std-option">-fvpt</em></a>.</p>
<p>If <tt class="docutils literal"><span class="pre">path</span></tt> is specified, GCC looks at the <tt class="docutils literal"><span class="pre">path</span></tt> to find
the profile feedback data files. See <a class="reference internal" href="#cmdoption-fprofile-dir"><em class="xref std std-option">-fprofile-dir</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fprofile-use">
<tt class="descname">-fprofile-use</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fprofile-use" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable profile feedback-directed optimizations,
and the following optimizations
which are generally profitable only with profile feedback available:
<a class="reference internal" href="#cmdoption-fbranch-probabilities"><em class="xref std std-option">-fbranch-probabilities</em></a>, <a class="reference internal" href="#cmdoption-fvpt"><em class="xref std std-option">-fvpt</em></a>,
<a class="reference internal" href="#cmdoption-funroll-loops"><em class="xref std std-option">-funroll-loops</em></a>, <a class="reference internal" href="#cmdoption-fpeel-loops"><em class="xref std std-option">-fpeel-loops</em></a>, <a class="reference internal" href="#cmdoption-ftracer"><em class="xref std std-option">-ftracer</em></a>,
<a class="reference internal" href="#cmdoption-ftree-vectorize"><em class="xref std std-option">-ftree-vectorize</em></a>, and ftree-loop-distribute-patterns.</p>
<p>By default, GCC emits an error message if the feedback profiles do not
match the source code.  This error can be turned into a warning by using
<em class="xref std std-option">-Wcoverage-mismatch</em>.  Note this may result in poorly optimized
code.</p>
<p>If <tt class="docutils literal"><span class="pre">path</span></tt> is specified, GCC looks at the <tt class="docutils literal"><span class="pre">path</span></tt> to find
the profile feedback data files. See <a class="reference internal" href="#cmdoption-fprofile-dir"><em class="xref std std-option">-fprofile-dir</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fauto-profile">
<tt class="descname">-fauto-profile</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fauto-profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable sampling-based feedback-directed optimizations,
and the following optimizations
which are generally profitable only with profile feedback available:
<a class="reference internal" href="#cmdoption-fbranch-probabilities"><em class="xref std std-option">-fbranch-probabilities</em></a>, <a class="reference internal" href="#cmdoption-fvpt"><em class="xref std std-option">-fvpt</em></a>,
<a class="reference internal" href="#cmdoption-funroll-loops"><em class="xref std std-option">-funroll-loops</em></a>, <a class="reference internal" href="#cmdoption-fpeel-loops"><em class="xref std std-option">-fpeel-loops</em></a>, <a class="reference internal" href="#cmdoption-ftracer"><em class="xref std std-option">-ftracer</em></a>,
<a class="reference internal" href="#cmdoption-ftree-vectorize"><em class="xref std std-option">-ftree-vectorize</em></a>,
<a class="reference internal" href="#cmdoption-finline-functions"><em class="xref std std-option">-finline-functions</em></a>, <a class="reference internal" href="#cmdoption-fipa-cp"><em class="xref std std-option">-fipa-cp</em></a>, <a class="reference internal" href="#cmdoption-fipa-cp-clone"><em class="xref std std-option">-fipa-cp-clone</em></a>,
<a class="reference internal" href="#cmdoption-fpredictive-commoning"><em class="xref std std-option">-fpredictive-commoning</em></a>, <a class="reference internal" href="#cmdoption-funswitch-loops"><em class="xref std std-option">-funswitch-loops</em></a>,
<a class="reference internal" href="#cmdoption-fgcse-after-reload"><em class="xref std std-option">-fgcse-after-reload</em></a>, and <a class="reference internal" href="#cmdoption-ftree-loop-distribute-patterns"><em class="xref std std-option">-ftree-loop-distribute-patterns</em></a>.</p>
<p><tt class="docutils literal"><span class="pre">path</span></tt> is the name of a file containing AutoFDO profile information.
If omitted, it defaults to fbdata.afdo in the current directory.</p>
<p>Producing an AutoFDO profile data file requires running your program
with the <strong class="command">perf</strong> utility on a supported GNU/Linux target system.
For more information, see <a class="reference external" href="https://perf.wiki.kernel.org/">https://perf.wiki.kernel.org/</a>.</p>
<p>E.g.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">perf</span> <span class="n">record</span> <span class="o">-</span><span class="n">e</span> <span class="n">br_inst_retired</span><span class="o">:</span><span class="n">near_taken</span> <span class="o">-</span><span class="n">b</span> <span class="o">-</span><span class="n">o</span> <span class="n">perf</span><span class="p">.</span><span class="n">data</span> \
    <span class="o">--</span> <span class="n">your_program</span>
</pre></div>
</div>
<p>Then use the <strong class="command">create_gcov</strong> tool to convert the raw profile data
to a format that can be used by GCC. You must also supply the
unstripped binary for your program to this tool.
See <a class="reference external" href="https://github.com/google/autofdo">https://github.com/google/autofdo</a>.</p>
<p>E.g.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">create_gcov</span> <span class="o">--</span><span class="n">binary</span><span class="o">=</span><span class="n">your_program</span><span class="p">.</span><span class="n">unstripped</span> <span class="o">--</span><span class="n">profile</span><span class="o">=</span><span class="n">perf</span><span class="p">.</span><span class="n">data</span> \
    <span class="o">--</span><span class="n">gcov</span><span class="o">=</span><span class="n">profile</span><span class="p">.</span><span class="n">afdo</span>
</pre></div>
</div>
</dd></dl>

<p>The following options control compiler behavior regarding floating-point
arithmetic.  These options trade off between speed and
correctness.  All must be specifically enabled.</p>
<dl class="option">
<dt id="cmdoption-ffloat-store">
<tt class="descname">-ffloat-store</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ffloat-store" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not store floating-point variables in registers, and inhibit other
options that might change whether a floating-point value is taken from a
register or memory.</p>
<p id="index-4">This option prevents undesirable excess precision on machines such as
the 68000 where the floating registers (of the 68881) keep more
precision than a <tt class="docutils literal"><span class="pre">double</span></tt> is supposed to have.  Similarly for the
x86 architecture.  For most programs, the excess precision does only
good, but a few programs rely on the precise definition of IEEE floating
point.  Use <a class="reference internal" href="#cmdoption-ffloat-store"><em class="xref std std-option">-ffloat-store</em></a> for such programs, after modifying
them to store all pertinent intermediate computations into variables.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fexcess-precision">
<tt class="descname">-fexcess-precision</tt><tt class="descclassname">=style</tt><a class="headerlink" href="#cmdoption-fexcess-precision" title="Permalink to this definition">¶</a></dt>
<dd><p>This option allows further control over excess precision on machines
where floating-point registers have more precision than the IEEE
<tt class="docutils literal"><span class="pre">float</span></tt> and <tt class="docutils literal"><span class="pre">double</span></tt> types and the processor does not
support operations rounding to those types.  By default,
<em class="xref std std-option">-fexcess-precision=fast</em> is in effect; this means that
operations are carried out in the precision of the registers and that
it is unpredictable when rounding to the types specified in the source
code takes place.  When compiling C, if
<em class="xref std std-option">-fexcess-precision=standard</em> is specified then excess
precision follows the rules specified in ISO C99; in particular,
both casts and assignments cause values to be rounded to their
semantic types (whereas <a class="reference internal" href="#cmdoption-ffloat-store"><em class="xref std std-option">-ffloat-store</em></a> only affects
assignments).  This option is enabled by default for C if a strict
conformance option such as <em class="xref std std-option">-std=c99</em> is used.</p>
<p><em class="xref std std-option">-fexcess-precision=standard</em> is not implemented for languages
other than C, and has no effect if
<a class="reference internal" href="#cmdoption-funsafe-math-optimizations"><em class="xref std std-option">-funsafe-math-optimizations</em></a> or <a class="reference internal" href="#cmdoption-ffast-math"><em class="xref std std-option">-ffast-math</em></a> is
specified.  On the x86, it also has no effect if <em class="xref std std-option">-mfpmath=sse</em>
or <em class="xref std std-option">-mfpmath=sse+387</em> is specified; in the former case, IEEE
semantics apply without excess precision, and in the latter, rounding
is unpredictable.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ffast-math">
<tt class="descname">-ffast-math</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ffast-math" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the options <a class="reference internal" href="#cmdoption-fno-math-errno"><em class="xref std std-option">-fno-math-errno</em></a>, <a class="reference internal" href="#cmdoption-funsafe-math-optimizations"><em class="xref std std-option">-funsafe-math-optimizations</em></a>,
<a class="reference internal" href="#cmdoption-ffinite-math-only"><em class="xref std std-option">-ffinite-math-only</em></a>, <em class="xref std std-option">-fno-rounding-math</em>,
<em class="xref std std-option">-fno-signaling-nans</em> and <a class="reference internal" href="#cmdoption-fcx-limited-range"><em class="xref std std-option">-fcx-limited-range</em></a>.</p>
<p>This option causes the preprocessor macro <tt class="docutils literal"><span class="pre">__FAST_MATH__</span></tt> to be defined.</p>
<p>This option is not turned on by any <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> option besides
<a class="reference internal" href="#cmdoption-Ofast"><em class="xref std std-option">-Ofast</em></a> since it can result in incorrect output for programs
that depend on an exact implementation of IEEE or ISO rules/specifications
for math functions. It may, however, yield faster code for programs
that do not require the guarantees of these specifications.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-math-errno">
<tt class="descname">-fno-math-errno</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-math-errno" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not set <tt class="docutils literal"><span class="pre">errno</span></tt> after calling math functions that are executed
with a single instruction, e.g., <tt class="docutils literal"><span class="pre">sqrt</span></tt>.  A program that relies on
IEEE exceptions for math error handling may want to use this flag
for speed while maintaining IEEE arithmetic compatibility.</p>
<p>This option is not turned on by any <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> option since
it can result in incorrect output for programs that depend on
an exact implementation of IEEE or ISO rules/specifications for
math functions. It may, however, yield faster code for programs
that do not require the guarantees of these specifications.</p>
<p>The default is <em class="xref std std-option">-fmath-errno</em>.</p>
<p>On Darwin systems, the math library never sets <tt class="docutils literal"><span class="pre">errno</span></tt>.  There is
therefore no reason for the compiler to consider the possibility that
it might, and <a class="reference internal" href="#cmdoption-fno-math-errno"><em class="xref std std-option">-fno-math-errno</em></a> is the default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-funsafe-math-optimizations">
<tt class="descname">-funsafe-math-optimizations</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-funsafe-math-optimizations" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow optimizations for floating-point arithmetic that (a) assume
that arguments and results are valid and (b) may violate IEEE or
ANSI standards.  When used at link-time, it may include libraries
or startup files that change the default FPU control word or other
similar optimizations.</p>
<p>This option is not turned on by any <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> option since
it can result in incorrect output for programs that depend on
an exact implementation of IEEE or ISO rules/specifications for
math functions. It may, however, yield faster code for programs
that do not require the guarantees of these specifications.
Enables <a class="reference internal" href="#cmdoption-fno-signed-zeros"><em class="xref std std-option">-fno-signed-zeros</em></a>, <a class="reference internal" href="#cmdoption-fno-trapping-math"><em class="xref std std-option">-fno-trapping-math</em></a>,
<a class="reference internal" href="#cmdoption-fassociative-math"><em class="xref std std-option">-fassociative-math</em></a> and <a class="reference internal" href="#cmdoption-freciprocal-math"><em class="xref std std-option">-freciprocal-math</em></a>.</p>
<p>The default is <em class="xref std std-option">-fno-unsafe-math-optimizations</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fassociative-math">
<tt class="descname">-fassociative-math</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fassociative-math" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow re-association of operands in series of floating-point operations.
This violates the ISO C and C++ language standard by possibly changing
computation result.  NOTE: re-ordering may change the sign of zero as
well as ignore NaNs and inhibit or create underflow or overflow (and
thus cannot be used on code that relies on rounding behavior like
<tt class="docutils literal"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">2**52)</span> <span class="pre">-</span> <span class="pre">2**52</span></tt>.  May also reorder floating-point comparisons
and thus may not be used when ordered comparisons are required.
This option requires that both <a class="reference internal" href="#cmdoption-fno-signed-zeros"><em class="xref std std-option">-fno-signed-zeros</em></a> and
<a class="reference internal" href="#cmdoption-fno-trapping-math"><em class="xref std std-option">-fno-trapping-math</em></a> be in effect.  Moreover, it doesn&#8217;t make
much sense with <a class="reference internal" href="#cmdoption-frounding-math"><em class="xref std std-option">-frounding-math</em></a>. For Fortran the option
is automatically enabled when both <a class="reference internal" href="#cmdoption-fno-signed-zeros"><em class="xref std std-option">-fno-signed-zeros</em></a> and
<a class="reference internal" href="#cmdoption-fno-trapping-math"><em class="xref std std-option">-fno-trapping-math</em></a> are in effect.</p>
<p>The default is <em class="xref std std-option">-fno-associative-math</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-freciprocal-math">
<tt class="descname">-freciprocal-math</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-freciprocal-math" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the reciprocal of a value to be used instead of dividing by
the value if this enables optimizations.  For example <tt class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></tt>
can be replaced with <tt class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">(1/y)</span></tt>, which is useful if <tt class="docutils literal"><span class="pre">(1/y)</span></tt>
is subject to common subexpression elimination.  Note that this loses
precision and increases the number of flops operating on the value.</p>
<p>The default is <em class="xref std std-option">-fno-reciprocal-math</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ffinite-math-only">
<tt class="descname">-ffinite-math-only</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ffinite-math-only" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow optimizations for floating-point arithmetic that assume
that arguments and results are not NaNs or +-Infs.</p>
<p>This option is not turned on by any <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> option since
it can result in incorrect output for programs that depend on
an exact implementation of IEEE or ISO rules/specifications for
math functions. It may, however, yield faster code for programs
that do not require the guarantees of these specifications.</p>
<p>The default is <em class="xref std std-option">-fno-finite-math-only</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-signed-zeros">
<tt class="descname">-fno-signed-zeros</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-signed-zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow optimizations for floating-point arithmetic that ignore the
signedness of zero.  IEEE arithmetic specifies the behavior of
distinct +0.0 and -0.0 values, which then prohibits simplification
of expressions such as x+0.0 or 0.0*x (even with <a class="reference internal" href="#cmdoption-ffinite-math-only"><em class="xref std std-option">-ffinite-math-only</em></a>).
This option implies that the sign of a zero result isn&#8217;t significant.</p>
<p>The default is <em class="xref std std-option">-fsigned-zeros</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fno-trapping-math">
<tt class="descname">-fno-trapping-math</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fno-trapping-math" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile code assuming that floating-point operations cannot generate
user-visible traps.  These traps include division by zero, overflow,
underflow, inexact result and invalid operation.  This option requires
that <em class="xref std std-option">-fno-signaling-nans</em> be in effect.  Setting this option may
allow faster code if one relies on &#8216;non-stop&#8217; IEEE arithmetic, for example.</p>
<p>This option should never be turned on by any <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> option since
it can result in incorrect output for programs that depend on
an exact implementation of IEEE or ISO rules/specifications for
math functions.</p>
<p>The default is <em class="xref std std-option">-ftrapping-math</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-frounding-math">
<tt class="descname">-frounding-math</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-frounding-math" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable transformations and optimizations that assume default floating-point
rounding behavior.  This is round-to-zero for all floating point
to integer conversions, and round-to-nearest for all other arithmetic
truncations.  This option should be specified for programs that change
the FP rounding mode dynamically, or that may be executed with a
non-default rounding mode.  This option disables constant folding of
floating-point expressions at compile time (which may be affected by
rounding mode) and arithmetic transformations that are unsafe in the
presence of sign-dependent rounding modes.</p>
<p>The default is <em class="xref std std-option">-fno-rounding-math</em>.</p>
<p>This option is experimental and does not currently guarantee to
disable all GCC optimizations that are affected by rounding mode.
Future versions of GCC may provide finer control of this setting
using C99&#8217;s <tt class="docutils literal"><span class="pre">FENV_ACCESS</span></tt> pragma.  This command-line option
will be used to specify the default state for <tt class="docutils literal"><span class="pre">FENV_ACCESS</span></tt>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsignaling-nans">
<tt class="descname">-fsignaling-nans</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsignaling-nans" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile code assuming that IEEE signaling NaNs may generate user-visible
traps during floating-point operations.  Setting this option disables
optimizations that may change the number of exceptions visible with
signaling NaNs.  This option implies <em class="xref std std-option">-ftrapping-math</em>.</p>
<p>This option causes the preprocessor macro <tt class="docutils literal"><span class="pre">__SUPPORT_SNAN__</span></tt> to
be defined.</p>
<p>The default is <em class="xref std std-option">-fno-signaling-nans</em>.</p>
<p>This option is experimental and does not currently guarantee to
disable all GCC optimizations that affect signaling NaN behavior.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsingle-precision-constant">
<tt class="descname">-fsingle-precision-constant</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsingle-precision-constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Treat floating-point constants as single precision instead of
implicitly converting them to double-precision constants.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fcx-limited-range">
<tt class="descname">-fcx-limited-range</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fcx-limited-range" title="Permalink to this definition">¶</a></dt>
<dd><p>When enabled, this option states that a range reduction step is not
needed when performing complex division.  Also, there is no checking
whether the result of a complex multiplication or division is <tt class="docutils literal"><span class="pre">NaN</span>
<span class="pre">+</span> <span class="pre">I*NaN</span></tt>, with an attempt to rescue the situation in that case.  The
default is <em class="xref std std-option">-fno-cx-limited-range</em>, but is enabled by
<a class="reference internal" href="#cmdoption-ffast-math"><em class="xref std std-option">-ffast-math</em></a>.</p>
<p>This option controls the default setting of the ISO C99
<tt class="docutils literal"><span class="pre">CX_LIMITED_RANGE</span></tt> pragma.  Nevertheless, the option applies to
all languages.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fcx-fortran-rules">
<tt class="descname">-fcx-fortran-rules</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fcx-fortran-rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex multiplication and division follow Fortran rules.  Range
reduction is done as part of complex division, but there is no checking
whether the result of a complex multiplication or division is <tt class="docutils literal"><span class="pre">NaN</span>
<span class="pre">+</span> <span class="pre">I*NaN</span></tt>, with an attempt to rescue the situation in that case.</p>
<p>The default is <em class="xref std std-option">-fno-cx-fortran-rules</em>.</p>
</dd></dl>

<p>The following options control optimizations that may improve
performance, but are not enabled by any <a class="reference internal" href="#cmdoption-O"><em class="xref std std-option">-O</em></a> options.  This
section includes experimental options that may produce broken code.</p>
<dl class="option">
<dt id="cmdoption-fbranch-probabilities">
<tt class="descname">-fbranch-probabilities</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fbranch-probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>After running a program compiled with <a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-fprofile-arcs"><em class="xref std std-option">-fprofile-arcs</em></a>
(see <a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#debugging-options"><em>Options for Debugging Your Program or GCC</em></a>), you can compile it a second time using
<a class="reference internal" href="#cmdoption-fbranch-probabilities"><em class="xref std std-option">-fbranch-probabilities</em></a>, to improve optimizations based on
the number of times each branch was taken.  When a program
compiled with <a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-fprofile-arcs"><em class="xref std std-option">-fprofile-arcs</em></a> exits, it saves arc execution
counts to a file called <tt class="docutils literal"><span class="pre">sourcename</span></tt>.gcda for each source
file.  The information in this data file is very dependent on the
structure of the generated code, so you must use the same source code
and the same optimization options for both compilations.</p>
<p>With <a class="reference internal" href="#cmdoption-fbranch-probabilities"><em class="xref std std-option">-fbranch-probabilities</em></a>, GCC puts a
REG_BR_PROB note on each JUMP_INSN and CALL_INSN.
These can be used to improve optimization.  Currently, they are only
used in one place: in reorg.c, instead of guessing which path a
branch is most likely to take, the REG_BR_PROB values are used to
exactly determine which path is taken more often.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fprofile-values">
<tt class="descname">-fprofile-values</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fprofile-values" title="Permalink to this definition">¶</a></dt>
<dd><p>If combined with <a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-fprofile-arcs"><em class="xref std std-option">-fprofile-arcs</em></a>, it adds code so that some
data about values of expressions in the program is gathered.</p>
<p>With <a class="reference internal" href="#cmdoption-fbranch-probabilities"><em class="xref std std-option">-fbranch-probabilities</em></a>, it reads back the data gathered
from profiling values of expressions for usage in optimizations.</p>
<p>Enabled with <a class="reference internal" href="#cmdoption-fprofile-generate"><em class="xref std std-option">-fprofile-generate</em></a> and <a class="reference internal" href="#cmdoption-fprofile-use"><em class="xref std std-option">-fprofile-use</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fprofile-reorder-functions">
<tt class="descname">-fprofile-reorder-functions</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fprofile-reorder-functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Function reordering based on profile instrumentation collects
first time of execution of a function and orders these functions
in ascending order.</p>
<p>Enabled with <a class="reference internal" href="#cmdoption-fprofile-use"><em class="xref std std-option">-fprofile-use</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fvpt">
<tt class="descname">-fvpt</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fvpt" title="Permalink to this definition">¶</a></dt>
<dd><p>If combined with <a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-fprofile-arcs"><em class="xref std std-option">-fprofile-arcs</em></a>, this option instructs the compiler
to add code to gather information about values of expressions.</p>
<p>With <a class="reference internal" href="#cmdoption-fbranch-probabilities"><em class="xref std std-option">-fbranch-probabilities</em></a>, it reads back the data gathered
and actually performs the optimizations based on them.
Currently the optimizations include specialization of division operations
using the knowledge about the value of the denominator.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-frename-registers">
<tt class="descname">-frename-registers</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-frename-registers" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to avoid false dependencies in scheduled code by making use
of registers left over after register allocation.  This optimization
most benefits processors with lots of registers.  Depending on the
debug information format adopted by the target, however, it can
make debugging impossible, since variables no longer stay in
a &#8216;home register&#8217;.</p>
<p>Enabled by default with <a class="reference internal" href="#cmdoption-funroll-loops"><em class="xref std std-option">-funroll-loops</em></a> and <a class="reference internal" href="#cmdoption-fpeel-loops"><em class="xref std std-option">-fpeel-loops</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fschedule-fusion">
<tt class="descname">-fschedule-fusion</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fschedule-fusion" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a target dependent pass over the instruction stream to schedule
instructions of same type together because target machine can execute them
more efficiently if they are adjacent to each other in the instruction flow.</p>
<p>Enabled at levels <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>, <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ftracer">
<tt class="descname">-ftracer</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ftracer" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform tail duplication to enlarge superblock size.  This transformation
simplifies the control flow of the function allowing other optimizations to do
a better job.</p>
<p>Enabled with <a class="reference internal" href="#cmdoption-fprofile-use"><em class="xref std std-option">-fprofile-use</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-funroll-loops">
<tt class="descname">-funroll-loops</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-funroll-loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Unroll loops whose number of iterations can be determined at compile time or
upon entry to the loop.  <a class="reference internal" href="#cmdoption-funroll-loops"><em class="xref std std-option">-funroll-loops</em></a> implies
<a class="reference internal" href="#cmdoption-frerun-cse-after-loop"><em class="xref std std-option">-frerun-cse-after-loop</em></a>, <a class="reference internal" href="#cmdoption-fweb"><em class="xref std std-option">-fweb</em></a> and <a class="reference internal" href="#cmdoption-frename-registers"><em class="xref std std-option">-frename-registers</em></a>.
It also turns on complete loop peeling (i.e. complete removal of loops with
a small constant number of iterations).  This option makes code larger, and may
or may not make it run faster.</p>
<p>Enabled with <a class="reference internal" href="#cmdoption-fprofile-use"><em class="xref std std-option">-fprofile-use</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-funroll-all-loops">
<tt class="descname">-funroll-all-loops</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-funroll-all-loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Unroll all loops, even if their number of iterations is uncertain when
the loop is entered.  This usually makes programs run more slowly.
<a class="reference internal" href="#cmdoption-funroll-all-loops"><em class="xref std std-option">-funroll-all-loops</em></a> implies the same options as
<a class="reference internal" href="#cmdoption-funroll-loops"><em class="xref std std-option">-funroll-loops</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fpeel-loops">
<tt class="descname">-fpeel-loops</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fpeel-loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Peels loops for which there is enough information that they do not
roll much (from profile feedback).  It also turns on complete loop peeling
(i.e. complete removal of loops with small constant number of iterations).</p>
<p>Enabled with <a class="reference internal" href="#cmdoption-fprofile-use"><em class="xref std std-option">-fprofile-use</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fmove-loop-invariants">
<tt class="descname">-fmove-loop-invariants</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fmove-loop-invariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables the loop invariant motion pass in the RTL loop optimizer.  Enabled
at level <em class="xref std std-option">-O1</em></p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-funswitch-loops">
<tt class="descname">-funswitch-loops</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-funswitch-loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Move branches with loop invariant conditions out of the loop, with duplicates
of the loop on both branches (modified according to result of the condition).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-ffunction-sections">
<tt class="descname">-ffunction-sections</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">-fdata-sections</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-ffunction-sections" title="Permalink to this definition">¶</a></dt>
<dd><p>Place each function or data item into its own section in the output
file if the target supports arbitrary sections.  The name of the
function or the name of the data item determines the section&#8217;s name
in the output file.</p>
<p>Use these options on systems where the linker can perform optimizations
to improve locality of reference in the instruction space.  Most systems
using the ELF object format and SPARC processors running Solaris 2 have
linkers with such optimizations.  AIX may have these optimizations in
the future.</p>
<p>Only use these options when there are significant benefits from doing
so.  When you specify these options, the assembler and linker
create larger object and executable files and are also slower.
You cannot use <strong class="command">gprof</strong> on all systems if you
specify this option, and you may have problems with debugging if
you specify both this option and <a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-g"><em class="xref std std-option">-g</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fbranch-target-load-optimize">
<tt class="descname">-fbranch-target-load-optimize</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fbranch-target-load-optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform branch target register load optimization before prologue / epilogue
threading.
The use of target registers can typically be exposed only during reload,
thus hoisting loads out of loops and doing inter-block scheduling needs
a separate optimization pass.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fbranch-target-load-optimize2">
<tt class="descname">-fbranch-target-load-optimize2</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fbranch-target-load-optimize2" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform branch target register load optimization after prologue / epilogue
threading.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fbtr-bb-exclusive">
<tt class="descname">-fbtr-bb-exclusive</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fbtr-bb-exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>When performing branch target register load optimization, don&#8217;t reuse
branch target registers within any basic block.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fstack-protector">
<tt class="descname">-fstack-protector</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fstack-protector" title="Permalink to this definition">¶</a></dt>
<dd><p>Emit extra code to check for buffer overflows, such as stack smashing
attacks.  This is done by adding a guard variable to functions with
vulnerable objects.  This includes functions that call <tt class="docutils literal"><span class="pre">alloca</span></tt>, and
functions with buffers larger than 8 bytes.  The guards are initialized
when a function is entered and then checked when the function exits.
If a guard check fails, an error message is printed and the program exits.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fstack-protector-all">
<tt class="descname">-fstack-protector-all</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fstack-protector-all" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#cmdoption-fstack-protector"><em class="xref std std-option">-fstack-protector</em></a> except that all functions are protected.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fstack-protector-strong">
<tt class="descname">-fstack-protector-strong</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fstack-protector-strong" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#cmdoption-fstack-protector"><em class="xref std std-option">-fstack-protector</em></a> but includes additional functions to
be protected - those that have local array definitions, or have
references to local frame addresses.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fstack-protector-explicit">
<tt class="descname">-fstack-protector-explicit</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fstack-protector-explicit" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#cmdoption-fstack-protector"><em class="xref std std-option">-fstack-protector</em></a> but only protects those functions which
have the <tt class="docutils literal"><span class="pre">stack_protect</span></tt> attribute</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fstdarg-opt">
<tt class="descname">-fstdarg-opt</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fstdarg-opt" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the prologue of variadic argument functions with respect to usage of
those arguments.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-fsection-anchors">
<tt class="descname">-fsection-anchors</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fsection-anchors" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to reduce the number of symbolic address calculations by using
shared &#8216;anchor&#8217; symbols to address nearby objects.  This transformation
can help to reduce the number of GOT entries and GOT accesses on some
targets.</p>
<p>For example, the implementation of the following function <tt class="docutils literal"><span class="pre">foo</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">foo</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>usually calculates the addresses of all three variables, but if you
compile it with <a class="reference internal" href="#cmdoption-fsection-anchors"><em class="xref std std-option">-fsection-anchors</em></a>, it accesses the variables
from a common anchor point instead.  The effect is similar to the
following pseudocode (which isn&#8217;t valid C):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">foo</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">xr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">xr</span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">xr</span><span class="p">[</span><span class="o">&amp;</span><span class="n">b</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">xr</span><span class="p">[</span><span class="o">&amp;</span><span class="n">c</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Not all targets support this option.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--param">
<tt class="descname">--param</tt><tt class="descclassname"> name=value</tt><a class="headerlink" href="#cmdoption--param" title="Permalink to this definition">¶</a></dt>
<dd><p>In some places, GCC uses various constants to control the amount of
optimization that is done.  For example, GCC does not inline functions
that contain more than a certain number of instructions.  You can
control some of these constants on the command line using the
<a class="reference internal" href="#cmdoption--param"><em class="xref std std-option">--param</em></a> option.</p>
<p>The names of specific parameters, and the meaning of the values, are
tied to the internals of the compiler, and are subject to change
without notice in future releases.</p>
<p>In each case, the <tt class="docutils literal"><span class="pre">value</span></tt> is an integer.  The allowable choices for
<tt class="docutils literal"><span class="pre">name</span></tt> are:</p>
<dl class="docutils">
<dt>predictable-branch-outcome</dt>
<dd>When branch is predicted to be taken with probability lower than this threshold
(in percent), then it is considered well predictable. The default is 10.</dd>
<dt>max-crossjump-edges</dt>
<dd>The maximum number of incoming edges to consider for cross-jumping.
The algorithm used by <a class="reference internal" href="#cmdoption-fcrossjumping"><em class="xref std std-option">-fcrossjumping</em></a> is O(N^2) in
the number of edges incoming to each block.  Increasing values mean
more aggressive optimization, making the compilation time increase with
probably small improvement in executable size.</dd>
<dt>min-crossjump-insns</dt>
<dd>The minimum number of instructions that must be matched at the end
of two blocks before cross-jumping is performed on them.  This
value is ignored in the case where all instructions in the block being
cross-jumped from are matched.  The default value is 5.</dd>
<dt>max-grow-copy-bb-insns</dt>
<dd>The maximum code size expansion factor when copying basic blocks
instead of jumping.  The expansion is relative to a jump instruction.
The default value is 8.</dd>
<dt>max-goto-duplication-insns</dt>
<dd>The maximum number of instructions to duplicate to a block that jumps
to a computed goto.  To avoid O(N^2) behavior in a number of
passes, GCC factors computed gotos early in the compilation process,
and unfactors them as late as possible.  Only computed jumps at the
end of a basic blocks with no more than max-goto-duplication-insns are
unfactored.  The default value is 8.</dd>
<dt>max-delay-slot-insn-search</dt>
<dd>The maximum number of instructions to consider when looking for an
instruction to fill a delay slot.  If more than this arbitrary number of
instructions are searched, the time savings from filling the delay slot
are minimal, so stop searching.  Increasing values mean more
aggressive optimization, making the compilation time increase with probably
small improvement in execution time.</dd>
<dt>max-delay-slot-live-search</dt>
<dd>When trying to fill delay slots, the maximum number of instructions to
consider when searching for a block with valid live register
information.  Increasing this arbitrarily chosen value means more
aggressive optimization, increasing the compilation time.  This parameter
should be removed when the delay slot code is rewritten to maintain the
control-flow graph.</dd>
<dt>max-gcse-memory</dt>
<dd>The approximate maximum amount of memory that can be allocated in
order to perform the global common subexpression elimination
optimization.  If more memory than specified is required, the
optimization is not done.</dd>
<dt>max-gcse-insertion-ratio</dt>
<dd>If the ratio of expression insertions to deletions is larger than this value
for any expression, then RTL PRE inserts or removes the expression and thus
leaves partially redundant computations in the instruction stream.  The default value is 20.</dd>
<dt>max-pending-list-length</dt>
<dd>The maximum number of pending dependencies scheduling allows
before flushing the current state and starting over.  Large functions
with few branches or calls can create excessively large lists which
needlessly consume memory and resources.</dd>
<dt>max-modulo-backtrack-attempts</dt>
<dd>The maximum number of backtrack attempts the scheduler should make
when modulo scheduling a loop.  Larger values can exponentially increase
compilation time.</dd>
<dt>max-inline-insns-single</dt>
<dd>Several parameters control the tree inliner used in GCC.
This number sets the maximum number of instructions (counted in GCC&#8217;s
internal representation) in a single function that the tree inliner
considers for inlining.  This only affects functions declared
inline and methods implemented in a class declaration (C++).
The default value is 400.</dd>
<dt>max-inline-insns-auto</dt>
<dd>When you use <a class="reference internal" href="#cmdoption-finline-functions"><em class="xref std std-option">-finline-functions</em></a> (included in <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>),
a lot of functions that would otherwise not be considered for inlining
by the compiler are investigated.  To those functions, a different
(more restrictive) limit compared to functions declared inline can
be applied.
The default value is 40.</dd>
<dt>inline-min-speedup</dt>
<dd>When estimated performance improvement of caller + callee runtime exceeds this
threshold (in precent), the function can be inlined regardless the limit on
<em class="xref std std-option">--param max-inline-insns-single</em> and <em class="xref std std-option">--param
max-inline-insns-auto</em>.</dd>
<dt>large-function-insns</dt>
<dd>The limit specifying really large functions.  For functions larger than this
limit after inlining, inlining is constrained by
<em class="xref std std-option">--param large-function-growth</em>.  This parameter is useful primarily
to avoid extreme compilation time caused by non-linear algorithms used by the
back end.
The default value is 2700.</dd>
<dt>large-function-growth</dt>
<dd>Specifies maximal growth of large function caused by inlining in percents.
The default value is 100 which limits large function growth to 2.0 times
the original size.</dd>
<dt>large-unit-insns</dt>
<dd>The limit specifying large translation unit.  Growth caused by inlining of
units larger than this limit is limited by <em class="xref std std-option">--param inline-unit-growth</em>.
For small units this might be too tight.
For example, consider a unit consisting of function A
that is inline and B that just calls A three times.  If B is small relative to
A, the growth of unit is 300% and yet such inlining is very sane.  For very
large units consisting of small inlineable functions, however, the overall unit
growth limit is needed to avoid exponential explosion of code size.  Thus for
smaller units, the size is increased to <em class="xref std std-option">--param large-unit-insns</em>
before applying <em class="xref std std-option">--param inline-unit-growth</em>.  The default is 10000.</dd>
<dt>inline-unit-growth</dt>
<dd>Specifies maximal overall growth of the compilation unit caused by inlining.
The default value is 20 which limits unit growth to 1.2 times the original
size. Cold functions (either marked cold via an attribute or by profile
feedback) are not accounted into the unit size.</dd>
<dt>ipcp-unit-growth</dt>
<dd>Specifies maximal overall growth of the compilation unit caused by
interprocedural constant propagation.  The default value is 10 which limits
unit growth to 1.1 times the original size.</dd>
<dt>large-stack-frame</dt>
<dd>The limit specifying large stack frames.  While inlining the algorithm is trying
to not grow past this limit too much.  The default value is 256 bytes.</dd>
<dt>large-stack-frame-growth</dt>
<dd>Specifies maximal growth of large stack frames caused by inlining in percents.
The default value is 1000 which limits large stack frame growth to 11 times
the original size.</dd>
<dt>max-inline-insns-recursive max-inline-insns-recursive-auto</dt>
<dd><p class="first">Specifies the maximum number of instructions an out-of-line copy of a
self-recursive inline
function can grow into by performing recursive inlining.</p>
<p class="last"><em class="xref std std-option">--param max-inline-insns-recursive</em> applies to functions
declared inline.
For functions not declared inline, recursive inlining
happens only when <a class="reference internal" href="#cmdoption-finline-functions"><em class="xref std std-option">-finline-functions</em></a> (included in <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>) is
enabled; <em class="xref std std-option">--param max-inline-insns-recursive-auto</em> applies instead.  The
default value is 450.</p>
</dd>
<dt>max-inline-recursive-depth max-inline-recursive-depth-auto</dt>
<dd><p class="first">Specifies the maximum recursion depth used for recursive inlining.</p>
<p class="last"><em class="xref std std-option">--param max-inline-recursive-depth</em> applies to functions
declared inline.  For functions not declared inline, recursive inlining
happens only when <a class="reference internal" href="#cmdoption-finline-functions"><em class="xref std std-option">-finline-functions</em></a> (included in <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>) is
enabled; <em class="xref std std-option">--param max-inline-recursive-depth-auto</em> applies instead.  The
default value is 8.</p>
</dd>
<dt>min-inline-recursive-probability</dt>
<dd><p class="first">Recursive inlining is profitable only for function having deep recursion
in average and can hurt for function having little recursion depth by
increasing the prologue size or complexity of function body to other
optimizers.</p>
<p class="last">When profile feedback is available (see <a class="reference internal" href="#cmdoption-fprofile-generate"><em class="xref std std-option">-fprofile-generate</em></a>) the actual
recursion depth can be guessed from probability that function recurses via a
given call expression.  This parameter limits inlining only to call expressions
whose probability exceeds the given threshold (in percents).
The default value is 10.</p>
</dd>
<dt>early-inlining-insns</dt>
<dd>Specify growth that the early inliner can make.  In effect it increases
the amount of inlining for code having a large abstraction penalty.
The default value is 14.</dd>
<dt>max-early-inliner-iterations</dt>
<dd>Limit of iterations of the early inliner.  This basically bounds
the number of nested indirect calls the early inliner can resolve.
Deeper chains are still handled by late inlining.</dd>
<dt>comdat-sharing-probability</dt>
<dd>Probability (in percent) that C++ inline function with comdat visibility
are shared across multiple compilation units.  The default value is 20.</dd>
<dt>profile-func-internal-id</dt>
<dd>A parameter to control whether to use function internal id in profile
database lookup. If the value is 0, the compiler uses an id that
is based on function assembler name and filename, which makes old profile
data more tolerant to source changes such as function reordering etc.
The default value is 0.</dd>
<dt>min-vect-loop-bound</dt>
<dd>The minimum number of iterations under which loops are not vectorized
when <a class="reference internal" href="#cmdoption-ftree-vectorize"><em class="xref std std-option">-ftree-vectorize</em></a> is used.  The number of iterations after
vectorization needs to be greater than the value specified by this option
to allow vectorization.  The default value is 0.</dd>
<dt>gcse-cost-distance-ratio</dt>
<dd>Scaling factor in calculation of maximum distance an expression
can be moved by GCSE optimizations.  This is currently supported only in the
code hoisting pass.  The bigger the ratio, the more aggressive code hoisting
is with simple expressions, i.e., the expressions that have cost
less than gcse-unrestricted-cost.  Specifying 0 disables
hoisting of simple expressions.  The default value is 10.</dd>
<dt>gcse-unrestricted-cost</dt>
<dd>Cost, roughly measured as the cost of a single typical machine
instruction, at which GCSE optimizations do not constrain
the distance an expression can travel.  This is currently
supported only in the code hoisting pass.  The lesser the cost,
the more aggressive code hoisting is.  Specifying 0
allows all expressions to travel unrestricted distances.
The default value is 3.</dd>
<dt>max-hoist-depth</dt>
<dd>The depth of search in the dominator tree for expressions to hoist.
This is used to avoid quadratic behavior in hoisting algorithm.
The value of 0 does not limit on the search, but may slow down compilation
of huge functions.  The default value is 30.</dd>
<dt>max-tail-merge-comparisons</dt>
<dd>The maximum amount of similar bbs to compare a bb with.  This is used to
avoid quadratic behavior in tree tail merging.  The default value is 10.</dd>
<dt>max-tail-merge-iterations</dt>
<dd>The maximum amount of iterations of the pass over the function.  This is used to
limit compilation time in tree tail merging.  The default value is 2.</dd>
<dt>max-unrolled-insns</dt>
<dd>The maximum number of instructions that a loop may have to be unrolled.
If a loop is unrolled, this parameter also determines how many times
the loop code is unrolled.</dd>
<dt>max-average-unrolled-insns</dt>
<dd>The maximum number of instructions biased by probabilities of their execution
that a loop may have to be unrolled.  If a loop is unrolled,
this parameter also determines how many times the loop code is unrolled.</dd>
<dt>max-unroll-times</dt>
<dd>The maximum number of unrollings of a single loop.</dd>
<dt>max-peeled-insns</dt>
<dd>The maximum number of instructions that a loop may have to be peeled.
If a loop is peeled, this parameter also determines how many times
the loop code is peeled.</dd>
<dt>max-peel-times</dt>
<dd>The maximum number of peelings of a single loop.</dd>
<dt>max-peel-branches</dt>
<dd>The maximum number of branches on the hot path through the peeled sequence.</dd>
<dt>max-completely-peeled-insns</dt>
<dd>The maximum number of insns of a completely peeled loop.</dd>
<dt>max-completely-peel-times</dt>
<dd>The maximum number of iterations of a loop to be suitable for complete peeling.</dd>
<dt>max-completely-peel-loop-nest-depth</dt>
<dd>The maximum depth of a loop nest suitable for complete peeling.</dd>
<dt>max-unswitch-insns</dt>
<dd>The maximum number of insns of an unswitched loop.</dd>
<dt>max-unswitch-level</dt>
<dd>The maximum number of branches unswitched in a single loop.</dd>
<dt>lim-expensive</dt>
<dd>The minimum cost of an expensive expression in the loop invariant motion.</dd>
<dt>iv-consider-all-candidates-bound</dt>
<dd>Bound on number of candidates for induction variables, below which
all candidates are considered for each use in induction variable
optimizations.  If there are more candidates than this,
only the most relevant ones are considered to avoid quadratic time complexity.</dd>
<dt>iv-max-considered-uses</dt>
<dd>The induction variable optimizations give up on loops that contain more
induction variable uses.</dd>
<dt>iv-always-prune-cand-set-bound</dt>
<dd>If the number of candidates in the set is smaller than this value,
always try to remove unnecessary ivs from the set
when adding a new one.</dd>
<dt>scev-max-expr-size</dt>
<dd>Bound on size of expressions used in the scalar evolutions analyzer.
Large expressions slow the analyzer.</dd>
<dt>scev-max-expr-complexity</dt>
<dd>Bound on the complexity of the expressions in the scalar evolutions analyzer.
Complex expressions slow the analyzer.</dd>
<dt>omega-max-vars</dt>
<dd>The maximum number of variables in an Omega constraint system.
The default value is 128.</dd>
<dt>omega-max-geqs</dt>
<dd>The maximum number of inequalities in an Omega constraint system.
The default value is 256.</dd>
<dt>omega-max-eqs</dt>
<dd>The maximum number of equalities in an Omega constraint system.
The default value is 128.</dd>
<dt>omega-max-wild-cards</dt>
<dd>The maximum number of wildcard variables that the Omega solver is
able to insert.  The default value is 18.</dd>
<dt>omega-hash-table-size</dt>
<dd>The size of the hash table in the Omega solver.  The default value is
550.</dd>
<dt>omega-max-keys</dt>
<dd>The maximal number of keys used by the Omega solver.  The default
value is 500.</dd>
<dt>omega-eliminate-redundant-constraints</dt>
<dd>When set to 1, use expensive methods to eliminate all redundant
constraints.  The default value is 0.</dd>
<dt>vect-max-version-for-alignment-checks</dt>
<dd>The maximum number of run-time checks that can be performed when
doing loop versioning for alignment in the vectorizer.</dd>
<dt>vect-max-version-for-alias-checks</dt>
<dd>The maximum number of run-time checks that can be performed when
doing loop versioning for alias in the vectorizer.</dd>
<dt>vect-max-peeling-for-alignment</dt>
<dd>The maximum number of loop peels to enhance access alignment
for vectorizer. Value -1 means &#8216;no limit&#8217;.</dd>
<dt>max-iterations-to-track</dt>
<dd>The maximum number of iterations of a loop the brute-force algorithm
for analysis of the number of iterations of the loop tries to evaluate.</dd>
<dt>hot-bb-count-ws-permille</dt>
<dd>A basic block profile count is considered hot if it contributes to
the given permillage (i.e. 0...1000) of the entire profiled execution.</dd>
<dt>hot-bb-frequency-fraction</dt>
<dd>Select fraction of the entry block frequency of executions of basic block in
function given basic block needs to have to be considered hot.</dd>
<dt>max-predicted-iterations</dt>
<dd>The maximum number of loop iterations we predict statically.  This is useful
in cases where a function contains a single loop with known bound and
another loop with unknown bound.
The known number of iterations is predicted correctly, while
the unknown number of iterations average to roughly 10.  This means that the
loop without bounds appears artificially cold relative to the other one.</dd>
<dt>builtin-expect-probability</dt>
<dd>Control the probability of the expression having the specified value. This
parameter takes a percentage (i.e. 0 ... 100) as input.
The default probability of 90 is obtained empirically.</dd>
<dt>align-threshold</dt>
<dd>Select fraction of the maximal frequency of executions of a basic block in
a function to align the basic block.</dd>
<dt>align-loop-iterations</dt>
<dd>A loop expected to iterate at least the selected number of iterations is
aligned.</dd>
<dt>tracer-dynamic-coverage tracer-dynamic-coverage-feedback</dt>
<dd><p class="first">This value is used to limit superblock formation once the given percentage of
executed instructions is covered.  This limits unnecessary code size
expansion.</p>
<p class="last">The tracer-dynamic-coverage-feedback parameter
is used only when profile
feedback is available.  The real profiles (as opposed to statically estimated
ones) are much less balanced allowing the threshold to be larger value.</p>
</dd>
<dt>tracer-max-code-growth</dt>
<dd>Stop tail duplication once code growth has reached given percentage.  This is
a rather artificial limit, as most of the duplicates are eliminated later in
cross jumping, so it may be set to much higher values than is the desired code
growth.</dd>
<dt>tracer-min-branch-ratio</dt>
<dd>Stop reverse growth when the reverse probability of best edge is less than this
threshold (in percent).</dd>
<dt>tracer-min-branch-ratio tracer-min-branch-ratio-feedback</dt>
<dd><p class="first">Stop forward growth if the best edge has probability lower than this
threshold.</p>
<p class="last">Similarly to tracer-dynamic-coverage two values are present, one for
compilation for profile feedback and one for compilation without.  The value
for compilation with profile feedback needs to be more conservative (higher) in
order to make tracer effective.</p>
</dd>
<dt>max-cse-path-length</dt>
<dd>The maximum number of basic blocks on path that CSE considers.
The default is 10.</dd>
<dt>max-cse-insns</dt>
<dd>The maximum number of instructions CSE processes before flushing.
The default is 1000.</dd>
<dt>ggc-min-expand</dt>
<dd><p class="first">GCC uses a garbage collector to manage its own memory allocation.  This
parameter specifies the minimum percentage by which the garbage
collector&#8217;s heap should be allowed to expand between collections.
Tuning this may improve compilation speed; it has no effect on code
generation.</p>
<p class="last">The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when
RAM &gt;= 1GB.  If <tt class="docutils literal"><span class="pre">getrlimit</span></tt> is available, the notion of &#8216;RAM&#8217; is
the smallest of actual RAM and <tt class="docutils literal"><span class="pre">RLIMIT_DATA</span></tt> or <tt class="docutils literal"><span class="pre">RLIMIT_AS</span></tt>.  If
GCC is not able to calculate RAM on a particular platform, the lower
bound of 30% is used.  Setting this parameter and
ggc-min-heapsize to zero causes a full collection to occur at
every opportunity.  This is extremely slow, but can be useful for
debugging.</p>
</dd>
<dt>ggc-min-heapsize</dt>
<dd><p class="first">Minimum size of the garbage collector&#8217;s heap before it begins bothering
to collect garbage.  The first collection occurs after the heap expands
by ggc-min-expand% beyond ggc-min-heapsize.  Again,
tuning this may improve compilation speed, and has no effect on code
generation.</p>
<p class="last">The default is the smaller of RAM/8, RLIMIT_RSS, or a limit that
tries to ensure that RLIMIT_DATA or RLIMIT_AS are not exceeded, but
with a lower bound of 4096 (four megabytes) and an upper bound of
131072 (128 megabytes).  If GCC is not able to calculate RAM on a
particular platform, the lower bound is used.  Setting this parameter
very large effectively disables garbage collection.  Setting this
parameter and ggc-min-expand to zero causes a full collection
to occur at every opportunity.</p>
</dd>
<dt>max-reload-search-insns</dt>
<dd>The maximum number of instruction reload should look backward for equivalent
register.  Increasing values mean more aggressive optimization, making the
compilation time increase with probably slightly better performance.
The default value is 100.</dd>
<dt>max-cselib-memory-locations</dt>
<dd>The maximum number of memory locations cselib should take into account.
Increasing values mean more aggressive optimization, making the compilation time
increase with probably slightly better performance.  The default value is 500.</dd>
<dt>reorder-blocks-duplicate reorder-blocks-duplicate-feedback</dt>
<dd><p class="first">Used by the basic block reordering pass to decide whether to use unconditional
branch or duplicate the code on its destination.  Code is duplicated when its
estimated size is smaller than this value multiplied by the estimated size of
unconditional jump in the hot spots of the program.</p>
<p class="last">The reorder-block-duplicate-feedback parameter
is used only when profile
feedback is available.  It may be set to higher values than
reorder-block-duplicate since information about the hot spots is more
accurate.</p>
</dd>
<dt>max-sched-ready-insns</dt>
<dd>The maximum number of instructions ready to be issued the scheduler should
consider at any given time during the first scheduling pass.  Increasing
values mean more thorough searches, making the compilation time increase
with probably little benefit.  The default value is 100.</dd>
<dt>max-sched-region-blocks</dt>
<dd>The maximum number of blocks in a region to be considered for
interblock scheduling.  The default value is 10.</dd>
<dt>max-pipeline-region-blocks</dt>
<dd>The maximum number of blocks in a region to be considered for
pipelining in the selective scheduler.  The default value is 15.</dd>
<dt>max-sched-region-insns</dt>
<dd>The maximum number of insns in a region to be considered for
interblock scheduling.  The default value is 100.</dd>
<dt>max-pipeline-region-insns</dt>
<dd>The maximum number of insns in a region to be considered for
pipelining in the selective scheduler.  The default value is 200.</dd>
<dt>min-spec-prob</dt>
<dd>The minimum probability (in percents) of reaching a source block
for interblock speculative scheduling.  The default value is 40.</dd>
<dt>max-sched-extend-regions-iters</dt>
<dd>The maximum number of iterations through CFG to extend regions.
A value of 0 (the default) disables region extensions.</dd>
<dt>max-sched-insn-conflict-delay</dt>
<dd>The maximum conflict delay for an insn to be considered for speculative motion.
The default value is 3.</dd>
<dt>sched-spec-prob-cutoff</dt>
<dd>The minimal probability of speculation success (in percents), so that
speculative insns are scheduled.
The default value is 40.</dd>
<dt>sched-spec-state-edge-prob-cutoff</dt>
<dd>The minimum probability an edge must have for the scheduler to save its
state across it.
The default value is 10.</dd>
<dt>sched-mem-true-dep-cost</dt>
<dd>Minimal distance (in CPU cycles) between store and load targeting same
memory locations.  The default value is 1.</dd>
<dt>selsched-max-lookahead</dt>
<dd>The maximum size of the lookahead window of selective scheduling.  It is a
depth of search for available instructions.
The default value is 50.</dd>
<dt>selsched-max-sched-times</dt>
<dd>The maximum number of times that an instruction is scheduled during
selective scheduling.  This is the limit on the number of iterations
through which the instruction may be pipelined.  The default value is 2.</dd>
<dt>selsched-max-insns-to-rename</dt>
<dd>The maximum number of best instructions in the ready list that are considered
for renaming in the selective scheduler.  The default value is 2.</dd>
<dt>sms-min-sc</dt>
<dd>The minimum value of stage count that swing modulo scheduler
generates.  The default value is 2.</dd>
<dt>max-last-value-rtl</dt>
<dd>The maximum size measured as number of RTLs that can be recorded in an expression
in combiner for a pseudo register as last known value of that register.  The default
is 10000.</dd>
<dt>max-combine-insns</dt>
<dd>The maximum number of instructions the RTL combiner tries to combine.
The default value is 2 at <a class="reference internal" href="#cmdoption-Og"><em class="xref std std-option">-Og</em></a> and 4 otherwise.</dd>
<dt>integer-share-limit</dt>
<dd>Small integer constants can use a shared data structure, reducing the
compiler&#8217;s memory usage and increasing its speed.  This sets the maximum
value of a shared integer constant.  The default value is 256.</dd>
<dt>ssp-buffer-size</dt>
<dd>The minimum size of buffers (i.e. arrays) that receive stack smashing
protection when <em class="xref std std-option">-fstack-protection</em> is used.</dd>
<dt>min-size-for-stack-sharing</dt>
<dd>The minimum size of variables taking part in stack slot sharing when not
optimizing. The default value is 32.</dd>
<dt>max-jump-thread-duplication-stmts</dt>
<dd>Maximum number of statements allowed in a block that needs to be
duplicated when threading jumps.</dd>
<dt>max-fields-for-field-sensitive</dt>
<dd>Maximum number of fields in a structure treated in
a field sensitive manner during pointer analysis.  The default is zero
for <a class="reference internal" href="#cmdoption-O0"><em class="xref std std-option">-O0</em></a> and <em class="xref std std-option">-O1</em>,
and 100 for <a class="reference internal" href="#cmdoption-Os"><em class="xref std std-option">-Os</em></a>, <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a>, and <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>.</dd>
<dt>prefetch-latency</dt>
<dd>Estimate on average number of instructions that are executed before
prefetch finishes.  The distance prefetched ahead is proportional
to this constant.  Increasing this number may also lead to less
streams being prefetched (see simultaneous-prefetches).</dd>
<dt>simultaneous-prefetches</dt>
<dd>Maximum number of prefetches that can run at the same time.</dd>
<dt>l1-cache-line-size</dt>
<dd>The size of cache line in L1 cache, in bytes.</dd>
<dt>l1-cache-size</dt>
<dd>The size of L1 cache, in kilobytes.</dd>
<dt>l2-cache-size</dt>
<dd>The size of L2 cache, in kilobytes.</dd>
<dt>min-insn-to-prefetch-ratio</dt>
<dd>The minimum ratio between the number of instructions and the
number of prefetches to enable prefetching in a loop.</dd>
<dt>prefetch-min-insn-to-mem-ratio</dt>
<dd>The minimum ratio between the number of instructions and the
number of memory references to enable prefetching in a loop.</dd>
<dt>use-canonical-types</dt>
<dd>Whether the compiler should use the &#8216;canonical&#8217; type system.  By
default, this should always be 1, which uses a more efficient internal
mechanism for comparing types in C++ and Objective-C++.  However, if
bugs in the canonical type system are causing compilation failures,
set this value to 0 to disable canonical types.</dd>
<dt>switch-conversion-max-branch-ratio</dt>
<dd>Switch initialization conversion refuses to create arrays that are
bigger than switch-conversion-max-branch-ratio times the number of
branches in the switch.</dd>
<dt>max-partial-antic-length</dt>
<dd>Maximum length of the partial antic set computed during the tree
partial redundancy elimination optimization (<a class="reference internal" href="#cmdoption-ftree-pre"><em class="xref std std-option">-ftree-pre</em></a>) when
optimizing at <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a> and above.  For some sorts of source code
the enhanced partial redundancy elimination optimization can run away,
consuming all of the memory available on the host machine.  This
parameter sets a limit on the length of the sets that are computed,
which prevents the runaway behavior.  Setting a value of 0 for
this parameter allows an unlimited set length.</dd>
<dt>sccvn-max-scc-size</dt>
<dd>Maximum size of a strongly connected component (SCC) during SCCVN
processing.  If this limit is hit, SCCVN processing for the whole
function is not done and optimizations depending on it are
disabled.  The default maximum SCC size is 10000.</dd>
<dt>sccvn-max-alias-queries-per-access</dt>
<dd>Maximum number of alias-oracle queries we perform when looking for
redundancies for loads and stores.  If this limit is hit the search
is aborted and the load or store is not considered redundant.  The
number of queries is algorithmically limited to the number of
stores on all paths from the load to the function entry.
The default maxmimum number of queries is 1000.</dd>
<dt>ira-max-loops-num</dt>
<dd>IRA uses regional register allocation by default.  If a function
contains more loops than the number given by this parameter, only at most
the given number of the most frequently-executed loops form regions
for regional register allocation.  The default value of the
parameter is 100.</dd>
<dt>ira-max-conflict-table-size</dt>
<dd>Although IRA uses a sophisticated algorithm to compress the conflict
table, the table can still require excessive amounts of memory for
huge functions.  If the conflict table for a function could be more
than the size in MB given by this parameter, the register allocator
instead uses a faster, simpler, and lower-quality
algorithm that does not require building a pseudo-register conflict table.
The default value of the parameter is 2000.</dd>
<dt>ira-loop-reserved-regs</dt>
<dd>IRA can be used to evaluate more accurate register pressure in loops
for decisions to move loop invariants (see <a class="reference internal" href="#cmdoption-O3"><em class="xref std std-option">-O3</em></a>).  The number
of available registers reserved for some other purposes is given
by this parameter.  The default value of the parameter is 2, which is
the minimal number of registers needed by typical instructions.
This value is the best found from numerous experiments.</dd>
<dt>lra-inheritance-ebb-probability-cutoff</dt>
<dd>LRA tries to reuse values reloaded in registers in subsequent insns.
This optimization is called inheritance.  EBB is used as a region to
do this optimization.  The parameter defines a minimal fall-through
edge probability in percentage used to add BB to inheritance EBB in
LRA.  The default value of the parameter is 40.  The value was chosen
from numerous runs of SPEC2000 on x86-64.</dd>
<dt>loop-invariant-max-bbs-in-loop</dt>
<dd>Loop invariant motion can be very expensive, both in compilation time and
in amount of needed compile-time memory, with very large loops.  Loops
with more basic blocks than this parameter won&#8217;t have loop invariant
motion optimization performed on them.  The default value of the
parameter is 1000 for <em class="xref std std-option">-O1</em> and 10000 for <a class="reference internal" href="#cmdoption-O2"><em class="xref std std-option">-O2</em></a> and above.</dd>
<dt>loop-max-datarefs-for-datadeps</dt>
<dd>Building data dapendencies is expensive for very large loops.  This
parameter limits the number of data references in loops that are
considered for data dependence analysis.  These large loops are no
handled by the optimizations using loop data dependencies.
The default value is 1000.</dd>
<dt>max-vartrack-size</dt>
<dd>Sets a maximum number of hash table slots to use during variable
tracking dataflow analysis of any function.  If this limit is exceeded
with variable tracking at assignments enabled, analysis for that
function is retried without it, after removing all debug insns from
the function.  If the limit is exceeded even without debug insns, var
tracking analysis is completely disabled for the function.  Setting
the parameter to zero makes it unlimited.</dd>
<dt>max-vartrack-expr-depth</dt>
<dd>Sets a maximum number of recursion levels when attempting to map
variable names or debug temporaries to value expressions.  This trades
compilation time for more complete debug information.  If this is set too
low, value expressions that are available and could be represented in
debug information may end up not being used; setting this higher may
enable the compiler to find more complex debug expressions, but compile
time and memory use may grow.  The default is 12.</dd>
<dt>min-nondebug-insn-uid</dt>
<dd>Use uids starting at this parameter for nondebug insns.  The range below
the parameter is reserved exclusively for debug insns created by
<a class="reference internal" href="options-for-debugging-your-program-or-gcc.html#cmdoption-fvar-tracking-assignments"><em class="xref std std-option">-fvar-tracking-assignments</em></a>, but debug insns may get
(non-overlapping) uids above it if the reserved range is exhausted.</dd>
<dt>ipa-sra-ptr-growth-factor</dt>
<dd><p class="first">IPA-SRA replaces a pointer to an aggregate with one or more new
parameters only when their cumulative size is less or equal to
ipa-sra-ptr-growth-factor times the size of the original
pointer parameter.</p>
<p class="last">sra-max-scalarization-size-Ospeed</p>
</dd>
<dt>sra-max-scalarization-size-Osize</dt>
<dd>The two Scalar Reduction of Aggregates passes (SRA and IPA-SRA) aim to
replace scalar parts of aggregates with uses of independent scalar
variables.  These parameters control the maximum size, in storage units,
of aggregate which is considered for replacement when compiling for
speed
(sra-max-scalarization-size-Ospeed) or size
(sra-max-scalarization-size-Osize) respectively.</dd>
<dt>tm-max-aggregate-size</dt>
<dd>When making copies of thread-local variables in a transaction, this
parameter specifies the size in bytes after which variables are
saved with the logging functions as opposed to save/restore code
sequence pairs.  This option only applies when using
<a class="reference internal" href="options-controlling-c-dialect.html#cmdoption-fgnu-tm"><em class="xref std std-option">-fgnu-tm</em></a>.</dd>
<dt>graphite-max-nb-scop-params</dt>
<dd>To avoid exponential effects in the Graphite loop transforms, the
number of parameters in a Static Control Part (SCoP) is bounded.  The
default value is 10 parameters.  A variable whose value is unknown at
compilation time and defined outside a SCoP is a parameter of the SCoP.</dd>
<dt>graphite-max-bbs-per-function</dt>
<dd>To avoid exponential effects in the detection of SCoPs, the size of
the functions analyzed by Graphite is bounded.  The default value is
100 basic blocks.</dd>
<dt>loop-block-tile-size</dt>
<dd>Loop blocking or strip mining transforms, enabled with
<a class="reference internal" href="#cmdoption-floop-block"><em class="xref std std-option">-floop-block</em></a> or <a class="reference internal" href="#cmdoption-floop-strip-mine"><em class="xref std std-option">-floop-strip-mine</em></a>, strip mine each
loop in the loop nest by a given number of iterations.  The strip
length can be changed using the loop-block-tile-size
parameter.  The default value is 51 iterations.</dd>
<dt>loop-unroll-jam-size</dt>
<dd>Specify the unroll factor for the <a class="reference internal" href="#cmdoption-floop-unroll-and-jam"><em class="xref std std-option">-floop-unroll-and-jam</em></a> option.  The
default value is 4.</dd>
<dt>loop-unroll-jam-depth</dt>
<dd>Specify the dimension to be unrolled (counting from the most inner loop)
for the  <a class="reference internal" href="#cmdoption-floop-unroll-and-jam"><em class="xref std std-option">-floop-unroll-and-jam</em></a>.  The default value is 2.</dd>
<dt>ipa-cp-value-list-size</dt>
<dd>IPA-CP attempts to track all possible values and types passed to a function&#8217;s
parameter in order to propagate them and perform devirtualization.
ipa-cp-value-list-size is the maximum number of values and types it
stores per one formal parameter of a function.</dd>
<dt>ipa-cp-eval-threshold</dt>
<dd>IPA-CP calculates its own score of cloning profitability heuristics
and performs those cloning opportunities with scores that exceed
ipa-cp-eval-threshold.</dd>
<dt>ipa-cp-recursion-penalty</dt>
<dd>Percentage penalty the recursive functions will receive when they
are evaluated for cloning.</dd>
<dt>ipa-cp-single-call-penalty</dt>
<dd>Percentage penalty functions containg a single call to another
function will receive when they are evaluated for cloning.</dd>
<dt>ipa-max-agg-items</dt>
<dd>IPA-CP is also capable to propagate a number of scalar values passed
in an aggregate. ipa-max-agg-items controls the maximum
number of such values per one parameter.</dd>
<dt>ipa-cp-loop-hint-bonus</dt>
<dd>When IPA-CP determines that a cloning candidate would make the number
of iterations of a loop known, it adds a bonus of
ipa-cp-loop-hint-bonus to the profitability score of
the candidate.</dd>
<dt>ipa-cp-array-index-hint-bonus</dt>
<dd>When IPA-CP determines that a cloning candidate would make the index of
an array access known, it adds a bonus of
ipa-cp-array-index-hint-bonus to the profitability
score of the candidate.</dd>
<dt>ipa-max-aa-steps</dt>
<dd>During its analysis of function bodies, IPA-CP employs alias analysis
in order to track values pointed to by function parameters.  In order
not spend too much time analyzing huge functions, it gives up and
consider all memory clobbered after examining
ipa-max-aa-steps statements modifying memory.</dd>
<dt>lto-partitions</dt>
<dd>Specify desired number of partitions produced during WHOPR compilation.
The number of partitions should exceed the number of CPUs used for compilation.
The default value is 32.</dd>
<dt>lto-minpartition</dt>
<dd>Size of minimal partition for WHOPR (in estimated instructions).
This prevents expenses of splitting very small programs into too many
partitions.</dd>
<dt>cxx-max-namespaces-for-diagnostic-help</dt>
<dd>The maximum number of namespaces to consult for suggestions when C++
name lookup fails for an identifier.  The default is 1000.</dd>
<dt>sink-frequency-threshold</dt>
<dd>The maximum relative execution frequency (in percents) of the target block
relative to a statement&#8217;s original block to allow statement sinking of a
statement.  Larger numbers result in more aggressive statement sinking.
The default value is 75.  A small positive adjustment is applied for
statements with memory operands as those are even more profitable so sink.</dd>
<dt>max-stores-to-sink</dt>
<dd>The maximum number of conditional stores paires that can be sunk.  Set to 0
if either vectorization (<a class="reference internal" href="#cmdoption-ftree-vectorize"><em class="xref std std-option">-ftree-vectorize</em></a>) or if-conversion
(<a class="reference internal" href="#cmdoption-ftree-loop-if-convert"><em class="xref std std-option">-ftree-loop-if-convert</em></a>) is disabled.  The default is 2.</dd>
<dt>allow-store-data-races</dt>
<dd>Allow optimizers to introduce new data races on stores.
Set to 1 to allow, otherwise to 0.  This option is enabled by default
at optimization level <a class="reference internal" href="#cmdoption-Ofast"><em class="xref std std-option">-Ofast</em></a>.</dd>
<dt>case-values-threshold</dt>
<dd>The smallest number of different values for which it is best to use a
jump-table instead of a tree of conditional branches.  If the value is
0, use the default for the machine.  The default is 0.</dd>
<dt>tree-reassoc-width</dt>
<dd>Set the maximum number of instructions executed in parallel in
reassociated tree. This parameter overrides target dependent
heuristics used by default if has non zero value.</dd>
<dt>sched-pressure-algorithm</dt>
<dd><p class="first">Choose between the two available implementations of
<a class="reference internal" href="#cmdoption-fsched-pressure"><em class="xref std std-option">-fsched-pressure</em></a>.  Algorithm 1 is the original implementation
and is the more likely to prevent instructions from being reordered.
Algorithm 2 was designed to be a compromise between the relatively
conservative approach taken by algorithm 1 and the rather aggressive
approach taken by the default scheduler.  It relies more heavily on
having a regular register file and accurate register pressure classes.
See haifa-sched.c in the GCC sources for more details.</p>
<p class="last">The default choice depends on the target.</p>
</dd>
<dt>max-slsr-cand-scan</dt>
<dd>Set the maximum number of existing candidates that are considered when
seeking a basis for a new straight-line strength reduction candidate.</dd>
<dt>asan-globals</dt>
<dd>Enable buffer overflow detection for global objects.  This kind
of protection is enabled by default if you are using
<em class="xref std std-option">-fsanitize=address</em> option.
To disable global objects protection use <em class="xref std std-option">--param asan-globals=0</em>.</dd>
<dt>asan-stack</dt>
<dd>Enable buffer overflow detection for stack objects.  This kind of
protection is enabled by default when using:option:<cite>-fsanitize=address</cite>.
To disable stack protection use <em class="xref std std-option">--param asan-stack=0</em> option.</dd>
<dt>asan-instrument-reads</dt>
<dd>Enable buffer overflow detection for memory reads.  This kind of
protection is enabled by default when using <em class="xref std std-option">-fsanitize=address</em>.
To disable memory reads protection use
<em class="xref std std-option">--param asan-instrument-reads=0</em>.</dd>
<dt>asan-instrument-writes</dt>
<dd>Enable buffer overflow detection for memory writes.  This kind of
protection is enabled by default when using <em class="xref std std-option">-fsanitize=address</em>.
To disable memory writes protection use
<em class="xref std std-option">--param asan-instrument-writes=0</em> option.</dd>
<dt>asan-memintrin</dt>
<dd>Enable detection for built-in functions.  This kind of protection
is enabled by default when using <em class="xref std std-option">-fsanitize=address</em>.
To disable built-in functions protection use
<em class="xref std std-option">--param asan-memintrin=0</em>.</dd>
<dt>asan-use-after-return</dt>
<dd>Enable detection of use-after-return.  This kind of protection
is enabled by default when using <em class="xref std std-option">-fsanitize=address</em> option.
To disable use-after-return detection use
<em class="xref std std-option">--param asan-use-after-return=0</em>.</dd>
<dt>asan-instrumentation-with-call-threshold</dt>
<dd>If number of memory accesses in function being instrumented
is greater or equal to this number, use callbacks instead of inline checks.
E.g. to disable inline code use
<em class="xref std std-option">--param asan-instrumentation-with-call-threshold=0</em>.</dd>
<dt>chkp-max-ctor-size</dt>
<dd>Static constructors generated by Pointer Bounds Checker may become very
large and significantly increase compile time at optimization level
<em class="xref std std-option">-O1</em> and higher.  This parameter is a maximum nubmer of statements
in a single generated constructor.  Default value is 5000.</dd>
<dt>max-fsm-thread-path-insns</dt>
<dd>Maximum number of instructions to copy when duplicating blocks on a
finite state automaton jump thread path.  The default is 100.</dd>
<dt>max-fsm-thread-length</dt>
<dd>Maximum number of basic blocks on a finite state automaton jump thread
path.  The default is 10.</dd>
<dt>max-fsm-thread-paths</dt>
<dd>Maximum number of new jump thread paths to create for a finite state
automaton.  The default is 50.</dd>
</dl>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="options-controlling-the-preprocessor.html" title="Options Controlling the Preprocessor"
             >next</a> |</li>
        <li class="right" >
          <a href="options-for-debugging-your-program-or-gcc.html" title="Options for Debugging Your Program or GCC"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="gcc-command-options.html" >GCC Command Options</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>