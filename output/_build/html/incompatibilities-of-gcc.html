

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Incompatibilities of GCC &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="Known Causes of Trouble with GCC" href="known-causes-of-trouble-with-gcc.html" />
    <link rel="next" title="Fixed Header Files" href="fixed-header-files.html" />
    <link rel="prev" title="Interoperation" href="interoperation.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="fixed-header-files.html" title="Fixed Header Files"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="interoperation.html" title="Interoperation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="known-causes-of-trouble-with-gcc.html" accesskey="U">Known Causes of Trouble with GCC</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="interoperation.html"
                        title="previous chapter">Interoperation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="fixed-header-files.html"
                        title="next chapter">Fixed Header Files</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/incompatibilities-of-gcc.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="incompatibilities-of-gcc">
<h1>Incompatibilities of GCC<a class="headerlink" href="#incompatibilities-of-gcc" title="Permalink to this headline">Â¶</a></h1>
<span class="target" id="index-0"></span><p id="index-1">There are several noteworthy incompatibilities between GNU C and K&amp;R
(non-ISO) versions of C.</p>
<span class="target" id="index-2"></span><span class="target" id="index-3"></span><ul id="index-4">
<li><p class="first">GCC normally makes string constants read-only.  If several
identical-looking string constants are used, GCC stores only one
copy of the string.</p>
<p><tt class="docutils literal"><span class="pre">mktemp</span></tt>, and constant strings
One consequence is that you cannot call <tt class="docutils literal"><span class="pre">mktemp</span></tt> with a string
constant argument.  The function <tt class="docutils literal"><span class="pre">mktemp</span></tt> always alters the
string its argument points to.</p>
<p><tt class="docutils literal"><span class="pre">sscanf</span></tt>, and constant strings
<tt class="docutils literal"><span class="pre">fscanf</span></tt>, and constant strings
<tt class="docutils literal"><span class="pre">scanf</span></tt>, and constant strings
Another consequence is that <tt class="docutils literal"><span class="pre">sscanf</span></tt> does not work on some very
old systems when passed a string constant as its format control string
or input.  This is because <tt class="docutils literal"><span class="pre">sscanf</span></tt> incorrectly tries to write
into the string constant.  Likewise <tt class="docutils literal"><span class="pre">fscanf</span></tt> and <tt class="docutils literal"><span class="pre">scanf</span></tt>.</p>
<p>The solution to these problems is to change the program to use
<tt class="docutils literal"><span class="pre">char</span></tt>-array variables with initialization strings for these
purposes instead of string constants.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-2147483648</span></tt> is positive.</li>
</ul>
<p>This is because 2147483648 cannot fit in the type <tt class="docutils literal"><span class="pre">int</span></tt>, so
(following the ISO C rules) its data type is <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">int</span></tt>.
Negating this value yields 2147483648 again.</p>
<ul class="simple">
<li>GCC does not substitute macro arguments when they appear inside of</li>
</ul>
<p>string constants.  For example, the following macro in GCC</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define foo(a) &quot;a&quot;</span>
</pre></div>
</div>
<p>will produce output <tt class="docutils literal"><span class="pre">&quot;a&quot;</span></tt> regardless of what the argument <tt class="docutils literal"><span class="pre">a</span></tt> is.</p>
<p><tt class="docutils literal"><span class="pre">setjmp</span></tt> incompatibilities
<tt class="docutils literal"><span class="pre">longjmp</span></tt> incompatibilities
* When you use <tt class="docutils literal"><span class="pre">setjmp</span></tt> and <tt class="docutils literal"><span class="pre">longjmp</span></tt>, the only automatic
variables guaranteed to remain valid are those declared
<tt class="docutils literal"><span class="pre">volatile</span></tt>.  This is a consequence of automatic register
allocation.  Consider this function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">jmp_buf</span> <span class="n">j</span><span class="p">;</span>

<span class="n">foo</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">fun1</span> <span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">setjmp</span> <span class="p">(</span><span class="n">j</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">fun2</span> <span class="p">();</span>
  <span class="cm">/* ``longjmp (j)`` may occur in ``fun3``. */</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">fun3</span> <span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">a</span></tt> may or may not be restored to its first value when the
<tt class="docutils literal"><span class="pre">longjmp</span></tt> occurs.  If <tt class="docutils literal"><span class="pre">a</span></tt> is allocated in a register, then
its first value is restored; otherwise, it keeps the last value stored
in it.</p>
<p id="index-5">If you use the <em class="xref std std-option">-W</em> option with the <a class="reference internal" href="options-that-control-optimization.html#cmdoption-O"><em class="xref std std-option">-O</em></a> option, you will
get a warning when GCC thinks such a problem might be possible.</p>
<ul class="simple">
<li>Programs that use preprocessing directives in the middle of macro</li>
</ul>
<p>arguments do not work with GCC.  For example, a program like this
will not work:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">foobar</span> <span class="p">(</span>
<span class="cp">#define luser</span>
        <span class="n">hack</span><span class="p">)</span>
</pre></div>
</div>
<p>ISO C does not permit such a construct.</p>
<ul class="simple">
<li>K&amp;R compilers allow comments to cross over an inclusion boundary</li>
</ul>
<p>(i.e. started in an include file and ended in the including file).</p>
<span class="target" id="index-6"></span><span class="target" id="index-7"></span><ul class="simple" id="index-8">
<li>Declarations of external variables and functions within a block apply</li>
</ul>
<p>only to the block containing the declaration.  In other words, they
have the same scope as any other declaration in the same place.</p>
<p>In some other C compilers, an <tt class="docutils literal"><span class="pre">extern</span></tt> declaration affects all the
rest of the file even if it happens within a block.</p>
<ul class="simple">
<li>In traditional C, you can combine <tt class="docutils literal"><span class="pre">long</span></tt>, etc., with a typedef name,</li>
</ul>
<p>as shown here:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">long</span> <span class="n">foo</span> <span class="n">bar</span><span class="p">;</span>
</pre></div>
</div>
<p>In ISO C, this is not allowed: <tt class="docutils literal"><span class="pre">long</span></tt> and other type modifiers
require an explicit <tt class="docutils literal"><span class="pre">int</span></tt>.</p>
<ul class="simple" id="index-9">
<li>PCC allows typedef names to be used as function parameters.</li>
<li>Traditional C allows the following erroneous pair of declarations to</li>
</ul>
<p>appear together in a given scope:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">foo</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>GCC treats all characters of identifiers as significant.  According to</li>
</ul>
<p>K&amp;R-1 (2.2), &#8216;No more than the first eight characters are significant,
although more may be used.&#8217;.  Also according to K&amp;R-1 (2.2), &#8216;An
identifier is a sequence of letters and digits; the first character must
be a letter.  The underscore _ counts as a letter.&#8217;, but GCC also
allows dollar signs in identifiers.</p>
<ul class="simple" id="index-10">
<li>PCC allows whitespace in the middle of compound assignment operators</li>
</ul>
<p>such as +=.  GCC, following the ISO standard, does not
allow this.</p>
<p id="index-11"><tt class="docutils literal"><span class="pre">'</span></tt>
* GCC complains about unterminated character constants inside of
preprocessing conditionals that fail.  Some programs have English
comments enclosed in conditionals that are guaranteed to fail; if these
comments contain apostrophes, GCC will probably report an error.  For
example, this code would produce an error:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#if 0</span><span class="c"></span>
<span class="c">You can&#39;t expect this to work.</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>The best solution to such a problem is to put the text into an actual
C comment delimited by /<em>...</em>/.</p>
<ul class="simple">
<li>Many user programs contain the declaration long time ();.  In the</li>
</ul>
<p>past, the system header files on many systems did not actually declare
<tt class="docutils literal"><span class="pre">time</span></tt>, so it did not matter what type your program declared it to
return.  But in systems with ISO C headers, <tt class="docutils literal"><span class="pre">time</span></tt> is declared to
return <tt class="docutils literal"><span class="pre">time_t</span></tt>, and if that is not the same as <tt class="docutils literal"><span class="pre">long</span></tt>, then
long time (); is erroneous.</p>
<p>The solution is to change your program to use appropriate system headers
(<tt class="docutils literal"><span class="pre">&lt;time.h&gt;</span></tt> on systems with ISO C headers) and not to declare
<tt class="docutils literal"><span class="pre">time</span></tt> if the system header files declare it, or failing that to
use <tt class="docutils literal"><span class="pre">time_t</span></tt> as the return type of <tt class="docutils literal"><span class="pre">time</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">float</span></tt> as function value type
* When compiling functions that return <tt class="docutils literal"><span class="pre">float</span></tt>, PCC converts it to
a double.  GCC actually returns a <tt class="docutils literal"><span class="pre">float</span></tt>.  If you are concerned
with PCC compatibility, you should declare your functions to return
<tt class="docutils literal"><span class="pre">double</span></tt>; you might as well say what you mean.</p>
<span class="target" id="index-12"></span><ul class="simple" id="index-13">
<li>When compiling functions that return structures or unions, GCC</li>
</ul>
<p>output code normally uses a method different from that used on most
versions of Unix.  As a result, code compiled with GCC cannot call
a structure-returning function compiled with PCC, and vice versa.</p>
<p>The method used by GCC is as follows: a structure or union which is
1, 2, 4 or 8 bytes long is returned like a scalar.  A structure or union
with any other size is stored into an address supplied by the caller
(usually in a special, fixed register, but on some machines it is passed
on the stack).  The target hook <tt class="docutils literal"><span class="pre">TARGET_STRUCT_VALUE_RTX</span></tt>
tells GCC where to pass this address.</p>
<p>By contrast, PCC on most target machines returns structures and unions
of any size by copying the data into an area of static storage, and then
returning the address of that storage as if it were a pointer value.
The caller must copy the data from that memory area to the place where
the value is wanted.  GCC does not use this method because it is
slower and nonreentrant.</p>
<p>On some newer machines, PCC uses a reentrant convention for all
structure and union returning.  GCC on most of these machines uses a
compatible convention when returning structures and unions in memory,
but still returns small structures and unions in registers.</p>
<p id="index-14">You can tell GCC to use a compatible convention for all structure and
union returning with the option <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fpcc-struct-return"><em class="xref std std-option">-fpcc-struct-return</em></a>.</p>
<span class="target" id="index-15"></span><ul class="simple" id="index-16">
<li>GCC complains about program fragments such as 0x74ae-0x4000</li>
</ul>
<p>which appear to be two hexadecimal constants separated by the minus
operator.  Actually, this string is a single <em class="dfn">preprocessing token</em>.
Each such token must correspond to one token in C.  Since this does not,
GCC prints an error message.  Although it may appear obvious that what
is meant is an operator and two values, the ISO C standard specifically
requires that this be treated as erroneous.</p>
<p>A <em class="dfn">preprocessing token</em> is a <em class="dfn">preprocessing number</em> if it
begins with a digit and is followed by letters, underscores, digits,
periods and e+, e-, E+, E-, p+,
p-, P+, or P- character sequences.  (In strict C90
mode, the sequences p+, p-, P+ and P- cannot
appear in preprocessing numbers.)</p>
<p>To make the above program fragment valid, place whitespace in front of
the minus sign.  This whitespace will end the preprocessing number.</p>
</li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="fixed-header-files.html" title="Fixed Header Files"
             >next</a> |</li>
        <li class="right" >
          <a href="interoperation.html" title="Interoperation"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="known-causes-of-trouble-with-gcc.html" >Known Causes of Trouble with GCC</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>