

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Specifying Attributes of Variables &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="Extensions to the C Language Family" href="extensions-to-the-c-language-family.html" />
    <link rel="next" title="Specifying Attributes of Types" href="specifying-attributes-of-types.html" />
    <link rel="prev" title="Declaring Attributes of Functions" href="declaring-attributes-of-functions.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="specifying-attributes-of-types.html" title="Specifying Attributes of Types"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="declaring-attributes-of-functions.html" title="Declaring Attributes of Functions"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" accesskey="U">Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Specifying Attributes of Variables</a><ul>
<li><a class="reference internal" href="#common-variable-attributes">Common Variable Attributes</a></li>
<li><a class="reference internal" href="#avr-variable-attributes">AVR Variable Attributes</a></li>
<li><a class="reference internal" href="#blackfin-variable-attributes">Blackfin Variable Attributes</a></li>
<li><a class="reference internal" href="#h8-300-variable-attributes">H8/300 Variable Attributes</a></li>
<li><a class="reference internal" href="#ia-64-variable-attributes">IA-64 Variable Attributes</a></li>
<li><a class="reference internal" href="#m32r-d-variable-attributes">M32R/D Variable Attributes</a></li>
<li><a class="reference internal" href="#mep-variable-attributes">MeP Variable Attributes</a></li>
<li><a class="reference internal" href="#microsoft-windows-variable-attributes">Microsoft Windows Variable Attributes</a></li>
<li><a class="reference internal" href="#powerpc-variable-attributes">PowerPC Variable Attributes</a></li>
<li><a class="reference internal" href="#spu-variable-attributes">SPU Variable Attributes</a></li>
<li><a class="reference internal" href="#x86-variable-attributes">x86 Variable Attributes</a></li>
<li><a class="reference internal" href="#xstormy16-variable-attributes">Xstormy16 Variable Attributes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="declaring-attributes-of-functions.html"
                        title="previous chapter">Declaring Attributes of Functions</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="specifying-attributes-of-types.html"
                        title="next chapter">Specifying Attributes of Types</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/specifying-attributes-of-variables.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <blockquote>
<div></div></blockquote>
<div class="section" id="specifying-attributes-of-variables">
<span id="variable-attributes"></span><h1>Specifying Attributes of Variables<a class="headerlink" href="#specifying-attributes-of-variables" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><p id="index-1">The keyword <tt class="docutils literal"><span class="pre">__attribute__</span></tt> allows you to specify special
attributes of variables or structure fields.  This keyword is followed
by an attribute specification inside double parentheses.  Some
attributes are currently defined generically for variables.
Other attributes are defined for variables on particular target
systems.  Other attributes are available for functions
(see <a class="reference internal" href="declaring-attributes-of-functions.html#function-attributes"><em>Declaring Attributes of Functions</em></a>), labels (see <a class="reference internal" href="label-attributes.html#label-attributes"><em>Label Attributes</em></a>) and for
types (see <a class="reference internal" href="specifying-attributes-of-types.html#type-attributes"><em>Specifying Attributes of Types</em></a>).
Other front ends might define more attributes
(see <a class="reference internal" href="extensions-to-the-c++-language.html#c-extensions"><em>Extensions to the C++ Language</em></a>).</p>
<p>See <a class="reference internal" href="attribute-syntax.html#attribute-syntax"><em>Attribute Syntax</em></a>, for details of the exact syntax for using
attributes.</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="common-variable-attributes">
<span id="id1"></span><h2>Common Variable Attributes<a class="headerlink" href="#common-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p>The following attributes are supported on most targets.</p>
<dl class="docutils" id="index-2">
<dt><tt class="samp docutils literal"><span class="pre">aligned</span> <span class="pre">(</span><em><span class="pre">alignment</span></em><span class="pre">)</span></tt></dt>
<dd><p class="first">This attribute specifies a minimum alignment for the variable or
structure field, measured in bytes.  For example, the declaration:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">16</span><span class="p">)))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>causes the compiler to allocate the global variable <tt class="docutils literal"><span class="pre">x</span></tt> on a
16-byte boundary.  On a 68040, this could be used in conjunction with
an <tt class="docutils literal"><span class="pre">asm</span></tt> expression to access the <tt class="docutils literal"><span class="pre">move16</span></tt> instruction which
requires 16-byte aligned operands.</p>
<p>You can also specify the alignment of structure fields.  For example, to
create a double-word aligned <tt class="docutils literal"><span class="pre">int</span></tt> pair, you could write:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">8</span><span class="p">)));</span> <span class="p">};</span>
</pre></div>
</div>
<p>This is an alternative to creating a union with a <tt class="docutils literal"><span class="pre">double</span></tt> member,
which forces the union to be double-word aligned.</p>
<p>As in the preceding examples, you can explicitly specify the alignment
(in bytes) that you wish the compiler to use for a given variable or
structure field.  Alternatively, you can leave out the alignment factor
and just ask the compiler to align a variable or field to the
default alignment for the target architecture you are compiling for.
The default alignment is sufficient for all scalar types, but may not be
enough for all vector types on a target that supports vector operations.
The default alignment is fixed for a particular target ABI.</p>
<p>GCC also provides a target specific macro <tt class="docutils literal"><span class="pre">__BIGGEST_ALIGNMENT__</span></tt>,
which is the largest alignment ever used for any data type on the
target machine you are compiling for.  For example, you could write:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">short</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="n">__BIGGEST_ALIGNMENT__</span><span class="p">)));</span>
</pre></div>
</div>
<p>The compiler automatically sets the alignment for the declared
variable or field to <tt class="docutils literal"><span class="pre">__BIGGEST_ALIGNMENT__</span></tt>.  Doing this can
often make copy operations more efficient, because the compiler can
use whatever instructions copy the biggest chunks of memory when
performing copies to or from the variables or fields that you have
aligned this way.  Note that the value of <tt class="docutils literal"><span class="pre">__BIGGEST_ALIGNMENT__</span></tt>
may change depending on command-line options.</p>
<p>When used on a struct, or struct member, the <tt class="docutils literal"><span class="pre">aligned</span></tt> attribute can
only increase the alignment; in order to decrease it, the <tt class="docutils literal"><span class="pre">packed</span></tt>
attribute must be specified as well.  When used as part of a typedef, the
<tt class="docutils literal"><span class="pre">aligned</span></tt> attribute can both increase and decrease alignment, and
specifying the <tt class="docutils literal"><span class="pre">packed</span></tt> attribute generates a warning.</p>
<p>Note that the effectiveness of <tt class="docutils literal"><span class="pre">aligned</span></tt> attributes may be limited
by inherent limitations in your linker.  On many systems, the linker is
only able to arrange for variables to be aligned up to a certain maximum
alignment.  (For some linkers, the maximum supported alignment may
be very very small.)  If your linker is only able to align variables
up to a maximum of 8-byte alignment, then specifying <tt class="docutils literal"><span class="pre">aligned(16)</span></tt>
in an <tt class="docutils literal"><span class="pre">__attribute__</span></tt> still only provides you with 8-byte
alignment.  See your linker documentation for further information.</p>
<p class="last">The <tt class="docutils literal"><span class="pre">aligned</span></tt> attribute can also be used for functions
(see <a class="reference internal" href="declaring-attributes-of-functions.html#common-function-attributes"><em>Common Function Attributes</em></a>.)</p>
</dd>
</dl>
<p><tt class="samp docutils literal"><span class="pre">cleanup</span> <span class="pre">(</span><em><span class="pre">cleanup_function</span></em><span class="pre">)</span></tt></p>
<blockquote>
<div><p id="index-3">The <tt class="docutils literal"><span class="pre">cleanup</span></tt> attribute runs a function when the variable goes
out of scope.  This attribute can only be applied to auto function
scope variables; it may not be applied to parameters or variables
with static storage duration.  The function must take one parameter,
a pointer to a type compatible with the variable.  The return value
of the function (if any) is ignored.</p>
<p>If <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fexceptions"><em class="xref std std-option">-fexceptions</em></a> is enabled, then <tt class="docutils literal"><span class="pre">cleanup_function</span></tt>
is run during the stack unwinding that happens during the
processing of the exception.  Note that the <tt class="docutils literal"><span class="pre">cleanup</span></tt> attribute
does not allow the exception to be caught, only to perform an action.
It is undefined what happens if <tt class="docutils literal"><span class="pre">cleanup_function</span></tt> does not
return normally.</p>
</div></blockquote>
<dl class="option">
<dt id="cmdoption-fcommon">
<tt class="descname">-fcommon</tt><tt class="descclassname"></tt><tt class="descclassname">, </tt><tt class="descname">-fno-common</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-fcommon" title="Permalink to this definition">¶</a></dt>
<dd><span class="target" id="index-4"></span><p id="index-5">The <tt class="docutils literal"><span class="pre">common</span></tt> attribute requests GCC to place a variable in
&#8216;common&#8217; storage.  The <tt class="docutils literal"><span class="pre">nocommon</span></tt> attribute requests the
opposite-to allocate space for it directly.</p>
<p>These attributes override the default chosen by the
<a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fno-common"><em class="xref std std-option">-fno-common</em></a> and <a class="reference internal" href="#cmdoption-fcommon"><em class="xref std std-option">-fcommon</em></a> flags respectively.</p>
</dd></dl>

<p><tt class="docutils literal"><span class="pre">deprecated</span></tt> <tt class="samp docutils literal"><span class="pre">deprecated</span> <span class="pre">(</span><em><span class="pre">msg</span></em><span class="pre">)</span></tt></p>
<blockquote>
<div><p id="index-6">The <tt class="docutils literal"><span class="pre">deprecated</span></tt> attribute results in a warning if the variable
is used anywhere in the source file.  This is useful when identifying
variables that are expected to be removed in a future version of a
program.  The warning also includes the location of the declaration
of the deprecated variable, to enable users to easily find further
information about why the variable is deprecated, or what they should
do instead.  Note that the warning only occurs for uses:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="n">old_var</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">deprecated</span><span class="p">));</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">old_var</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">new_fn</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">old_var</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>results in a warning on line 3 but not line 2.  The optional <tt class="docutils literal"><span class="pre">msg</span></tt>
argument, which must be a string, is printed in the warning if
present.</p>
<p>The <tt class="docutils literal"><span class="pre">deprecated</span></tt> attribute can also be used for functions and
types (see <a class="reference internal" href="declaring-attributes-of-functions.html#common-function-attributes"><em>Common Function Attributes</em></a>,
see <a class="reference internal" href="specifying-attributes-of-types.html#common-type-attributes"><em>Common Type Attributes</em></a>).</p>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">mode</span> <span class="pre">(</span><em><span class="pre">mode</span></em><span class="pre">)</span></tt></p>
<blockquote>
<div><p id="index-7">This attribute specifies the data type for the declaration-whichever
type corresponds to the mode <tt class="docutils literal"><span class="pre">mode</span></tt>.  This in effect lets you
request an integer or floating-point type according to its width.</p>
<p>You may also specify a mode of <tt class="docutils literal"><span class="pre">byte</span></tt> or <tt class="docutils literal"><span class="pre">__byte__</span></tt> to
indicate the mode corresponding to a one-byte integer, <tt class="docutils literal"><span class="pre">word</span></tt> or
<tt class="docutils literal"><span class="pre">__word__</span></tt> for the mode of a one-word integer, and <tt class="docutils literal"><span class="pre">pointer</span></tt>
or <tt class="docutils literal"><span class="pre">__pointer__</span></tt> for the mode used to represent pointers.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">packed</span></tt></p>
<blockquote>
<div><p id="index-8">The <tt class="docutils literal"><span class="pre">packed</span></tt> attribute specifies that a variable or structure field
should have the smallest possible alignment-one byte for a variable,
and one bit for a field, unless you specify a larger value with the
<tt class="docutils literal"><span class="pre">aligned</span></tt> attribute.</p>
<p>Here is a structure in which the field <tt class="docutils literal"><span class="pre">x</span></tt> is packed, so that it
immediately follows <tt class="docutils literal"><span class="pre">a</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">foo</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Note:</em> The 4.1, 4.2 and 4.3 series of GCC ignore the
<tt class="docutils literal"><span class="pre">packed</span></tt> attribute on bit-fields of type <tt class="docutils literal"><span class="pre">char</span></tt>.  This has
been fixed in GCC 4.4 but the change can lead to differences in the
structure layout.  See the documentation of
<a class="reference internal" href="options-to-request-or-suppress-warnings.html#cmdoption-Wpacked-bitfield-compat"><em class="xref std std-option">-Wpacked-bitfield-compat</em></a> for more information.</p>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">section</span> <span class="pre">(&quot;</span><em><span class="pre">section-name</span></em><span class="pre">&quot;)</span></tt></p>
<blockquote>
<div><p id="index-9">Normally, the compiler places the objects it generates in sections like
<tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">bss</span></tt>.  Sometimes, however, you need additional sections,
or you need certain particular variables to appear in special sections,
for example to map to special hardware.  The <tt class="docutils literal"><span class="pre">section</span></tt>
attribute specifies that a variable (or function) lives in a particular
section.  For example, this small program uses several specific section names:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">duart</span> <span class="n">a</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">section</span> <span class="p">(</span><span class="s">&quot;DUART_A&quot;</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">duart</span> <span class="n">b</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">section</span> <span class="p">(</span><span class="s">&quot;DUART_B&quot;</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kt">char</span> <span class="n">stack</span><span class="p">[</span><span class="mi">10000</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">section</span> <span class="p">(</span><span class="s">&quot;STACK&quot;</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">init_data</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">section</span> <span class="p">(</span><span class="s">&quot;INITDATA&quot;</span><span class="p">)));</span>

<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="cm">/* Initialize stack pointer */</span>
  <span class="n">init_sp</span> <span class="p">(</span><span class="n">stack</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">stack</span><span class="p">));</span>

  <span class="cm">/* Initialize initialized data */</span>
  <span class="n">memcpy</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">init_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edata</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>

  <span class="cm">/* Turn on the serial ports */</span>
  <span class="n">init_duart</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
  <span class="n">init_duart</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Use the <tt class="docutils literal"><span class="pre">section</span></tt> attribute with
<em>global</em> variables and not <em>local</em> variables,
as shown in the example.</p>
<p>You may use the <tt class="docutils literal"><span class="pre">section</span></tt> attribute with initialized or
uninitialized global variables but the linker requires
each object be defined once, with the exception that uninitialized
variables tentatively go in the <tt class="docutils literal"><span class="pre">common</span></tt> (or <tt class="docutils literal"><span class="pre">bss</span></tt>) section
and can be multiply &#8216;defined&#8217;.  Using the <tt class="docutils literal"><span class="pre">section</span></tt> attribute
changes what section the variable goes into and may cause the
linker to issue an error if an uninitialized variable has multiple
definitions.  You can force a variable to be initialized with the
<a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fno-common"><em class="xref std std-option">-fno-common</em></a> flag or the <tt class="docutils literal"><span class="pre">nocommon</span></tt> attribute.</p>
<p>Some file formats do not support arbitrary sections so the <tt class="docutils literal"><span class="pre">section</span></tt>
attribute is not available on all platforms.
If you need to map the entire contents of a module to a particular
section, consider using the facilities of the linker instead.</p>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">tls_model</span> <span class="pre">(&quot;</span><em><span class="pre">tls_model</span></em><span class="pre">&quot;)</span></tt></p>
<blockquote>
<div><p id="index-10">The <tt class="docutils literal"><span class="pre">tls_model</span></tt> attribute sets thread-local storage model
(see <a class="reference internal" href="thread-local-storage.html#thread-local"><em>Thread-Local Storage</em></a>) of a particular <tt class="docutils literal"><span class="pre">__thread</span></tt> variable,
overriding <em class="xref std std-option">-ftls-model=</em> command-line switch on a per-variable
basis.
The <tt class="docutils literal"><span class="pre">tls_model</span></tt> argument should be one of <tt class="docutils literal"><span class="pre">global-dynamic</span></tt>,
<tt class="docutils literal"><span class="pre">local-dynamic</span></tt>, <tt class="docutils literal"><span class="pre">initial-exec</span></tt> or <tt class="docutils literal"><span class="pre">local-exec</span></tt>.</p>
<p>Not all targets support this attribute.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">unused</span></tt></p>
<blockquote>
<div><p id="index-11">This attribute, attached to a variable, means that the variable is meant
to be possibly unused.  GCC does not produce a warning for this
variable.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">used</span></tt></p>
<blockquote>
<div><p id="index-12">This attribute, attached to a variable with static storage, means that
the variable must be emitted even if it appears that the variable is not
referenced.</p>
<p>When applied to a static data member of a C++ class template, the
attribute also means that the member is instantiated if the
class itself is instantiated.</p>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">vector_size</span> <span class="pre">(</span><em><span class="pre">bytes</span></em><span class="pre">)</span></tt></p>
<blockquote>
<div><p id="index-13">This attribute specifies the vector size for the variable, measured in
bytes.  For example, the declaration:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">foo</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">vector_size</span> <span class="p">(</span><span class="mi">16</span><span class="p">)));</span>
</pre></div>
</div>
<p>causes the compiler to set the mode for <tt class="docutils literal"><span class="pre">foo</span></tt>, to be 16 bytes,
divided into <tt class="docutils literal"><span class="pre">int</span></tt> sized units.  Assuming a 32-bit int (a vector of
4 units of 4 bytes), the corresponding mode of <tt class="docutils literal"><span class="pre">foo</span></tt> is V4SI.</p>
<p>This attribute is only applicable to integral and float scalars,
although arrays, pointers, and function return values are allowed in
conjunction with this construct.</p>
<p>Aggregates with this attribute are invalid, even if they are of the same
size as a corresponding scalar.  For example, the declaration:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">S</span>  <span class="n">__attribute__</span> <span class="p">((</span><span class="n">vector_size</span> <span class="p">(</span><span class="mi">16</span><span class="p">)))</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
<p>is invalid even if the size of the structure is the same as the size of
the <tt class="docutils literal"><span class="pre">int</span></tt>.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">weak</span></tt></p>
<blockquote>
<div><p id="index-14">The <tt class="docutils literal"><span class="pre">weak</span></tt> attribute is described in
Common Function Attributes.</p>
</div></blockquote>
</div>
<div class="section" id="avr-variable-attributes">
<span id="id2"></span><h2>AVR Variable Attributes<a class="headerlink" href="#avr-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">progmem</span></tt></p>
<blockquote>
<div><p id="index-15">The <tt class="docutils literal"><span class="pre">progmem</span></tt> attribute is used on the AVR to place read-only
data in the non-volatile program memory (flash). The <tt class="docutils literal"><span class="pre">progmem</span></tt>
attribute accomplishes this by putting respective variables into a
section whose name starts with <tt class="docutils literal"><span class="pre">.progmem</span></tt>.</p>
<p>This attribute works similar to the <tt class="docutils literal"><span class="pre">section</span></tt> attribute
but adds additional checking. Notice that just like the
<tt class="docutils literal"><span class="pre">section</span></tt> attribute, <tt class="docutils literal"><span class="pre">progmem</span></tt> affects the location
of the data but not how this data is accessed.</p>
<p>In order to read data located with the <tt class="docutils literal"><span class="pre">progmem</span></tt> attribute
(inline) assembler must be used.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/* Use custom macros from http://nongnu.org/avr-libc/user-manual/AVR-LibC */</span>
<span class="cp">#include &lt;avr/pgmspace.h&gt;</span>

<span class="cm">/* Locate var in flash memory */</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">var</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">PROGMEM</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">read_var</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Access var[] by accessor macro from avr/pgmspace.h */</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">pgm_read_word</span> <span class="p">(</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>AVR is a Harvard architecture processor and data and read-only data
normally resides in the data memory (RAM).</p>
<p>See also the AVR Named Address Spaces section for
an alternate way to locate and access data in flash memory.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">io</span></tt> <tt class="samp docutils literal"><span class="pre">io</span> <span class="pre">(</span><em><span class="pre">addr</span></em><span class="pre">)</span></tt></p>
<blockquote>
<div><p id="index-16">Variables with the <tt class="docutils literal"><span class="pre">io</span></tt> attribute are used to address
memory-mapped peripherals in the io address range.
If an address is specified, the variable
is assigned that address, and the value is interpreted as an
address in the data address space.
Example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">volatile</span> <span class="kt">int</span> <span class="n">porta</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">io</span> <span class="p">(</span><span class="mh">0x22</span><span class="p">)));</span>
</pre></div>
</div>
<p>The address specified in the address in the data address range.</p>
<p>Otherwise, the variable it is not assigned an address, but the
compiler will still use in/out instructions where applicable,
assuming some other module assigns an address in the io address range.
Example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">porta</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">io</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">io_low</span></tt> <tt class="samp docutils literal"><span class="pre">io_low</span> <span class="pre">(</span><em><span class="pre">addr</span></em><span class="pre">)</span></tt></p>
<blockquote>
<div><p id="index-17">This is like the <tt class="docutils literal"><span class="pre">io</span></tt> attribute, but additionally it informs the
compiler that the object lies in the lower half of the I/O area,
allowing the use of <tt class="docutils literal"><span class="pre">cbi</span></tt>, <tt class="docutils literal"><span class="pre">sbi</span></tt>, <tt class="docutils literal"><span class="pre">sbic</span></tt> and <tt class="docutils literal"><span class="pre">sbis</span></tt>
instructions.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">address</span></tt> <tt class="samp docutils literal"><span class="pre">address</span> <span class="pre">(</span><em><span class="pre">addr</span></em><span class="pre">)</span></tt></p>
<blockquote>
<div><p id="index-18">Variables with the <tt class="docutils literal"><span class="pre">address</span></tt> attribute are used to address
memory-mapped peripherals that may lie outside the io address range.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">volatile</span> <span class="kt">int</span> <span class="n">porta</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">address</span> <span class="p">(</span><span class="mh">0x600</span><span class="p">)));</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="blackfin-variable-attributes">
<span id="id3"></span><h2>Blackfin Variable Attributes<a class="headerlink" href="#blackfin-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p>Three attributes are currently defined for the Blackfin.</p>
<p><tt class="docutils literal"><span class="pre">l1_data</span></tt> <tt class="docutils literal"><span class="pre">l1_data_A</span></tt> <tt class="docutils literal"><span class="pre">l1_data_B</span></tt></p>
<blockquote>
<div><span class="target" id="index-19"></span><span class="target" id="index-20"></span><p id="index-21">Use these attributes on the Blackfin to place the variable into L1 Data SRAM.
Variables with <tt class="docutils literal"><span class="pre">l1_data</span></tt> attribute are put into the specific section
named <tt class="docutils literal"><span class="pre">.l1.data</span></tt>. Those with <tt class="docutils literal"><span class="pre">l1_data_A</span></tt> attribute are put into
the specific section named <tt class="docutils literal"><span class="pre">.l1.data.A</span></tt>. Those with <tt class="docutils literal"><span class="pre">l1_data_B</span></tt>
attribute are put into the specific section named <tt class="docutils literal"><span class="pre">.l1.data.B</span></tt>.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">l2</span></tt></p>
<blockquote>
<div><p id="index-22">Use this attribute on the Blackfin to place the variable into L2 SRAM.
Variables with <tt class="docutils literal"><span class="pre">l2</span></tt> attribute are put into the specific section
named <tt class="docutils literal"><span class="pre">.l2.data</span></tt>.</p>
</div></blockquote>
</div>
<div class="section" id="h8-300-variable-attributes">
<span id="id4"></span><h2>H8/300 Variable Attributes<a class="headerlink" href="#h8-300-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p>These variable attributes are available for H8/300 targets:</p>
<p><tt class="docutils literal"><span class="pre">eightbit_data</span></tt></p>
<blockquote>
<div><span class="target" id="index-23"></span><p id="index-24">Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified
variable should be placed into the eight-bit data section.
The compiler generates more efficient code for certain operations
on data in the eight-bit data area.  Note the eight-bit data area is limited to
256 bytes of data.</p>
<p>You must use GAS and GLD from GNU binutils version 2.7 or later for
this attribute to work correctly.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">tiny_data</span></tt></p>
<blockquote>
<div><span class="target" id="index-25"></span><p id="index-26">Use this attribute on the H8/300H and H8S to indicate that the specified
variable should be placed into the tiny data section.
The compiler generates more efficient code for loads and stores
on data in the tiny data section.  Note the tiny data area is limited to
slightly under 32KB of data.</p>
</div></blockquote>
</div>
<div class="section" id="ia-64-variable-attributes">
<span id="id5"></span><h2>IA-64 Variable Attributes<a class="headerlink" href="#ia-64-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p>The IA-64 back end supports the following variable attribute:</p>
<p><tt class="samp docutils literal"><span class="pre">model</span> <span class="pre">(</span><em><span class="pre">model-name</span></em><span class="pre">)</span></tt></p>
<blockquote>
<div><p id="index-27">On IA-64, use this attribute to set the addressability of an object.
At present, the only supported identifier for <tt class="docutils literal"><span class="pre">model-name</span></tt> is
<tt class="docutils literal"><span class="pre">small</span></tt>, indicating addressability via &#8216;small&#8217; (22-bit)
addresses (so that their addresses can be loaded with the <tt class="docutils literal"><span class="pre">addl</span></tt>
instruction).  Caveat: such addressing is by definition not position
independent and hence this attribute must not be used for objects
defined by shared libraries.</p>
</div></blockquote>
</div>
<div class="section" id="m32r-d-variable-attributes">
<span id="id6"></span><h2>M32R/D Variable Attributes<a class="headerlink" href="#m32r-d-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p>One attribute is currently defined for the M32R/D.</p>
<p><tt class="samp docutils literal"><span class="pre">model</span> <span class="pre">(</span><em><span class="pre">model-name</span></em><span class="pre">)</span></tt></p>
<blockquote>
<div><span class="target" id="index-28"></span><p id="index-29">Use this attribute on the M32R/D to set the addressability of an object.
The identifier <tt class="docutils literal"><span class="pre">model-name</span></tt> is one of <tt class="docutils literal"><span class="pre">small</span></tt>, <tt class="docutils literal"><span class="pre">medium</span></tt>,
or <tt class="docutils literal"><span class="pre">large</span></tt>, representing each of the code models.</p>
<p>Small model objects live in the lower 16MB of memory (so that their
addresses can be loaded with the <tt class="docutils literal"><span class="pre">ld24</span></tt> instruction).</p>
<p>Medium and large model objects may live anywhere in the 32-bit address space
(the compiler generates <tt class="docutils literal"><span class="pre">seth/add3</span></tt> instructions to load their
addresses).</p>
</div></blockquote>
</div>
<div class="section" id="mep-variable-attributes">
<span id="id7"></span><h2>MeP Variable Attributes<a class="headerlink" href="#mep-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p>The MeP target has a number of addressing modes and busses.  The
<tt class="docutils literal"><span class="pre">near</span></tt> space spans the standard memory space&#8217;s first 16 megabytes
(24 bits).  The <tt class="docutils literal"><span class="pre">far</span></tt> space spans the entire 32-bit memory space.
The <tt class="docutils literal"><span class="pre">based</span></tt> space is a 128-byte region in the memory space that
is addressed relative to the <tt class="docutils literal"><span class="pre">$tp</span></tt> register.  The <tt class="docutils literal"><span class="pre">tiny</span></tt>
space is a 65536-byte region relative to the <tt class="docutils literal"><span class="pre">$gp</span></tt> register.  In
addition to these memory regions, the MeP target has a separate 16-bit
control bus which is specified with <tt class="docutils literal"><span class="pre">cb</span></tt> attributes.</p>
<p><tt class="docutils literal"><span class="pre">based</span></tt></p>
<blockquote>
<div><p id="index-30">Any variable with the <tt class="docutils literal"><span class="pre">based</span></tt> attribute is assigned to the
<tt class="docutils literal"><span class="pre">.based</span></tt> section, and is accessed with relative to the
<tt class="docutils literal"><span class="pre">$tp</span></tt> register.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">tiny</span></tt></p>
<blockquote>
<div><p id="index-31">Likewise, the <tt class="docutils literal"><span class="pre">tiny</span></tt> attribute assigned variables to the
<tt class="docutils literal"><span class="pre">.tiny</span></tt> section, relative to the <tt class="docutils literal"><span class="pre">$gp</span></tt> register.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">near</span></tt></p>
<blockquote>
<div><p id="index-32">Variables with the <tt class="docutils literal"><span class="pre">near</span></tt> attribute are assumed to have addresses
that fit in a 24-bit addressing mode.  This is the default for large
variables (<tt class="docutils literal"><span class="pre">-mtiny=4</span></tt> is the default) but this attribute can
override <tt class="docutils literal"><span class="pre">-mtiny=</span></tt> for small variables, or override <tt class="docutils literal"><span class="pre">-ml</span></tt>.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">far</span></tt></p>
<blockquote>
<div><p id="index-33">Variables with the <tt class="docutils literal"><span class="pre">far</span></tt> attribute are addressed using a full
32-bit address.  Since this covers the entire memory space, this
allows modules to make no assumptions about where variables might be
stored.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">io</span></tt>
.. index:: io variable attribute, MeP</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="samp docutils literal"><span class="pre">io</span> <span class="pre">(</span><em><span class="pre">addr</span></em><span class="pre">)</span></tt></dt>
<dd><p class="first">Variables with the <tt class="docutils literal"><span class="pre">io</span></tt> attribute are used to address
memory-mapped peripherals.  If an address is specified, the variable
is assigned that address, else it is not assigned an address (it is
assumed some other module assigns an address).  Example:</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">timer_count</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">io</span><span class="p">(</span><span class="mh">0x123</span><span class="p">)));</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">cb</span></tt> <tt class="samp docutils literal"><span class="pre">cb</span> <span class="pre">(</span><em><span class="pre">addr</span></em><span class="pre">)</span></tt></p>
<blockquote>
<div><p id="index-34">Variables with the <tt class="docutils literal"><span class="pre">cb</span></tt> attribute are used to access the control
bus, using special instructions.  <tt class="docutils literal"><span class="pre">addr</span></tt> indicates the control bus
address.  Example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">cpu_clock</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">cb</span><span class="p">(</span><span class="mh">0x123</span><span class="p">)));</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="microsoft-windows-variable-attributes">
<span id="id8"></span><h2>Microsoft Windows Variable Attributes<a class="headerlink" href="#microsoft-windows-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p>You can use these attributes on Microsoft Windows targets.
x86 Variable Attributes for additional Windows compatibility
attributes available on all x86 targets.</p>
<p><tt class="docutils literal"><span class="pre">dllimport</span></tt> <tt class="docutils literal"><span class="pre">dllexport</span></tt></p>
<blockquote>
<div><span class="target" id="index-35"></span><p id="index-36">The <tt class="docutils literal"><span class="pre">dllimport</span></tt> and <tt class="docutils literal"><span class="pre">dllexport</span></tt> attributes are described in
Microsoft Windows Function Attributes.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">selectany</span></tt></p>
<blockquote>
<div><p id="index-37">The <tt class="docutils literal"><span class="pre">selectany</span></tt> attribute causes an initialized global variable to
have link-once semantics.  When multiple definitions of the variable are
encountered by the linker, the first is selected and the remainder are
discarded.  Following usage by the Microsoft compiler, the linker is told
<em>not</em> to warn about size or content differences of the multiple
definitions.</p>
<p>Although the primary usage of this attribute is for POD types, the
attribute can also be applied to global C++ objects that are initialized
by a constructor.  In this case, the static initialization and destruction
code for the object is emitted in each translation defining the object,
but the calls to the constructor and destructor are protected by a
link-once guard variable.</p>
<p>The <tt class="docutils literal"><span class="pre">selectany</span></tt> attribute is only available on Microsoft Windows
targets.  You can use <tt class="docutils literal"><span class="pre">__declspec</span> <span class="pre">(selectany)</span></tt> as a synonym for
<tt class="docutils literal"><span class="pre">__attribute__</span> <span class="pre">((selectany))</span></tt> for compatibility with other
compilers.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">shared</span></tt></p>
<blockquote>
<div><p id="index-38">On Microsoft Windows, in addition to putting variable definitions in a named
section, the section can also be shared among all running copies of an
executable or DLL.  For example, this small program defines shared data
by putting it in a named section <tt class="docutils literal"><span class="pre">shared</span></tt> and marking the section
shareable:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">foo</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">section</span> <span class="p">(</span><span class="s">&quot;shared&quot;</span><span class="p">),</span> <span class="n">shared</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="cm">/* Read and write foo.  All running</span>
<span class="cm">     copies see the same value.  */</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may only use the <tt class="docutils literal"><span class="pre">shared</span></tt> attribute along with <tt class="docutils literal"><span class="pre">section</span></tt>
attribute with a fully-initialized global definition because of the way
linkers work.  See <tt class="docutils literal"><span class="pre">section</span></tt> attribute for more information.</p>
<p>The <tt class="docutils literal"><span class="pre">shared</span></tt> attribute is only available on Microsoft Windows.</p>
</div></blockquote>
</div>
<div class="section" id="powerpc-variable-attributes">
<span id="id9"></span><h2>PowerPC Variable Attributes<a class="headerlink" href="#powerpc-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p>Three attributes currently are defined for PowerPC configurations:
<tt class="docutils literal"><span class="pre">altivec</span></tt>, <tt class="docutils literal"><span class="pre">ms_struct</span></tt> and <tt class="docutils literal"><span class="pre">gcc_struct</span></tt>.</p>
<span class="target" id="index-39"></span><p id="index-40">For full documentation of the struct attributes please see the
documentation in x86 Variable Attributes.</p>
<p id="index-41">For documentation of <tt class="docutils literal"><span class="pre">altivec</span></tt> attribute please see the
documentation in PowerPC Type Attributes.</p>
</div>
<div class="section" id="spu-variable-attributes">
<span id="id10"></span><h2>SPU Variable Attributes<a class="headerlink" href="#spu-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p id="index-42">The SPU supports the <tt class="docutils literal"><span class="pre">spu_vector</span></tt> attribute for variables.  For
documentation of this attribute please see the documentation in
SPU Type Attributes.</p>
</div>
<div class="section" id="x86-variable-attributes">
<span id="id11"></span><h2>x86 Variable Attributes<a class="headerlink" href="#x86-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p>Two attributes are currently defined for x86 configurations:
<tt class="docutils literal"><span class="pre">ms_struct</span></tt> and <tt class="docutils literal"><span class="pre">gcc_struct</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">ms_struct</span></tt> <tt class="docutils literal"><span class="pre">gcc_struct</span></tt></p>
<blockquote>
<div><span class="target" id="index-43"></span><p id="index-44">If <tt class="docutils literal"><span class="pre">packed</span></tt> is used on a structure, or if bit-fields are used,
it may be that the Microsoft ABI lays out the structure differently
than the way GCC normally does.  Particularly when moving packed
data between functions compiled with GCC and the native Microsoft compiler
(either via function call or as data in a file), it may be necessary to access
either format.</p>
<p>Currently <em class="xref std std-option">-m[no-]ms-bitfields</em> is provided for the Microsoft Windows x86
compilers to match the native Microsoft compiler.</p>
<p>The Microsoft structure layout algorithm is fairly simple with the exception
of the bit-field packing.
The padding and alignment of members of structures and whether a bit-field
can straddle a storage-unit boundary are determine by these rules:</p>
<ul>
<li><p class="first">Structure members are stored sequentially in the order in which they are
declared: the first member has the lowest memory address and the last member
the highest.</p>
</li>
<li><p class="first">Every data object has an alignment requirement.  The alignment requirement
for all data except structures, unions, and arrays is either the size of the
object or the current packing size (specified with either the
<tt class="docutils literal"><span class="pre">aligned</span></tt> attribute or the <tt class="docutils literal"><span class="pre">pack</span></tt> pragma),
whichever is less.  For structures, unions, and arrays,
the alignment requirement is the largest alignment requirement of its members.
Every object is allocated an offset so that:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">offset</span> <span class="o">%</span> <span class="n">alignment_requirement</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</li>
<li><p class="first">Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte allocation
unit if the integral types are the same size and if the next bit-field fits
into the current allocation unit without crossing the boundary imposed by the
common alignment requirements of the bit-fields.</p>
</li>
</ul>
<p>MSVC interprets zero-length bit-fields in the following ways:</p>
<ul>
<li><p class="first">If a zero-length bit-field is inserted between two bit-fields that
are normally coalesced, the bit-fields are not coalesced.</p>
<p>For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span>
 <span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bf_1</span> <span class="o">:</span> <span class="mi">12</span><span class="p">;</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bf_2</span> <span class="o">:</span> <span class="mi">12</span><span class="p">;</span>
 <span class="p">}</span> <span class="n">t1</span><span class="p">;</span>
</pre></div>
</div>
<p>The size of <tt class="docutils literal"><span class="pre">t1</span></tt> is 8 bytes with the zero-length bit-field.  If the
zero-length bit-field were removed, <tt class="docutils literal"><span class="pre">t1</span></tt>&#8216;s size would be 4 bytes.</p>
</li>
<li><p class="first">If a zero-length bit-field is inserted after a bit-field, <tt class="docutils literal"><span class="pre">foo</span></tt>, and the
alignment of the zero-length bit-field is greater than the member that follows it,
<tt class="docutils literal"><span class="pre">bar</span></tt>, <tt class="docutils literal"><span class="pre">bar</span></tt> is aligned as the type of the zero-length bit-field.</p>
<p>For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span>
 <span class="p">{</span>
   <span class="kt">char</span> <span class="n">foo</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
   <span class="kt">short</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
   <span class="kt">char</span> <span class="n">bar</span><span class="p">;</span>
 <span class="p">}</span> <span class="n">t2</span><span class="p">;</span>

<span class="k">struct</span>
 <span class="p">{</span>
   <span class="kt">char</span> <span class="n">foo</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
   <span class="kt">short</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">bar</span><span class="p">;</span>
 <span class="p">}</span> <span class="n">t3</span><span class="p">;</span>
</pre></div>
</div>
<p>For <tt class="docutils literal"><span class="pre">t2</span></tt>, <tt class="docutils literal"><span class="pre">bar</span></tt> is placed at offset 2, rather than offset 1.
Accordingly, the size of <tt class="docutils literal"><span class="pre">t2</span></tt> is 4.  For <tt class="docutils literal"><span class="pre">t3</span></tt>, the zero-length
bit-field does not affect the alignment of <tt class="docutils literal"><span class="pre">bar</span></tt> or, as a result, the size
of the structure.</p>
<p>Taking this into account, it is important to note the following:</p>
<ul>
<li><p class="first">If a zero-length bit-field follows a normal bit-field, the type of the
zero-length bit-field may affect the alignment of the structure as whole. For
example, <tt class="docutils literal"><span class="pre">t2</span></tt> has a size of 4 bytes, since the zero-length bit-field follows a
normal bit-field, and is of type short.</p>
</li>
<li><p class="first">Even if a zero-length bit-field is not followed by a normal bit-field, it may
still affect the alignment of the structure:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span>
 <span class="p">{</span>
   <span class="kt">char</span> <span class="n">foo</span> <span class="o">:</span> <span class="mi">6</span><span class="p">;</span>
   <span class="kt">long</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span> <span class="n">t4</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">t4</span></tt> takes up 4 bytes.</p>
</li>
</ul>
</li>
<li><p class="first">Zero-length bit-fields following non-bit-field members are ignored:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span>
 <span class="p">{</span>
   <span class="kt">char</span> <span class="n">foo</span><span class="p">;</span>
   <span class="kt">long</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
   <span class="kt">char</span> <span class="n">bar</span><span class="p">;</span>
 <span class="p">}</span> <span class="n">t5</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">t5</span></tt> takes up 2 bytes.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="xstormy16-variable-attributes">
<span id="id12"></span><h2>Xstormy16 Variable Attributes<a class="headerlink" href="#xstormy16-variable-attributes" title="Permalink to this headline">¶</a></h2>
<p>One attribute is currently defined for xstormy16 configurations:
<tt class="docutils literal"><span class="pre">below100</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">below100</span></tt></p>
<blockquote>
<div><p id="index-45">If a variable has the <tt class="docutils literal"><span class="pre">below100</span></tt> attribute (<tt class="docutils literal"><span class="pre">BELOW100</span></tt> is
allowed also), GCC places the variable in the first 0x100 bytes of
memory and use special opcodes to access it.  Such variables are
placed in either the <tt class="docutils literal"><span class="pre">.bss_below100</span></tt> section or the
<tt class="docutils literal"><span class="pre">.data_below100</span></tt> section.</p>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="specifying-attributes-of-types.html" title="Specifying Attributes of Types"
             >next</a> |</li>
        <li class="right" >
          <a href="declaring-attributes-of-functions.html" title="Declaring Attributes of Functions"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" >Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>