

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Type Encoding &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="GNU Objective-C Features" href="gnu-objective-c-features.html" />
    <link rel="next" title="Garbage Collection" href="garbage-collection.html" />
    <link rel="prev" title="&lt;no title&gt;" href="+load:-executing-code-before-main.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="garbage-collection.html" title="Garbage Collection"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="+load:-executing-code-before-main.html" title="&lt;no title&gt;"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="gnu-objective-c-features.html" accesskey="U">GNU Objective-C Features</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Type Encoding</a><ul>
<li><a class="reference internal" href="#legacy-type-encoding">Legacy Type Encoding</a></li>
<li><a class="reference internal" href="#method-signatures">Method Signatures</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="+load:-executing-code-before-main.html"
                        title="previous chapter">&lt;no title&gt;</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="garbage-collection.html"
                        title="next chapter">Garbage Collection</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/type-encoding.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="type-encoding">
<span id="id1"></span><h1>Type Encoding<a class="headerlink" href="#type-encoding" title="Permalink to this headline">Â¶</a></h1>
<p>This is an advanced section.  Type encodings are used extensively by
the compiler and by the runtime, but you generally do not need to know
about them to use Objective-C.</p>
<p>The Objective-C compiler generates type encodings for all the types.
These type encodings are used at runtime to find out information about
selectors and methods and about objects and classes.</p>
<p>The types are encoded in the following way:</p>
<p><tt class="docutils literal"><span class="pre">_Bool</span></tt></p>
<p><tt class="docutils literal"><span class="pre">B</span></tt></p>
<p><tt class="docutils literal"><span class="pre">char</span></tt></p>
<p><tt class="docutils literal"><span class="pre">c</span></tt></p>
<p><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt></p>
<p><tt class="docutils literal"><span class="pre">C</span></tt></p>
<p><tt class="docutils literal"><span class="pre">short</span></tt></p>
<p><tt class="docutils literal"><span class="pre">s</span></tt></p>
<p><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></tt></p>
<p><tt class="docutils literal"><span class="pre">S</span></tt></p>
<p><tt class="docutils literal"><span class="pre">int</span></tt></p>
<p><tt class="docutils literal"><span class="pre">i</span></tt></p>
<p><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt></p>
<p><tt class="docutils literal"><span class="pre">I</span></tt></p>
<p><tt class="docutils literal"><span class="pre">long</span></tt></p>
<p><tt class="docutils literal"><span class="pre">l</span></tt></p>
<p><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt></p>
<p><tt class="docutils literal"><span class="pre">L</span></tt></p>
<p><tt class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt></p>
<p><tt class="docutils literal"><span class="pre">q</span></tt></p>
<p><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></tt></p>
<p><tt class="docutils literal"><span class="pre">Q</span></tt></p>
<p><tt class="docutils literal"><span class="pre">float</span></tt></p>
<p><tt class="docutils literal"><span class="pre">f</span></tt></p>
<p><tt class="docutils literal"><span class="pre">double</span></tt></p>
<p><tt class="docutils literal"><span class="pre">d</span></tt></p>
<p><tt class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></tt></p>
<p><tt class="docutils literal"><span class="pre">D</span></tt></p>
<p><tt class="docutils literal"><span class="pre">void</span></tt></p>
<p><tt class="docutils literal"><span class="pre">v</span></tt></p>
<p><tt class="docutils literal"><span class="pre">id</span></tt></p>
<p><tt class="docutils literal"><span class="pre">&#64;</span></tt></p>
<p><tt class="docutils literal"><span class="pre">Class</span></tt></p>
<p><tt class="docutils literal"><span class="pre">#</span></tt></p>
<p><tt class="docutils literal"><span class="pre">SEL</span></tt></p>
<p><tt class="docutils literal"><span class="pre">:</span></tt></p>
<p><tt class="docutils literal"><span class="pre">char*</span></tt></p>
<p><tt class="docutils literal"><span class="pre">*</span></tt></p>
<p><tt class="docutils literal"><span class="pre">enum</span></tt></p>
<p>an <tt class="docutils literal"><span class="pre">enum</span></tt> is encoded exactly as the integer type that the compiler uses for it, which depends on the enumeration
values.  Often the compiler users <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt>, which is then encoded as <tt class="docutils literal"><span class="pre">I</span></tt>.</p>
<p>unknown type</p>
<p><tt class="docutils literal"><span class="pre">?</span></tt></p>
<p>Complex types</p>
<p><tt class="docutils literal"><span class="pre">j</span></tt> followed by the inner type.  For example <tt class="docutils literal"><span class="pre">_Complex</span> <span class="pre">double</span></tt> is encoded as &#8220;jd&#8221;.</p>
<p>bit-fields</p>
<p><tt class="docutils literal"><span class="pre">b</span></tt> followed by the starting position of the bit-field, the type of the bit-field and the size of the bit-field (the bit-fields encoding was changed from the NeXT&#8217;s compiler encoding, see below)</p>
<p>The encoding of bit-fields has changed to allow bit-fields to be
properly handled by the runtime functions that compute sizes and
alignments of types that contain bit-fields.  The previous encoding
contained only the size of the bit-field.  Using only this information
it is not possible to reliably compute the size occupied by the
bit-field.  This is very important in the presence of the Boehm&#8217;s
garbage collector because the objects are allocated using the typed
memory facility available in this collector.  The typed memory
allocation requires information about where the pointers are located
inside the object.</p>
<p>The position in the bit-field is the position, counting in bits, of the
bit closest to the beginning of the structure.</p>
<p>The non-atomic types are encoded as follows:</p>
<p>pointers</p>
<p>^ followed by the pointed type.</p>
<p>arrays</p>
<p>[ followed by the number of elements in the array followed by the type of the elements followed by ]</p>
<p>structures</p>
<p>{ followed by the name of the structure (or ? if the structure is unnamed), the = sign, the type of the members and by }</p>
<p>unions</p>
<p>( followed by the name of the structure (or ? if the union is unnamed), the = sign, the type of the members followed by )</p>
<p>vectors</p>
<p>![ followed by the vector_size (the number of bytes composing the vector) followed by a comma, followed by the alignment (in bytes) of the vector, followed by the type of the elements followed by ]</p>
<p>Here are some types and their encodings, as they are generated by the
compiler on an i386 machine:</p>
<p>Objective-C type</p>
<p>Compiler encoding</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">[10i]</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">a</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">{?=i[3f]b128i3b131i2c}</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">vector_size</span> <span class="p">(</span><span class="mi">16</span><span class="p">)));</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">![16,16i]</span></tt> (alignment would depend on the machine)</p>
<p>In addition to the types the compiler also encodes the type
specifiers.  The table below describes the encoding of the current
Objective-C type specifiers:</p>
<p>Specifier</p>
<p>Encoding</p>
<p><tt class="docutils literal"><span class="pre">const</span></tt></p>
<p><tt class="docutils literal"><span class="pre">r</span></tt></p>
<p><tt class="docutils literal"><span class="pre">in</span></tt></p>
<p><tt class="docutils literal"><span class="pre">n</span></tt></p>
<p><tt class="docutils literal"><span class="pre">inout</span></tt></p>
<p><tt class="docutils literal"><span class="pre">N</span></tt></p>
<p><tt class="docutils literal"><span class="pre">out</span></tt></p>
<p><tt class="docutils literal"><span class="pre">o</span></tt></p>
<p><tt class="docutils literal"><span class="pre">bycopy</span></tt></p>
<p><tt class="docutils literal"><span class="pre">O</span></tt></p>
<p><tt class="docutils literal"><span class="pre">byref</span></tt></p>
<p><tt class="docutils literal"><span class="pre">R</span></tt></p>
<p><tt class="docutils literal"><span class="pre">oneway</span></tt></p>
<p><tt class="docutils literal"><span class="pre">V</span></tt></p>
<p>The type specifiers are encoded just before the type.  Unlike types
however, the type specifiers are only encoded when they appear in method
argument types.</p>
<p>Note how <tt class="docutils literal"><span class="pre">const</span></tt> interacts with pointers:</p>
<p>Objective-C type</p>
<p>Compiler encoding</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="kt">int</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">ri</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="kt">int</span><span class="o">*</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">^ri</span></tt></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="o">*</span><span class="k">const</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">r^i</span></tt></p>
<p><tt class="docutils literal"><span class="pre">const</span> <span class="pre">int*</span></tt> is a pointer to a <tt class="docutils literal"><span class="pre">const</span> <span class="pre">int</span></tt>, and so is
encoded as <tt class="docutils literal"><span class="pre">^ri</span></tt>.  <tt class="docutils literal"><span class="pre">int*</span> <span class="pre">const</span></tt>, instead, is a <tt class="docutils literal"><span class="pre">const</span></tt>
pointer to an <tt class="docutils literal"><span class="pre">int</span></tt>, and so is encoded as <tt class="docutils literal"><span class="pre">r^i</span></tt>.</p>
<p>Finally, there is a complication when encoding <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></tt>
versus <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">const</span></tt>.  Because <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> is encoded as
<tt class="docutils literal"><span class="pre">*</span></tt> and not as <tt class="docutils literal"><span class="pre">^c</span></tt>, there is no way to express the fact
that <tt class="docutils literal"><span class="pre">r</span></tt> applies to the pointer or to the pointee.</p>
<p>Hence, it is assumed as a convention that <tt class="docutils literal"><span class="pre">r*</span></tt> means <tt class="docutils literal"><span class="pre">const</span>
<span class="pre">char</span> <span class="pre">*</span></tt> (since it is what is most often meant), and there is no way to
encode <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*const</span></tt>.  <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*const</span></tt> would simply be encoded
as <tt class="docutils literal"><span class="pre">*</span></tt>, and the <tt class="docutils literal"><span class="pre">const</span></tt> is lost.</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="legacy-type-encoding">
<span id="id2"></span><h2>Legacy Type Encoding<a class="headerlink" href="#legacy-type-encoding" title="Permalink to this headline">Â¶</a></h2>
<p>Unfortunately, historically GCC used to have a number of bugs in its
encoding code.  The NeXT runtime expects GCC to emit type encodings in
this historical format (compatible with GCC-3.3), so when using the
NeXT runtime, GCC will introduce on purpose a number of incorrect
encodings:</p>
<ul class="simple">
<li>the read-only qualifier of the pointee gets emitted before the &#8216;^&#8217;.
The read-only qualifier of the pointer itself gets ignored, unless it
is a typedef.  Also, the &#8216;r&#8217; is only emitted for the outermost type.</li>
<li>32-bit longs are encoded as &#8216;l&#8217; or &#8216;L&#8217;, but not always.  For typedefs,
the compiler uses &#8216;i&#8217; or &#8216;I&#8217; instead if encoding a struct field or a
pointer.</li>
<li><a href="#id3"><span class="problematic" id="id4">``</span></a>enum``s are always encoded as &#8216;i&#8217; (int) even if they are actually
unsigned or long.</li>
</ul>
<p>In addition to that, the NeXT runtime uses a different encoding for
bitfields.  It encodes them as <tt class="docutils literal"><span class="pre">b</span></tt> followed by the size, without
a bit offset or the underlying field type.</p>
<p id="encode"><tt class="docutils literal"><span class="pre">&#64;encode``GNU</span> <span class="pre">Objective-C</span> <span class="pre">supports</span> <span class="pre">the</span> <span class="pre">``&#64;encode</span></tt> syntax that allows you to
create a type encoding from a C/Objective-C type.  For example,
<tt class="docutils literal"><span class="pre">&#64;encode(int)</span></tt> is compiled by the compiler into <tt class="docutils literal"><span class="pre">&quot;i&quot;</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">&#64;encode</span></tt> does not support type qualifiers other than
<tt class="docutils literal"><span class="pre">const</span></tt>.  For example, <tt class="docutils literal"><span class="pre">&#64;encode(const</span> <span class="pre">char*)</span></tt> is valid and
is compiled into <tt class="docutils literal"><span class="pre">&quot;r*&quot;</span></tt>, while <tt class="docutils literal"><span class="pre">&#64;encode(bycopy</span> <span class="pre">char</span> <span class="pre">*)</span></tt> is
invalid and will cause a compilation error.</p>
</div>
<div class="section" id="method-signatures">
<span id="id5"></span><h2>Method Signatures<a class="headerlink" href="#method-signatures" title="Permalink to this headline">Â¶</a></h2>
<p>This section documents the encoding of method types, which is rarely
needed to use Objective-C.  You should skip it at a first reading; the
runtime provides functions that will work on methods and can walk
through the list of parameters and interpret them for you.  These
functions are part of the public &#8216;API&#8217; and are the preferred way to
interact with method signatures from user code.</p>
<p>But if you need to debug a problem with method signatures and need to
know how they are implemented (i.e., the &#8216;ABI&#8217;), read on.</p>
<p>Methods have their &#8216;signature&#8217; encoded and made available to the
runtime.  The &#8216;signature&#8217; encodes all the information required to
dynamically build invocations of the method at runtime: return type
and arguments.</p>
<p>The &#8216;signature&#8217; is a null-terminated string, composed of the following:</p>
<ul class="simple">
<li>The return type, including type qualifiers.  For example, a method
returning <tt class="docutils literal"><span class="pre">int</span></tt> would have <tt class="docutils literal"><span class="pre">i</span></tt> here.</li>
<li>The total size (in bytes) required to pass all the parameters.  This
includes the two hidden parameters (the object <tt class="docutils literal"><span class="pre">self</span></tt> and the
method selector <tt class="docutils literal"><span class="pre">_cmd</span></tt>).</li>
<li>Each argument, with the type encoding, followed by the offset (in
bytes) of the argument in the list of parameters.</li>
</ul>
<p>For example, a method with no arguments and returning <tt class="docutils literal"><span class="pre">int</span></tt> would
have the signature <tt class="docutils literal"><span class="pre">i8&#64;0:4</span></tt> if the size of a pointer is 4.  The
signature is interpreted as follows: the <tt class="docutils literal"><span class="pre">i</span></tt> is the return type
(an <tt class="docutils literal"><span class="pre">int</span></tt>), the <tt class="docutils literal"><span class="pre">8</span></tt> is the total size of the parameters in
bytes (two pointers each of size 4), the <tt class="docutils literal"><span class="pre">&#64;0</span></tt> is the first
parameter (an object at byte offset <tt class="docutils literal"><span class="pre">0</span></tt>) and <tt class="docutils literal"><span class="pre">:4</span></tt> is the
second parameter (a <tt class="docutils literal"><span class="pre">SEL</span></tt> at byte offset <tt class="docutils literal"><span class="pre">4</span></tt>).</p>
<p>You can easily find more examples by running the &#8216;strings&#8217; program
on an Objective-C object file compiled by GCC.  You&#8217;ll see a lot of
strings that look very much like <tt class="docutils literal"><span class="pre">i8&#64;0:4</span></tt>.  They are signatures
of Objective-C methods.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="garbage-collection.html" title="Garbage Collection"
             >next</a> |</li>
        <li class="right" >
          <a href="+load:-executing-code-before-main.html" title="&lt;no title&gt;"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="gnu-objective-c-features.html" >GNU Objective-C Features</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>