

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Compound Literals &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="Extensions to the C Language Family" href="extensions-to-the-c-language-family.html" />
    <link rel="next" title="Designated Initializers" href="designated-initializers.html" />
    <link rel="prev" title="Non-Constant Initializers" href="non-constant-initializers.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="designated-initializers.html" title="Designated Initializers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="non-constant-initializers.html" title="Non-Constant Initializers"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" accesskey="U">Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="non-constant-initializers.html"
                        title="previous chapter">Non-Constant Initializers</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="designated-initializers.html"
                        title="next chapter">Designated Initializers</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/compound-literals.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="compound-literals">
<span id="id1"></span><h1>Compound Literals<a class="headerlink" href="#compound-literals" title="Permalink to this headline">Â¶</a></h1>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><span class="target" id="index-2"></span><span class="target" id="index-3"></span><span class="target" id="index-4"></span><p>ISO C99 supports compound literals.  A compound literal looks like
a cast containing an initializer.  Its value is an object of the
type specified in the cast, containing the elements specified in
the initializer; it is an lvalue.  As an extension, GCC supports
compound literals in C90 mode and in C++, though the semantics are
somewhat different in C++.</p>
<p>Usually, the specified type is a structure.  Assume that
<tt class="docutils literal"><span class="pre">struct</span> <span class="pre">foo</span></tt> and <tt class="docutils literal"><span class="pre">structure</span></tt> are declared as shown:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span><span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">];}</span> <span class="n">structure</span><span class="p">;</span>
</pre></div>
</div>
<p>Here is an example of constructing a <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">foo</span></tt> with a compound literal:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">structure</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">});</span>
</pre></div>
</div>
<p>This is equivalent to writing the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">{</span>
  <span class="k">struct</span> <span class="n">foo</span> <span class="n">temp</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
  <span class="n">structure</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can also construct an array, though this is dangerous in C++, as
explained below.  If all the elements of the compound literal are
(made up of) simple constant expressions, suitable for use in
initializers of objects of static storage duration, then the compound
literal can be coerced to a pointer to its first element and used in
such an initializer, as shown here:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">char</span> <span class="o">**</span><span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">[])</span> <span class="p">{</span> <span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="s">&quot;z&quot;</span> <span class="p">};</span>
</pre></div>
</div>
<p>Compound literals for scalar types and union types are
also allowed, but then the compound literal is equivalent
to a cast.</p>
<p>As a GNU extension, GCC allows initialization of objects with static storage
duration by compound literals (which is not possible in ISO C99, because
the initializer is not a constant).
It is handled as if the object is initialized only with the bracket
enclosed list if the types of the compound literal and the object match.
The initializer list of the compound literal must be constant.
If the object being initialized has array type of unknown size, the size is
determined by compound literal size.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="k">struct</span> <span class="n">foo</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">y</span><span class="p">[]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">[])</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">z</span><span class="p">[]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>
</pre></div>
</div>
<p>The above lines are equivalent to the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="k">struct</span> <span class="n">foo</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">y</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">z</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</pre></div>
</div>
<p>In C, a compound literal designates an unnamed object with static or
automatic storage duration.  In C++, a compound literal designates a
temporary object, which only lives until the end of its
full-expression.  As a result, well-defined C code that takes the
address of a subobject of a compound literal can be undefined in C++,
so the C++ compiler rejects the conversion of a temporary array to a pointer.
For instance, if the array compound literal example above appeared
inside a function, any subsequent use of <tt class="samp docutils literal"><span class="pre">foo</span></tt> in C++ has
undefined behavior because the lifetime of the array ends after the
declaration of <tt class="samp docutils literal"><span class="pre">foo</span></tt>.</p>
<p>As an optimization, the C++ compiler sometimes gives array compound
literals longer lifetimes: when the array either appears outside a
function or has const-qualified type.  If <tt class="samp docutils literal"><span class="pre">foo</span></tt> and its
initializer had elements of <tt class="samp docutils literal"><span class="pre">char</span> <span class="pre">*const</span></tt> type rather than
<tt class="samp docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt>, or if <tt class="samp docutils literal"><span class="pre">foo</span></tt> were a global variable, the array
would have static storage duration.  But it is probably safest just to
avoid the use of array compound literals in code compiled as C++.</p>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="designated-initializers.html" title="Designated Initializers"
             >next</a> |</li>
        <li class="right" >
          <a href="non-constant-initializers.html" title="Non-Constant Initializers"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" >Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>