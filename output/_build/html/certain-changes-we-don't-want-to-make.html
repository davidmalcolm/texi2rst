

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Certain Changes We Don’t Want to Make &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="Known Causes of Trouble with GCC" href="known-causes-of-trouble-with-gcc.html" />
    <link rel="next" title="Warning Messages and Error Messages" href="warning-messages-and-error-messages.html" />
    <link rel="prev" title="Common Misunderstandings with GNU C++" href="common-misunderstandings-with-gnu-c++.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="warning-messages-and-error-messages.html" title="Warning Messages and Error Messages"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="common-misunderstandings-with-gnu-c++.html" title="Common Misunderstandings with GNU C++"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="known-causes-of-trouble-with-gcc.html" accesskey="U">Known Causes of Trouble with GCC</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="common-misunderstandings-with-gnu-c++.html"
                        title="previous chapter">Common Misunderstandings with GNU C++</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="warning-messages-and-error-messages.html"
                        title="next chapter">Warning Messages and Error Messages</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/certain-changes-we-don&#39;t-want-to-make.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="certain-changes-we-don-t-want-to-make">
<span id="non-bugs"></span><h1>Certain Changes We Don&#8217;t Want to Make<a class="headerlink" href="#certain-changes-we-don-t-want-to-make" title="Permalink to this headline">¶</a></h1>
<p>This section lists changes that people frequently request, but which
we do not make because we think GCC is better without them.</p>
<ul>
<li><p class="first">Checking the number and type of arguments to a function which has an
old-fashioned definition and no prototype.</p>
<p>Such a feature would work only occasionally-only for calls that appear
in the same file as the called function, following the definition.  The
only way to check all calls reliably is to add a prototype for the
function.  But adding a prototype eliminates the motivation for this
feature.  So the feature is not worthwhile.</p>
</li>
<li><p class="first">Warning about using an expression whose type is signed as a shift count.</p>
<p>Shift count operands are probably signed more often than unsigned.
Warning about this would cause far more annoyance than good.</p>
</li>
<li><p class="first">Warning about assigning a signed value to an unsigned variable.</p>
<p>Such assignments must be very common; warning about them would cause
more annoyance than good.</p>
</li>
<li><p class="first">Warning when a non-void function value is ignored.</p>
<p>C contains many standard functions that return a value that most
programs choose to ignore.  One obvious example is <tt class="docutils literal"><span class="pre">printf</span></tt>.
Warning about this practice only leads the defensive programmer to
clutter programs with dozens of casts to <tt class="docutils literal"><span class="pre">void</span></tt>.  Such casts are
required so frequently that they become visual noise.  Writing those
casts becomes so automatic that they no longer convey useful
information about the intentions of the programmer.  For functions
where the return value should never be ignored, use the
<tt class="docutils literal"><span class="pre">warn_unused_result</span></tt> function attribute (Function
Attributes).</p>
</li>
<li><p id="index-0">Making <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fshort-enums"><em class="xref std std-option">-fshort-enums</em></a> the default.</p>
<p>This would cause storage layout to be incompatible with most other C
compilers.  And it doesn&#8217;t seem very important, given that you can get
the same result in other ways.  The case where it matters most is when
the enumeration-valued object is inside a structure, and in that case
you can specify a field width explicitly.</p>
</li>
<li><p class="first">Making bit-fields unsigned by default on particular machines where &#8216;the
ABI standard&#8217; says to do so.</p>
<p>The ISO C standard leaves it up to the implementation whether a bit-field
declared plain <tt class="docutils literal"><span class="pre">int</span></tt> is signed or not.  This in effect creates two
alternative dialects of C.</p>
<span class="target" id="index-1"></span><p id="index-2">The GNU C compiler supports both dialects; you can specify the signed
dialect with <a class="reference internal" href="options-controlling-c-dialect.html#cmdoption-fsigned-bitfields"><em class="xref std std-option">-fsigned-bitfields</em></a> and the unsigned dialect with
<em class="xref std std-option">-funsigned-bitfields</em>.  However, this leaves open the question of
which dialect to use by default.</p>
<p>Currently, the preferred dialect makes plain bit-fields signed, because
this is simplest.  Since <tt class="docutils literal"><span class="pre">int</span></tt> is the same as <tt class="docutils literal"><span class="pre">signed</span> <span class="pre">int</span></tt> in
every other context, it is cleanest for them to be the same in bit-fields
as well.</p>
<p>Some computer manufacturers have published Application Binary Interface
standards which specify that plain bit-fields should be unsigned.  It is
a mistake, however, to say anything about this issue in an ABI.  This is
because the handling of plain bit-fields distinguishes two dialects of C.
Both dialects are meaningful on every type of machine.  Whether a
particular object file was compiled using signed bit-fields or unsigned
is of no concern to other object files, even if they access the same
bit-fields in the same data structures.</p>
<p>A given program is written in one or the other of these two dialects.
The program stands a chance to work on most any machine if it is
compiled with the proper dialect.  It is unlikely to work at all if
compiled with the wrong dialect.</p>
<p>Many users appreciate the GNU C compiler because it provides an
environment that is uniform across machines.  These users would be
inconvenienced if the compiler treated plain bit-fields differently on
certain machines.</p>
<p>Occasionally users write programs intended only for a particular machine
type.  On these occasions, the users would benefit if the GNU C compiler
were to support by default the same dialect as the other compilers on
that machine.  But such applications are rare.  And users writing a
program to run on more than one type of machine cannot possibly benefit
from this kind of compatibility.</p>
<p>This is why GCC does and will treat plain bit-fields in the same
fashion on all types of machines (by default).</p>
<p>There are some arguments for making bit-fields unsigned by default on all
machines.  If, for example, this becomes a universal de facto standard,
it would make sense for GCC to go along with it.  This is something
to be considered in the future.</p>
<p>(Of course, users strongly concerned about portability should indicate
explicitly in each bit-field whether it is signed or not.  In this way,
they write programs which have the same meaning in both C dialects.)</p>
</li>
<li><span class="target" id="index-3"></span><p id="index-4">Undefining <tt class="docutils literal"><span class="pre">__STDC__</span></tt> when <a class="reference internal" href="options-controlling-c-dialect.html#cmdoption-ansi"><em class="xref std std-option">-ansi</em></a> is not used.</p>
<p>Currently, GCC defines <tt class="docutils literal"><span class="pre">__STDC__</span></tt> unconditionally.  This provides
good results in practice.</p>
<p>Programmers normally use conditionals on <tt class="docutils literal"><span class="pre">__STDC__</span></tt> to ask whether
it is safe to use certain features of ISO C, such as function
prototypes or ISO token concatenation.  Since plain <strong class="command">gcc</strong> supports
all the features of ISO C, the correct answer to these questions is
&#8216;yes&#8217;.</p>
<p>Some users try to use <tt class="docutils literal"><span class="pre">__STDC__</span></tt> to check for the availability of
certain library facilities.  This is actually incorrect usage in an ISO
C program, because the ISO C standard says that a conforming
freestanding implementation should define <tt class="docutils literal"><span class="pre">__STDC__</span></tt> even though it
does not have the library facilities.  gcc -ansi -pedantic is a
conforming freestanding implementation, and it is therefore required to
define <tt class="docutils literal"><span class="pre">__STDC__</span></tt>, even though it does not come with an ISO C
library.</p>
<p>Sometimes people say that defining <tt class="docutils literal"><span class="pre">__STDC__</span></tt> in a compiler that
does not completely conform to the ISO C standard somehow violates the
standard.  This is illogical.  The standard is a standard for compilers
that claim to support ISO C, such as gcc -ansi-not for other
compilers such as plain <strong class="command">gcc</strong>.  Whatever the ISO C standard says
is relevant to the design of plain <strong class="command">gcc</strong> without <a class="reference internal" href="options-controlling-c-dialect.html#cmdoption-ansi"><em class="xref std std-option">-ansi</em></a> only
for pragmatic reasons, not as a requirement.</p>
<p>GCC normally defines <tt class="docutils literal"><span class="pre">__STDC__</span></tt> to be 1, and in addition
defines <tt class="docutils literal"><span class="pre">__STRICT_ANSI__</span></tt> if you specify the <a class="reference internal" href="options-controlling-c-dialect.html#cmdoption-ansi"><em class="xref std std-option">-ansi</em></a> option,
or a <a class="reference internal" href="options-controlling-the-preprocessor.html#cmdoption-std"><em class="xref std std-option">-std</em></a> option for strict conformance to some version of ISO C.
On some hosts, system include files use a different convention, where
<tt class="docutils literal"><span class="pre">__STDC__</span></tt> is normally 0, but is 1 if the user specifies strict
conformance to the C Standard.  GCC follows the host convention when
processing system include files, but when processing user files it follows
the usual GNU C convention.</p>
</li>
<li><p class="first">Undefining <tt class="docutils literal"><span class="pre">__STDC__</span></tt> in C++.</p>
<p>Programs written to compile with C++-to-C translators get the
value of <tt class="docutils literal"><span class="pre">__STDC__</span></tt> that goes with the C compiler that is
subsequently used.  These programs must test <tt class="docutils literal"><span class="pre">__STDC__</span></tt>
to determine what kind of C preprocessor that compiler uses:
whether they should concatenate tokens in the ISO C fashion
or in the traditional fashion.</p>
<p>These programs work properly with GNU C++ if <tt class="docutils literal"><span class="pre">__STDC__</span></tt> is defined.
They would not work otherwise.</p>
<p>In addition, many header files are written to provide prototypes in ISO
C but not in traditional C.  Many of these header files can work without
change in C++ provided <tt class="docutils literal"><span class="pre">__STDC__</span></tt> is defined.  If <tt class="docutils literal"><span class="pre">__STDC__</span></tt>
is not defined, they will all fail, and will all need to be changed to
test explicitly for C++ as well.</p>
</li>
<li><p class="first">Deleting &#8216;empty&#8217; loops.</p>
<p>Historically, GCC has not deleted &#8216;empty&#8217; loops under the
assumption that the most likely reason you would put one in a program is
to have a delay, so deleting them will not make real programs run any
faster.</p>
<p>However, the rationale here is that optimization of a nonempty loop
cannot produce an empty one. This held for carefully written C compiled
with less powerful optimizers but is not always the case for carefully
written C++ or with more powerful optimizers.
Thus GCC will remove operations from loops whenever it can determine
those operations are not externally visible (apart from the time taken
to execute them, of course).  In case the loop can be proved to be finite,
GCC will also remove the loop itself.</p>
<p>Be aware of this when performing timing tests, for instance the
following loop can be completely removed, provided
<tt class="docutils literal"><span class="pre">some_expression</span></tt> can provably not change any global state.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">{</span>
   <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">ix</span><span class="p">;</span>

   <span class="k">for</span> <span class="p">(</span><span class="n">ix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ix</span> <span class="o">!=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">ix</span><span class="o">++</span><span class="p">)</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">some_expression</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Even though <tt class="docutils literal"><span class="pre">sum</span></tt> is accumulated in the loop, no use is made of
that summation, so the accumulation can be removed.</p>
</li>
<li><p class="first">Making side effects happen in the same order as in some other compiler.</p>
<span class="target" id="index-5"></span><p id="index-6">It is never safe to depend on the order of evaluation of side effects.
For example, a function call like this may very well behave differently
from one compiler to another:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">func</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">func</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
</pre></div>
</div>
<p>There is no guarantee (in either the C or the C++ standard language
definitions) that the increments will be evaluated in any particular
order.  Either increment might happen first.  <tt class="docutils literal"><span class="pre">func</span></tt> might get the
arguments 2, 3, or it might get 3, 2, or even 2, 2.</p>
</li>
<li><p class="first">Making certain warnings into errors by default.</p>
<p>Some ISO C testsuites report failure when the compiler does not produce
an error message for a certain program.</p>
<p id="index-7">ISO C requires a &#8216;diagnostic&#8217; message for certain kinds of invalid
programs, but a warning is defined by GCC to count as a diagnostic.  If
GCC produces a warning but not an error, that is correct ISO C support.
If testsuites call this &#8216;failure&#8217;, they should be run with the GCC
option <a class="reference internal" href="options-to-request-or-suppress-warnings.html#cmdoption-pedantic-errors"><em class="xref std std-option">-pedantic-errors</em></a>, which will turn these warnings into
errors.</p>
</li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="warning-messages-and-error-messages.html" title="Warning Messages and Error Messages"
             >next</a> |</li>
        <li class="right" >
          <a href="common-misunderstandings-with-gnu-c++.html" title="Common Misunderstandings with GNU C++"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="known-causes-of-trouble-with-gcc.html" >Known Causes of Trouble with GCC</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>