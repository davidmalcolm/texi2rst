

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>&lt;no title&gt; &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="Extensions to the C Language Family" href="extensions-to-the-c-language-family.html" />
    <link rel="next" title="Built-in Functions for Memory Model Aware Atomic Operations" href="built-in-functions-for-memory-model-aware-atomic-operations.html" />
    <link rel="prev" title="&lt;no title&gt;" href="support-for-offsetof.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="built-in-functions-for-memory-model-aware-atomic-operations.html" title="Built-in Functions for Memory Model Aware Atomic Operations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="support-for-offsetof.html" title="&lt;no title&gt;"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" accesskey="U">Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="support-for-offsetof.html"
                        title="previous chapter">&lt;no title&gt;</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="built-in-functions-for-memory-model-aware-atomic-operations.html"
                        title="next chapter">Built-in Functions for Memory Model Aware Atomic Operations</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/legacy-__sync-built-in-functions-for-atomic-memory-access.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <p>Legacy <tt class="docutils literal"><span class="pre">__sync</span></tt> Built-in Functions for Atomic Memory Access</p>
<p>The following built-in functions
are intended to be compatible with those described
in the Intel Itanium Processor-specific Application Binary Interface,
section 7.4.  As such, they depart from normal GCC practice by not using
the __builtin_ prefix and also by being overloaded so that they
work on multiple types.</p>
<p>The definition given in the Intel documentation allows only for the use of
the types <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">long</span></tt>, <tt class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt> or their unsigned
counterparts.  GCC allows any integral scalar or pointer type that is
1, 2, 4 or 8 bytes in length.</p>
<p>These functions are implemented in terms of the __atomic
builtins (__atomic Builtins).  They should not be used for new
code which should use the __atomic builtins instead.</p>
<p>Not all operations are supported by all target processors.  If a particular
operation cannot be implemented on the target processor, a warning is
generated and a call to an external function is generated.  The external
function carries the same name as the built-in version,
with an additional suffix
<span class="target" id="n">`n`</span> where <tt class="docutils literal"><span class="pre">n</span></tt> is the size of the data type.</p>
<p>In most cases, these built-in functions are considered a <em class="dfn">full barrier</em>.
That is,
no memory operand is moved across the operation, either forward or
backward.  Further, instructions are issued as necessary to prevent the
processor from speculating loads across the operation and from queuing stores
after the operation.</p>
<p>All of the routines are described in the Intel documentation to take
&#8216;an optional list of variables protected by the memory barrier&#8217;.  It&#8217;s
not clear what is meant by that; it could mean that only the
listed variables are protected, or it could mean a list of additional
variables to be protected.  The list is ignored by GCC which treats it as
empty.  GCC interprets an empty list as meaning that all globally
accessible variables should be protected.</p>
<p><tt class="docutils literal"><span class="pre">type</span></tt> __sync_fetch_and_add (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id1"><span class="problematic" id="id2">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)``type`` __sync_fetch_and_sub (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id3"><span class="problematic" id="id4">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)``type`` __sync_fetch_and_or (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id5"><span class="problematic" id="id6">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)``type`` __sync_fetch_and_and (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id7"><span class="problematic" id="id8">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)``type`` __sync_fetch_and_xor (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id9"><span class="problematic" id="id10">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)``type`` __sync_fetch_and_nand (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id11"><span class="problematic" id="id12">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)</p>
<blockquote>
<div><span class="target" id="index-0"></span><span class="target" id="index-1"></span><span class="target" id="index-2"></span><span class="target" id="index-3"></span><span class="target" id="index-4"></span><p id="index-5">These built-in functions perform the operation suggested by the name, and
returns the value that had previously been in memory.  That is,</p>
<div class="highlight-c++"><pre>{ tmp = *ptr; *ptr ``op``= value; return tmp; }
{ tmp = *ptr; *ptr = ~(tmp &amp; value); return tmp; }   // nand</pre>
</div>
<p>Note: GCC 4.4 and later implement <tt class="docutils literal"><span class="pre">__sync_fetch_and_nand</span></tt>
as <tt class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">~(tmp</span> <span class="pre">&amp;</span> <span class="pre">value)</span></tt> instead of <tt class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">~tmp</span> <span class="pre">&amp;</span> <span class="pre">value</span></tt>.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">type</span></tt> __sync_add_and_fetch (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id13"><span class="problematic" id="id14">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)``type`` __sync_sub_and_fetch (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id15"><span class="problematic" id="id16">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)``type`` __sync_or_and_fetch (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id17"><span class="problematic" id="id18">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)``type`` __sync_and_and_fetch (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id19"><span class="problematic" id="id20">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)``type`` __sync_xor_and_fetch (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id21"><span class="problematic" id="id22">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)``type`` __sync_nand_and_fetch (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id23"><span class="problematic" id="id24">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)</p>
<blockquote>
<div><span class="target" id="index-6"></span><span class="target" id="index-7"></span><span class="target" id="index-8"></span><span class="target" id="index-9"></span><span class="target" id="index-10"></span><p id="index-11">These built-in functions perform the operation suggested by the name, and
return the new value.  That is,</p>
<div class="highlight-c++"><pre>{ *ptr ``op``= value; return *ptr; }
{ *ptr = ~(*ptr &amp; value); return *ptr; }   // nand</pre>
</div>
<p>Note: GCC 4.4 and later implement <tt class="docutils literal"><span class="pre">__sync_nand_and_fetch</span></tt>
as <tt class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">~(*ptr</span> <span class="pre">&amp;</span> <span class="pre">value)</span></tt> instead of
<tt class="docutils literal"><span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">~*ptr</span> <span class="pre">&amp;</span> <span class="pre">value</span></tt>.</p>
</div></blockquote>
<p>bool __sync_bool_compare_and_swap (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id25"><span class="problematic" id="id26">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> oldval, <tt class="docutils literal"><span class="pre">type</span></tt> newval, ...)``type`` __sync_val_compare_and_swap (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id27"><span class="problematic" id="id28">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> oldval, <tt class="docutils literal"><span class="pre">type</span></tt> newval, ...)</p>
<blockquote>
<div><span class="target" id="index-12"></span><p id="index-13">These built-in functions perform an atomic compare and swap.
That is, if the current
value of <tt class="docutils literal"><span class="pre">*``ptr``</span></tt> is <tt class="docutils literal"><span class="pre">oldval</span></tt>, then write <tt class="docutils literal"><span class="pre">newval</span></tt> into
<tt class="docutils literal"><span class="pre">*``ptr``</span></tt>.</p>
<p>The &#8216;bool&#8217; version returns true if the comparison is successful and
<tt class="docutils literal"><span class="pre">newval</span></tt> is written.  The &#8216;val&#8217; version returns the contents
of <tt class="docutils literal"><span class="pre">*``ptr``</span></tt> before the operation.</p>
</div></blockquote>
<p>__sync_synchronize (...)</p>
<blockquote>
<div><p id="index-14">This built-in function issues a full memory barrier.</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">type</span></tt> __sync_lock_test_and_set (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id29"><span class="problematic" id="id30">*</span></a>ptr, <tt class="docutils literal"><span class="pre">type</span></tt> value, ...)</p>
<blockquote>
<div><p id="index-15">This built-in function, as described by Intel, is not a traditional test-and-set
operation, but rather an atomic exchange operation.  It writes <tt class="docutils literal"><span class="pre">value</span></tt>
into <tt class="docutils literal"><span class="pre">*``ptr``</span></tt>, and returns the previous contents of
<tt class="docutils literal"><span class="pre">*``ptr``</span></tt>.</p>
<p>Many targets have only minimal support for such locks, and do not support
a full exchange operation.  In this case, a target may support reduced
functionality here by which the only valid value to store is the
immediate constant 1.  The exact value actually stored in <tt class="docutils literal"><span class="pre">*``ptr``</span></tt>
is implementation defined.</p>
<p>This built-in function is not a full barrier,
but rather an <em class="dfn">acquire barrier</em>.
This means that references after the operation cannot move to (or be
speculated to) before the operation, but previous memory stores may not
be globally visible yet, and previous memory loads may not yet be
satisfied.</p>
</div></blockquote>
<p>void __sync_lock_release (<tt class="docutils literal"><span class="pre">type</span></tt> <a href="#id31"><span class="problematic" id="id32">*</span></a>ptr, ...)</p>
<blockquote>
<div><p id="index-16">This built-in function releases the lock acquired by
<tt class="docutils literal"><span class="pre">__sync_lock_test_and_set</span></tt>.
Normally this means writing the constant 0 to <tt class="docutils literal"><span class="pre">*``ptr``</span></tt>.</p>
<p>This built-in function is not a full barrier,
but rather a <em class="dfn">release barrier</em>.
This means that all previous memory stores are globally visible, and all
previous memory loads have been satisfied, but following memory reads
are not prevented from being speculated to before the barrier.</p>
</div></blockquote>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="built-in-functions-for-memory-model-aware-atomic-operations.html" title="Built-in Functions for Memory Model Aware Atomic Operations"
             >next</a> |</li>
        <li class="right" >
          <a href="support-for-offsetof.html" title="&lt;no title&gt;"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" >Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>