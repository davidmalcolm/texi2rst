

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Built-in Functions for Memory Model Aware Atomic Operations &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="Extensions to the C Language Family" href="extensions-to-the-c-language-family.html" />
    <link rel="next" title="Built-in Functions to Perform Arithmetic with Overflow Checking" href="built-in-functions-to-perform-arithmetic-with-overflow-checking.html" />
    <link rel="prev" title="&lt;no title&gt;" href="legacy-__sync-built-in-functions-for-atomic-memory-access.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="built-in-functions-to-perform-arithmetic-with-overflow-checking.html" title="Built-in Functions to Perform Arithmetic with Overflow Checking"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="legacy-__sync-built-in-functions-for-atomic-memory-access.html" title="&lt;no title&gt;"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" accesskey="U">Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="legacy-__sync-built-in-functions-for-atomic-memory-access.html"
                        title="previous chapter">&lt;no title&gt;</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="built-in-functions-to-perform-arithmetic-with-overflow-checking.html"
                        title="next chapter">Built-in Functions to Perform Arithmetic with Overflow Checking</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/built-in-functions-for-memory-model-aware-atomic-operations.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <blockquote>
<div></div></blockquote>
<div class="section" id="built-in-functions-for-memory-model-aware-atomic-operations">
<h1>Built-in Functions for Memory Model Aware Atomic Operations<a class="headerlink" href="#built-in-functions-for-memory-model-aware-atomic-operations" title="Permalink to this headline">Â¶</a></h1>
<p>The following built-in functions approximately match the requirements
for C++11 concurrency and memory models.  They are all
identified by being prefixed with __atomic and most are
overloaded so that they work with multiple types.</p>
<p>These functions are intended to replace the legacy __sync
builtins.  The main difference is that the memory model to be used is a
parameter to the functions.  New code should always use the
__atomic builtins rather than the __sync builtins.</p>
<p>Note that the __atomic builtins assume that programs will
conform to the C++11 model for concurrency.  In particular, they assume
that programs are free of data races.  See the C++11 standard for
detailed definitions.</p>
<p>The __atomic builtins can be used with any integral scalar or
pointer type that is 1, 2, 4, or 8 bytes in length.  16-byte integral
types are also allowed if __int128 (__int128) is
supported by the architecture.</p>
<p>The four non-arithmetic functions (load, store, exchange, and
compare_exchange) all have a generic version as well.  This generic
version works on any data type.  If the data type size maps to one
of the integral sizes that may have lock free support, the generic
version uses the lock free built-in function.  Otherwise an
external call is left to be resolved at run time.  This external call is
the same format with the addition of a size_t parameter inserted
as the first parameter indicating the size of the object being pointed to.
All objects must be the same size.</p>
<p>There are 6 different memory models that can be specified.  These map
to the C++11 memory models with the same names, see the C++11 standard
or the <a class="reference external" href="http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSyncGCC">http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSyncGCC</a> wiki
on atomic synchronization for detailed definitions.  Individual
targets may also support additional memory models for use on specific
architectures.  Refer to the target documentation for details of
these.</p>
<p>The memory models integrate both barriers to code motion as well as
synchronization requirements with other threads.  They are listed here
in approximately ascending order of strength.</p>
<dl class="docutils">
<dt>__ATOMIC_RELAXED</dt>
<dd>No barriers or synchronization.</dd>
<dt>__ATOMIC_CONSUME</dt>
<dd>Data dependency only for both barrier and synchronization with another
thread.</dd>
<dt>__ATOMIC_ACQUIRE</dt>
<dd>Barrier to hoisting of code and synchronizes with release (or stronger)
semantic stores from another thread.</dd>
<dt>__ATOMIC_RELEASE</dt>
<dd>Barrier to sinking of code and synchronizes with acquire (or stronger)
semantic loads from another thread.</dd>
<dt>__ATOMIC_ACQ_REL</dt>
<dd>Barrier in both directions and synchronizes with acquire loads and
release stores in another thread.</dd>
<dt>__ATOMIC_SEQ_CST</dt>
<dd><p class="first">Barrier in both directions and synchronizes with acquire loads and
release stores in all threads.</p>
<p class="last">Note that the scope of a C++11 memory model depends on whether or not</p>
</dd>
</dl>
<p>the function being called is a fence (such as
__atomic_thread_fence).  In a fence, all memory accesses are
subject to the restrictions of the memory model.  When the function is
an operation on a location, the restrictions apply only to those
memory accesses that could affect or that could depend on the
location.</p>
<p>Target architectures are encouraged to provide their own patterns for
each of these built-in functions.  If no target is provided, the original
non-memory model set of __sync atomic built-in functions are
used, along with any required synchronization fences surrounding it in
order to achieve the proper behavior.  Execution in this case is subject
to the same restrictions as those built-in functions.</p>
<p>If there is no pattern or mechanism to provide a lock free instruction
sequence, a call is made to an external routine with the same parameters
to be resolved at run time.</p>
<p>When implementing patterns for these built-in functions, the memory model
parameter can be ignored as long as the pattern implements the most
restrictive <tt class="docutils literal"><span class="pre">__ATOMIC_SEQ_CST</span></tt> model.  Any of the other memory models
execute correctly with this memory model but they may not execute as
efficiently as they could with a more appropriate implementation of the
relaxed requirements.</p>
<p>Note that the C++11 standard allows for the memory model parameter to be
determined at run time rather than at compile time.  These built-in
functions map any run-time value to <tt class="docutils literal"><span class="pre">__ATOMIC_SEQ_CST</span></tt> rather
than invoke a runtime library call or inline a switch statement.  This is
standard compliant, safe, and the simplest approach for now.</p>
<p>The memory model parameter is a signed int, but only the lower 16 bits are
reserved for the memory model.  The remainder of the signed int is reserved
for target use and should be 0.  Use of the predefined atomic values
ensures proper usage.</p>
<p id="index-0">Built-in Function``type``__atomic_load_n(<tt class="docutils literal"><span class="pre">type``*ptr,intmemmodel)This</span> <span class="pre">built-in</span> <span class="pre">function</span> <span class="pre">implements</span> <span class="pre">an</span> <span class="pre">atomic</span> <span class="pre">load</span> <span class="pre">operation.</span>&nbsp; <span class="pre">It</span> <span class="pre">returns</span> <span class="pre">the</span>
<span class="pre">contents</span> <span class="pre">of</span> <span class="pre">``*``ptr``</span></tt>.</p>
<p>The valid memory model variants are
<tt class="docutils literal"><span class="pre">__ATOMIC_RELAXED</span></tt>, <tt class="docutils literal"><span class="pre">__ATOMIC_SEQ_CST</span></tt>, <tt class="docutils literal"><span class="pre">__ATOMIC_ACQUIRE</span></tt>,
and <tt class="docutils literal"><span class="pre">__ATOMIC_CONSUME</span></tt>.</p>
<p id="index-1">Built-in Functionvoid__atomic_load(<tt class="docutils literal"><span class="pre">type``*ptr,``type``*ret,intmemmodel)This</span> <span class="pre">is</span> <span class="pre">the</span> <span class="pre">generic</span> <span class="pre">version</span> <span class="pre">of</span> <span class="pre">an</span> <span class="pre">atomic</span> <span class="pre">load.</span>&nbsp; <span class="pre">It</span> <span class="pre">returns</span> <span class="pre">the</span>
<span class="pre">contents</span> <span class="pre">of</span> <span class="pre">``*``ptr``</span></tt> in <tt class="docutils literal"><span class="pre">*``ret``</span></tt>.</p>
<p id="index-2">Built-in Functionvoid__atomic_store_n(<tt class="docutils literal"><span class="pre">type``*ptr,``type``val,intmemmodel)This</span> <span class="pre">built-in</span> <span class="pre">function</span> <span class="pre">implements</span> <span class="pre">an</span> <span class="pre">atomic</span> <span class="pre">store</span> <span class="pre">operation.</span>&nbsp; <span class="pre">It</span> <span class="pre">writes</span>
<span class="pre">````val``</span></tt> into <tt class="docutils literal"><span class="pre">*``ptr``</span></tt>.</p>
<p>The valid memory model variants are
<tt class="docutils literal"><span class="pre">__ATOMIC_RELAXED</span></tt>, <tt class="docutils literal"><span class="pre">__ATOMIC_SEQ_CST</span></tt>, and <tt class="docutils literal"><span class="pre">__ATOMIC_RELEASE</span></tt>.</p>
<p id="index-3">Built-in Functionvoid__atomic_store(<tt class="docutils literal"><span class="pre">type``*ptr,``type``*val,intmemmodel)This</span> <span class="pre">is</span> <span class="pre">the</span> <span class="pre">generic</span> <span class="pre">version</span> <span class="pre">of</span> <span class="pre">an</span> <span class="pre">atomic</span> <span class="pre">store.</span>&nbsp; <span class="pre">It</span> <span class="pre">stores</span> <span class="pre">the</span> <span class="pre">value</span>
<span class="pre">of</span> <span class="pre">``*``val``</span></tt> into <tt class="docutils literal"><span class="pre">*``ptr``</span></tt>.</p>
<p id="index-4">Built-in Function``type``__atomic_exchange_n(<tt class="docutils literal"><span class="pre">type``*ptr,``type``val,intmemmodel)This</span> <span class="pre">built-in</span> <span class="pre">function</span> <span class="pre">implements</span> <span class="pre">an</span> <span class="pre">atomic</span> <span class="pre">exchange</span> <span class="pre">operation.</span>&nbsp; <span class="pre">It</span> <span class="pre">writes</span>
<span class="pre">``val</span></tt> into <tt class="docutils literal"><span class="pre">*``ptr``</span></tt>, and returns the previous contents of
<tt class="docutils literal"><span class="pre">*``ptr``</span></tt>.</p>
<p>The valid memory model variants are
<tt class="docutils literal"><span class="pre">__ATOMIC_RELAXED</span></tt>, <tt class="docutils literal"><span class="pre">__ATOMIC_SEQ_CST</span></tt>, <tt class="docutils literal"><span class="pre">__ATOMIC_ACQUIRE</span></tt>,
<tt class="docutils literal"><span class="pre">__ATOMIC_RELEASE</span></tt>, and <tt class="docutils literal"><span class="pre">__ATOMIC_ACQ_REL</span></tt>.</p>
<p id="index-5">Built-in Functionvoid__atomic_exchange(<tt class="docutils literal"><span class="pre">type``*ptr,``type``*val,``type``*ret,intmemmodel)This</span> <span class="pre">is</span> <span class="pre">the</span> <span class="pre">generic</span> <span class="pre">version</span> <span class="pre">of</span> <span class="pre">an</span> <span class="pre">atomic</span> <span class="pre">exchange.</span>&nbsp; <span class="pre">It</span> <span class="pre">stores</span> <span class="pre">the</span>
<span class="pre">contents</span> <span class="pre">of</span> <span class="pre">``*``val``</span></tt> into <tt class="docutils literal"><span class="pre">*``ptr``</span></tt>. The original value
of <tt class="docutils literal"><span class="pre">*``ptr``</span></tt> is copied into <tt class="docutils literal"><span class="pre">*``ret``</span></tt>.</p>
<p id="index-6">Built-in Functionbool__atomic_compare_exchange_n(<tt class="docutils literal"><span class="pre">type``*ptr,``type``*expected,``type``desired,boolweak,intsuccess_memmodel,intfailure_memmodel)This</span> <span class="pre">built-in</span> <span class="pre">function</span> <span class="pre">implements</span> <span class="pre">an</span> <span class="pre">atomic</span> <span class="pre">compare</span> <span class="pre">and</span> <span class="pre">exchange</span> <span class="pre">operation.</span>
<span class="pre">This</span> <span class="pre">compares</span> <span class="pre">the</span> <span class="pre">contents</span> <span class="pre">of</span> <span class="pre">``*``ptr``</span></tt> with the contents of
<tt class="docutils literal"><span class="pre">*``expected``</span></tt>. If equal, the operation is a read-modify-write
which writes <tt class="docutils literal"><span class="pre">desired</span></tt> into <tt class="docutils literal"><span class="pre">*``ptr``</span></tt>.  If they are not
equal, the operation is a read and the current contents of
<tt class="docutils literal"><span class="pre">*``ptr``</span></tt> is written into <tt class="docutils literal"><span class="pre">*``expected``</span></tt>.  <tt class="docutils literal"><span class="pre">weak</span></tt> is true
for weak compare_exchange, and false for the strong variation.  Many targets
only offer the strong variation and ignore the parameter.  When in doubt, use
the strong variation.</p>
<p>True is returned if <tt class="docutils literal"><span class="pre">desired</span></tt> is written into
<tt class="docutils literal"><span class="pre">*``ptr``</span></tt> and the operation is considered to conform to the
memory model specified by <tt class="docutils literal"><span class="pre">success_memmodel</span></tt>.  There are no
restrictions on what memory model can be used here.</p>
<p>False is returned otherwise, and the operation is considered to conform
to <tt class="docutils literal"><span class="pre">failure_memmodel</span></tt>. This memory model cannot be
<tt class="docutils literal"><span class="pre">__ATOMIC_RELEASE</span></tt> nor <tt class="docutils literal"><span class="pre">__ATOMIC_ACQ_REL</span></tt>.  It also cannot be a
stronger model than that specified by <tt class="docutils literal"><span class="pre">success_memmodel</span></tt>.</p>
<p id="index-7">Built-in Functionbool__atomic_compare_exchange(<tt class="docutils literal"><span class="pre">type``*ptr,``type``*expected,``type``*desired,boolweak,intsuccess_memmodel,intfailure_memmodel)This</span> <span class="pre">built-in</span> <span class="pre">function</span> <span class="pre">implements</span> <span class="pre">the</span> <span class="pre">generic</span> <span class="pre">version</span> <span class="pre">of</span>
<span class="pre">``__atomic_compare_exchange</span></tt>.  The function is virtually identical to
<tt class="docutils literal"><span class="pre">__atomic_compare_exchange_n</span></tt>, except the desired value is also a
pointer.</p>
<p id="index-8">Built-in Function``type``__atomic_add_fetch(<a href="#id1"><span class="problematic" id="id2">``</span></a>type``*ptr,``type``val,intmemmodel)
.. index:: __atomic_sub_fetch</p>
<p>Built-in Function``type``__atomic_sub_fetch(<a href="#id3"><span class="problematic" id="id4">``</span></a>type``*ptr,``type``val,intmemmodel)
.. index:: __atomic_and_fetch</p>
<p>Built-in Function``type``__atomic_and_fetch(<a href="#id5"><span class="problematic" id="id6">``</span></a>type``*ptr,``type``val,intmemmodel)
.. index:: __atomic_xor_fetch</p>
<p>Built-in Function``type``__atomic_xor_fetch(<a href="#id7"><span class="problematic" id="id8">``</span></a>type``*ptr,``type``val,intmemmodel)
.. index:: __atomic_or_fetch</p>
<p>Built-in Function``type``__atomic_or_fetch(<a href="#id9"><span class="problematic" id="id10">``</span></a>type``*ptr,``type``val,intmemmodel)
.. index:: __atomic_nand_fetch</p>
<p>Built-in Function``type``__atomic_nand_fetch(<a href="#id11"><span class="problematic" id="id12">``</span></a>type``*ptr,``type``val,intmemmodel)These built-in functions perform the operation suggested by the name, and
return the result of the operation. That is,</p>
<div class="highlight-c++"><pre>{ *ptr ``op``= val; return *ptr; }</pre>
</div>
<p>All memory models are valid.</p>
<p id="index-9">Built-in Function``type``__atomic_fetch_add(<a href="#id13"><span class="problematic" id="id14">``</span></a>type``*ptr,``type``val,intmemmodel)
.. index:: __atomic_fetch_sub</p>
<p>Built-in Function``type``__atomic_fetch_sub(<a href="#id15"><span class="problematic" id="id16">``</span></a>type``*ptr,``type``val,intmemmodel)
.. index:: __atomic_fetch_and</p>
<p>Built-in Function``type``__atomic_fetch_and(<a href="#id17"><span class="problematic" id="id18">``</span></a>type``*ptr,``type``val,intmemmodel)
.. index:: __atomic_fetch_xor</p>
<p>Built-in Function``type``__atomic_fetch_xor(<a href="#id19"><span class="problematic" id="id20">``</span></a>type``*ptr,``type``val,intmemmodel)
.. index:: __atomic_fetch_or</p>
<p>Built-in Function``type``__atomic_fetch_or(<a href="#id21"><span class="problematic" id="id22">``</span></a>type``*ptr,``type``val,intmemmodel)
.. index:: __atomic_fetch_nand</p>
<p>Built-in Function``type``__atomic_fetch_nand(<tt class="docutils literal"><span class="pre">type``*ptr,``type``val,intmemmodel)These</span> <span class="pre">built-in</span> <span class="pre">functions</span> <span class="pre">perform</span> <span class="pre">the</span> <span class="pre">operation</span> <span class="pre">suggested</span> <span class="pre">by</span> <span class="pre">the</span> <span class="pre">name,</span> <span class="pre">and</span>
<span class="pre">return</span> <span class="pre">the</span> <span class="pre">value</span> <span class="pre">that</span> <span class="pre">had</span> <span class="pre">previously</span> <span class="pre">been</span> <span class="pre">in</span> <span class="pre">``*``ptr``</span></tt>.  That is,</p>
<div class="highlight-c++"><pre>{ tmp = *ptr; *ptr ``op``= val; return tmp; }</pre>
</div>
<p>All memory models are valid.</p>
<p id="index-10">Built-in Functionbool__atomic_test_and_set(void*ptr,intmemmodel)This built-in function performs an atomic test-and-set operation on
the byte at <tt class="docutils literal"><span class="pre">*``ptr``</span></tt>.  The byte is set to some implementation
defined nonzero &#8216;set&#8217; value and the return value is <tt class="docutils literal"><span class="pre">true</span></tt> if and only
if the previous contents were &#8216;set&#8217;.
It should be only used for operands of type <tt class="docutils literal"><span class="pre">bool</span></tt> or <tt class="docutils literal"><span class="pre">char</span></tt>. For
other types only part of the value may be set.</p>
<p>All memory models are valid.</p>
<p id="index-11">Built-in Functionvoid__atomic_clear(bool*ptr,intmemmodel)This built-in function performs an atomic clear operation on
<tt class="docutils literal"><span class="pre">*``ptr``</span></tt>.  After the operation, <tt class="docutils literal"><span class="pre">*``ptr``</span></tt> contains 0.
It should be only used for operands of type <tt class="docutils literal"><span class="pre">bool</span></tt> or <tt class="docutils literal"><span class="pre">char</span></tt> and
in conjunction with <tt class="docutils literal"><span class="pre">__atomic_test_and_set</span></tt>.
For other types it may only clear partially. If the type is not <tt class="docutils literal"><span class="pre">bool</span></tt>
prefer using <tt class="docutils literal"><span class="pre">__atomic_store</span></tt>.</p>
<p>The valid memory model variants are
<tt class="docutils literal"><span class="pre">__ATOMIC_RELAXED</span></tt>, <tt class="docutils literal"><span class="pre">__ATOMIC_SEQ_CST</span></tt>, and
<tt class="docutils literal"><span class="pre">__ATOMIC_RELEASE</span></tt>.</p>
<p id="index-12">Built-in Functionvoid__atomic_thread_fence(intmemmodel)This built-in function acts as a synchronization fence between threads
based on the specified memory model.</p>
<p>All memory orders are valid.</p>
<p id="index-13">Built-in Functionvoid__atomic_signal_fence(intmemmodel)This built-in function acts as a synchronization fence between a thread
and signal handlers based in the same thread.</p>
<p>All memory orders are valid.</p>
<p id="index-14">Built-in Functionbool__atomic_always_lock_free(size_tsize,void*ptr)This built-in function returns true if objects of <tt class="docutils literal"><span class="pre">size</span></tt> bytes always
generate lock free atomic instructions for the target architecture.
<tt class="docutils literal"><span class="pre">size</span></tt> must resolve to a compile-time constant and the result also
resolves to a compile-time constant.</p>
<p><tt class="docutils literal"><span class="pre">ptr</span></tt> is an optional pointer to the object that may be used to determine
alignment.  A value of 0 indicates typical alignment should be used.  The
compiler may also ignore this parameter.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">_atomic_always_lock_free</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p id="index-15">Built-in Functionbool__atomic_is_lock_free(size_tsize,void*ptr)This built-in function returns true if objects of <tt class="docutils literal"><span class="pre">size</span></tt> bytes always
generate lock free atomic instructions for the target architecture.  If
it is not known to be lock free a call is made to a runtime routine named
<tt class="docutils literal"><span class="pre">__atomic_is_lock_free</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">ptr</span></tt> is an optional pointer to the object that may be used to determine
alignment.  A value of 0 indicates typical alignment should be used.  The
compiler may also ignore this parameter.</p>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="built-in-functions-to-perform-arithmetic-with-overflow-checking.html" title="Built-in Functions to Perform Arithmetic with Overflow Checking"
             >next</a> |</li>
        <li class="right" >
          <a href="legacy-__sync-built-in-functions-for-atomic-memory-access.html" title="&lt;no title&gt;"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" >Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>