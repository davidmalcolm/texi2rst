

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Specifying Attributes of Types &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="Extensions to the C Language Family" href="extensions-to-the-c-language-family.html" />
    <link rel="next" title="Label Attributes" href="label-attributes.html" />
    <link rel="prev" title="Specifying Attributes of Variables" href="specifying-attributes-of-variables.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="label-attributes.html" title="Label Attributes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="specifying-attributes-of-variables.html" title="Specifying Attributes of Variables"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" accesskey="U">Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Specifying Attributes of Types</a><ul>
<li><a class="reference internal" href="#common-type-attributes">Common Type Attributes</a></li>
<li><a class="reference internal" href="#arm-type-attributes">ARM Type Attributes</a></li>
<li><a class="reference internal" href="#mep-type-attributes">MeP Type Attributes</a></li>
<li><a class="reference internal" href="#powerpc-type-attributes">PowerPC Type Attributes</a></li>
<li><a class="reference internal" href="#spu-type-attributes">SPU Type Attributes</a></li>
<li><a class="reference internal" href="#x86-type-attributes">x86 Type Attributes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="specifying-attributes-of-variables.html"
                        title="previous chapter">Specifying Attributes of Variables</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="label-attributes.html"
                        title="next chapter">Label Attributes</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/specifying-attributes-of-types.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="specifying-attributes-of-types">
<h1>Specifying Attributes of Types<a class="headerlink" href="#specifying-attributes-of-types" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><p id="index-1">The keyword <tt class="docutils literal"><span class="pre">__attribute__</span></tt> allows you to specify special
attributes of types.  Some type attributes apply only to <tt class="docutils literal"><span class="pre">struct</span></tt>
and <tt class="docutils literal"><span class="pre">union</span></tt> types, while others can apply to any type defined
via a <tt class="docutils literal"><span class="pre">typedef</span></tt> declaration.  Other attributes are defined for
functions (Function Attributes), labels (Label
Attributes) and for variables (Variable Attributes).</p>
<p>The <tt class="docutils literal"><span class="pre">__attribute__</span></tt> keyword is followed by an attribute specification
inside double parentheses.</p>
<p>You may specify type attributes in an enum, struct or union type
declaration or definition by placing them immediately after the
<tt class="docutils literal"><span class="pre">struct</span></tt>, <tt class="docutils literal"><span class="pre">union</span></tt> or <tt class="docutils literal"><span class="pre">enum</span></tt> keyword.  A less preferred
syntax is to place them just past the closing curly brace of the
definition.</p>
<p>You can also include type attributes in a <tt class="docutils literal"><span class="pre">typedef</span></tt> declaration.
Attribute Syntax, for details of the exact syntax for using
attributes.</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<p>:: _common-type-attributes:</p>
<div class="section" id="common-type-attributes">
<h2>Common Type Attributes<a class="headerlink" href="#common-type-attributes" title="Permalink to this headline">¶</a></h2>
<p>The following type attributes are supported on most targets.</p>
<p><tt class="docutils literal"><span class="pre">aligned</span></tt> type attribute
.. option:: aligned (alignment), -fshort-enums</p>
<blockquote>
<div><p>This attribute specifies a minimum alignment (in bytes) for variables
of the specified type.  For example, the declarations:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="kt">short</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">more_aligned_int</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
</pre></div>
</div>
<p>force the compiler to ensure (as far as it can) that each variable whose
type is <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">S</span></tt> or <tt class="docutils literal"><span class="pre">more_aligned_int</span></tt> is allocated and
aligned at least on a 8-byte boundary.  On a SPARC, having all
variables of type <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">S</span></tt> aligned to 8-byte boundaries allows
the compiler to use the <tt class="docutils literal"><span class="pre">ldd</span></tt> and <tt class="docutils literal"><span class="pre">std</span></tt> (doubleword load and
store) instructions when copying one variable of type <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">S</span></tt> to
another, thus improving run-time efficiency.</p>
<p>Note that the alignment of any given <tt class="docutils literal"><span class="pre">struct</span></tt> or <tt class="docutils literal"><span class="pre">union</span></tt> type
is required by the ISO C standard to be at least a perfect multiple of
the lowest common multiple of the alignments of all of the members of
the <tt class="docutils literal"><span class="pre">struct</span></tt> or <tt class="docutils literal"><span class="pre">union</span></tt> in question.  This means that you can
effectively adjust the alignment of a <tt class="docutils literal"><span class="pre">struct</span></tt> or <tt class="docutils literal"><span class="pre">union</span></tt>
type by attaching an <tt class="docutils literal"><span class="pre">aligned</span></tt> attribute to any one of the members
of such a type, but the notation illustrated in the example above is a
more obvious, intuitive, and readable way to request the compiler to
adjust the alignment of an entire <tt class="docutils literal"><span class="pre">struct</span></tt> or <tt class="docutils literal"><span class="pre">union</span></tt> type.</p>
<p>As in the preceding example, you can explicitly specify the alignment
(in bytes) that you wish the compiler to use for a given <tt class="docutils literal"><span class="pre">struct</span></tt>
or <tt class="docutils literal"><span class="pre">union</span></tt> type.  Alternatively, you can leave out the alignment factor
and just ask the compiler to align a type to the maximum
useful alignment for the target machine you are compiling for.  For
example, you could write:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="kt">short</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">));</span>
</pre></div>
</div>
<p>Whenever you leave out the alignment factor in an <tt class="docutils literal"><span class="pre">aligned</span></tt>
attribute specification, the compiler automatically sets the alignment
for the type to the largest alignment that is ever used for any data
type on the target machine you are compiling for.  Doing this can often
make copy operations more efficient, because the compiler can use
whatever instructions copy the biggest chunks of memory when performing
copies to or from the variables that have types that you have aligned
this way.</p>
<p>In the example above, if the size of each <tt class="docutils literal"><span class="pre">short</span></tt> is 2 bytes, then
the size of the entire <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">S</span></tt> type is 6 bytes.  The smallest
power of two that is greater than or equal to that is 8, so the
compiler sets the alignment for the entire <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">S</span></tt> type to 8
bytes.</p>
<p>Note that although you can ask the compiler to select a time-efficient
alignment for a given type and then declare only individual stand-alone
objects of that type, the compiler&#8217;s ability to select a time-efficient
alignment is primarily useful only when you plan to create arrays of
variables having the relevant (efficiently aligned) type.  If you
declare or use arrays of variables of an efficiently-aligned type, then
it is likely that your program also does pointer arithmetic (or
subscripting, which amounts to the same thing) on pointers to the
relevant type, and the code that the compiler generates for these
pointer arithmetic operations is often more efficient for
efficiently-aligned types than for other types.</p>
<p>The <tt class="docutils literal"><span class="pre">aligned</span></tt> attribute can only increase the alignment; but you
can decrease it by specifying <tt class="docutils literal"><span class="pre">packed</span></tt> as well.  See below.</p>
<p>Note that the effectiveness of <tt class="docutils literal"><span class="pre">aligned</span></tt> attributes may be limited
by inherent limitations in your linker.  On many systems, the linker is
only able to arrange for variables to be aligned up to a certain maximum
alignment.  (For some linkers, the maximum supported alignment may
be very very small.)  If your linker is only able to align variables
up to a maximum of 8-byte alignment, then specifying <tt class="docutils literal"><span class="pre">aligned(16)</span></tt>
in an <tt class="docutils literal"><span class="pre">__attribute__</span></tt> still only provides you with 8-byte
alignment.  See your linker documentation for further information.</p>
<p>Specifying this attribute for <tt class="docutils literal"><span class="pre">struct</span></tt> and <tt class="docutils literal"><span class="pre">union</span></tt> types is
equivalent to specifying the <tt class="docutils literal"><span class="pre">packed</span></tt> attribute on each of the
structure or union members.  Specifying the <a class="reference internal" href="options-for-code-generation-conventions.html#cmdoption-fshort-enums"><em class="xref std std-option">-fshort-enums</em></a>
flag on the line is equivalent to specifying the <tt class="docutils literal"><span class="pre">packed</span></tt>
attribute on all <tt class="docutils literal"><span class="pre">enum</span></tt> definitions.</p>
<p>In the following example <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">my_packed_struct</span></tt>&#8216;s members are
packed closely together, but the internal layout of its <tt class="docutils literal"><span class="pre">s</span></tt> member
is not packed-to do that, <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">my_unpacked_struct</span></tt> needs to
be packed too.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">my_unpacked_struct</span>
 <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
 <span class="p">};</span>

<span class="k">struct</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">my_packed_struct</span>
  <span class="p">{</span>
     <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
     <span class="kt">int</span>  <span class="n">i</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">my_unpacked_struct</span> <span class="n">s</span><span class="p">;</span>
  <span class="p">};</span>
</pre></div>
</div>
<p>You may only specify this attribute on the definition of an <tt class="docutils literal"><span class="pre">enum</span></tt>,
<tt class="docutils literal"><span class="pre">struct</span></tt> or <tt class="docutils literal"><span class="pre">union</span></tt>, not on a <tt class="docutils literal"><span class="pre">typedef</span></tt> that does not
also define the enumerated type, structure or union.</p>
</div></blockquote>
<dl class="docutils">
<dt>bnd_variable_size</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">bnd_variable_size</span></tt> type attribute
.. index:: Pointer Bounds Checker attributes</p>
<p>When applied to a structure field, this attribute tells Pointer
Bounds Checker that the size of this field should not be computed
using static type information.  It may be used to mark variably-sized
static array fields placed at the end of a structure.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">S</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">+</span> <span class="mi">100</span><span class="p">);</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//Bounds violation</span>
</pre></div>
</div>
<p>By using an attribute for the field we may avoid unwanted bound
violation checks:</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">bnd_variable_size</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">S</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">+</span> <span class="mi">100</span><span class="p">);</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//OK</span>
</pre></div>
</div>
</dd>
<dt>deprecated deprecated (<tt class="docutils literal"><span class="pre">msg</span></tt>)</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">deprecated</span></tt> type attributeThe <tt class="docutils literal"><span class="pre">deprecated</span></tt> attribute results in a warning if the type
is used anywhere in the source file.  This is useful when identifying
types that are expected to be removed in a future version of a program.
If possible, the warning also includes the location of the declaration
of the deprecated type, to enable users to easily find further
information about why the type is deprecated, or what they should do
instead.  Note that the warnings only occur for uses and then only
if the type is being applied to an identifier that itself is not being
declared as deprecated.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="n">T1</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">deprecated</span><span class="p">));</span>
<span class="n">T1</span> <span class="n">x</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">T1</span> <span class="n">T2</span><span class="p">;</span>
<span class="n">T2</span> <span class="n">y</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">T1</span> <span class="n">T3</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">deprecated</span><span class="p">));</span>
<span class="n">T3</span> <span class="n">z</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">deprecated</span><span class="p">));</span>
</pre></div>
</div>
<p>results in a warning on line 2 and 3 but not lines 4, 5, or 6.  No
warning is issued for line 4 because T2 is not explicitly
deprecated.  Line 5 has no warning because T3 is explicitly
deprecated.  Similarly for line 6.  The optional <tt class="docutils literal"><span class="pre">msg</span></tt>
argument, which must be a string, is printed in the warning if
present.</p>
<p class="last">The <tt class="docutils literal"><span class="pre">deprecated</span></tt> attribute can also be used for functions and
variables (Function Attributes, Variable Attributes.)</p>
</dd>
<dt>designated_init</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">designated_init</span></tt> type attributeThis attribute may only be applied to structure types.  It indicates
that any initialization of an object of this type must use designated
initializers rather than positional initializers.  The intent of this
attribute is to allow the programmer to indicate that a structure&#8217;s
layout may change, and that therefore relying on positional
initialization will result in future breakage.</p>
<p class="last">GCC emits warnings based on this attribute by default; use
<em class="xref std std-option">-Wno-designated-init</em> to suppress them.</p>
</dd>
<dt>may_alias</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">may_alias</span></tt> type attributeAccesses through pointers to types with this attribute are not subject
to type-based alias analysis, but are instead assumed to be able to alias
any other type of objects.
In the context of section 6.5 paragraph 7 of the C99 standard,
an lvalue expression
dereferencing such a pointer is treated like having a character type.
See <a class="reference internal" href="options-that-control-optimization.html#cmdoption-fstrict-aliasing"><em class="xref std std-option">-fstrict-aliasing</em></a> for more information on aliasing issues.
This extension exists to support some vector APIs, in which pointers to
one vector type are permitted to alias pointers to a different vector type.</p>
<p>Note that an object of a type with this attribute does not have any
special semantics.</p>
<p>Example of use:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">short</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__may_alias__</span><span class="p">))</span> <span class="n">short_a</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
  <span class="n">short_a</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">short_a</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

  <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mh">0x12345678</span><span class="p">)</span>
    <span class="n">abort</span><span class="p">();</span>

  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="last">If you replaced <tt class="docutils literal"><span class="pre">short_a</span></tt> with <tt class="docutils literal"><span class="pre">short</span></tt> in the variable
declaration, the above program would abort when compiled with
<a class="reference internal" href="options-that-control-optimization.html#cmdoption-fstrict-aliasing"><em class="xref std std-option">-fstrict-aliasing</em></a>, which is on by default at <a class="reference internal" href="options-that-control-optimization.html#cmdoption-O2"><em class="xref std std-option">-O2</em></a> or
above.</p>
</dd>
<dt>packed</dt>
<dd><tt class="docutils literal"><span class="pre">packed</span></tt> type attributeThis attribute, attached to <tt class="docutils literal"><span class="pre">struct</span></tt> or <tt class="docutils literal"><span class="pre">union</span></tt> type
definition, specifies that each member (other than zero-width bit-fields)
of the structure or union is placed to minimize the memory required.  When
attached to an <tt class="docutils literal"><span class="pre">enum</span></tt> definition, it indicates that the smallest
integral type should be used.</dd>
<dt>transparent_union</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">transparent_union</span></tt> type attributeThis attribute, attached to a <tt class="docutils literal"><span class="pre">union</span></tt> type definition, indicates
that any function parameter having that union type causes calls to that
function to be treated in a special way.</p>
<p>First, the argument corresponding to a transparent union type can be of
any type in the union; no cast is required.  Also, if the union contains
a pointer type, the corresponding argument can be a null pointer
constant or a void pointer expression; and if the union contains a void
pointer type, the corresponding argument can be any pointer expression.
If the union member type is a pointer, qualifiers like <tt class="docutils literal"><span class="pre">const</span></tt> on
the referenced type must be respected, just as with normal pointer
conversions.</p>
<p>Second, the argument is passed to the function using the calling
conventions of the first member of the transparent union, not the calling
conventions of the union itself.  All members of the union must have the
same machine representation; this is necessary for this argument passing
to work properly.</p>
<p>Transparent unions are designed for library functions that have multiple
interfaces for compatibility reasons.  For example, suppose the
<tt class="docutils literal"><span class="pre">wait</span></tt> function must accept either a value of type <tt class="docutils literal"><span class="pre">int</span> <span class="pre">*</span></tt> to
comply with POSIX, or a value of type <tt class="docutils literal"><span class="pre">union</span> <span class="pre">wait</span> <span class="pre">*</span></tt> to comply with
the 4.1BSD interface.  If <tt class="docutils literal"><span class="pre">wait</span></tt>&#8216;s parameter were <tt class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt>,
<tt class="docutils literal"><span class="pre">wait</span></tt> would accept both kinds of arguments, but it would also
accept any other pointer type and this would make argument type checking
less useful.  Instead, <tt class="docutils literal"><span class="pre">&lt;sys/wait.h&gt;</span></tt> might define the interface
as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">union</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__transparent_union__</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">__ip</span><span class="p">;</span>
    <span class="k">union</span> <span class="n">wait</span> <span class="o">*</span><span class="n">__up</span><span class="p">;</span>
  <span class="p">}</span> <span class="kt">wait_status_ptr_t</span><span class="p">;</span>

<span class="kt">pid_t</span> <span class="nf">wait</span> <span class="p">(</span><span class="kt">wait_status_ptr_t</span><span class="p">);</span>
</pre></div>
</div>
<p>This interface allows either <tt class="docutils literal"><span class="pre">int</span> <span class="pre">*</span></tt> or <tt class="docutils literal"><span class="pre">union</span> <span class="pre">wait</span> <span class="pre">*</span></tt>
arguments to be passed, using the <tt class="docutils literal"><span class="pre">int</span> <span class="pre">*</span></tt> calling convention.
The program can call <tt class="docutils literal"><span class="pre">wait</span></tt> with arguments of either type:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">w1</span> <span class="p">()</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">w</span><span class="p">;</span> <span class="k">return</span> <span class="n">wait</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">w2</span> <span class="p">()</span> <span class="p">{</span> <span class="k">union</span> <span class="n">wait</span> <span class="n">w</span><span class="p">;</span> <span class="k">return</span> <span class="n">wait</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<p>With this interface, <tt class="docutils literal"><span class="pre">wait</span></tt>&#8216;s implementation might look like this:</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="kt">pid_t</span> <span class="nf">wait</span> <span class="p">(</span><span class="kt">wait_status_ptr_t</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">waitpid</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">__ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>unused</dt>
<dd><tt class="docutils literal"><span class="pre">unused</span></tt> type attributeWhen attached to a type (including a <tt class="docutils literal"><span class="pre">union</span></tt> or a <tt class="docutils literal"><span class="pre">struct</span></tt>),
this attribute means that variables of that type are meant to appear
possibly unused.  GCC does not produce a warning for any variables of
that type, even if the variable appears to do nothing.  This is often
the case with lock or thread classes, which are usually defined and then
not referenced, but contain constructors and destructors that have
nontrivial bookkeeping functions.</dd>
<dt>visibility</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">visibility</span></tt> type attributeIn C++, attribute visibility (Function Attributes) can also be
applied to class, struct, union and enum types.  Unlike other type
attributes, the attribute must appear between the initial keyword and
the name of the type; it cannot appear after the body of the type.</p>
<p>Note that the type visibility is applied to vague linkage entities
associated with the class (vtable, typeinfo node, etc.).  In
particular, if a class is thrown as an exception in one shared object
and caught in another, the class must have default visibility.
Otherwise the two shared objects are unable to use the same
typeinfo node and exception handling will break.</p>
<p class="last">To specify multiple attributes, separate them by commas within the</p>
</dd>
</dl>
<p>double parentheses: for example, __attribute__ ((aligned (16),
packed)).</p>
<p>:: _arm-type-attributes:</p>
</div>
<div class="section" id="arm-type-attributes">
<h2>ARM Type Attributes<a class="headerlink" href="#arm-type-attributes" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">notshared</span></tt> type attribute, ARMOn those ARM targets that support <tt class="docutils literal"><span class="pre">dllimport</span></tt> (such as Symbian
OS), you can use the <tt class="docutils literal"><span class="pre">notshared</span></tt> attribute to indicate that the
virtual table and other similar data for a class should not be
exported from a DLL.  For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">notshared</span><span class="p">)</span> <span class="n">C</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span> <span class="n">C</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">();</span>
<span class="p">}</span>

<span class="kr">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span>
<span class="n">C</span><span class="o">::</span><span class="n">C</span><span class="p">()</span> <span class="p">{}</span>
</pre></div>
</div>
<p>In this code, <tt class="docutils literal"><span class="pre">C::C</span></tt> is exported from the current DLL, but the
virtual table for <tt class="docutils literal"><span class="pre">C</span></tt> is not exported.  (You can use
<tt class="docutils literal"><span class="pre">__attribute__</span></tt> instead of <tt class="docutils literal"><span class="pre">__declspec</span></tt> if you prefer, but
most Symbian OS code uses <tt class="docutils literal"><span class="pre">__declspec</span></tt>.)</p>
<p>:: _mep-type-attributes:</p>
</div>
<div class="section" id="mep-type-attributes">
<h2>MeP Type Attributes<a class="headerlink" href="#mep-type-attributes" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">based</span></tt> type attribute, MeP``tiny`` type attribute, MeP``near`` type attribute, MeP``far`` type attribute, MePMany of the MeP variable attributes may be applied to types as well.
Specifically, the <tt class="docutils literal"><span class="pre">based</span></tt>, <tt class="docutils literal"><span class="pre">tiny</span></tt>, <tt class="docutils literal"><span class="pre">near</span></tt>, and
<tt class="docutils literal"><span class="pre">far</span></tt> attributes may be applied to either.  The <tt class="docutils literal"><span class="pre">io</span></tt> and
<tt class="docutils literal"><span class="pre">cb</span></tt> attributes may not be applied to types.</p>
<p>:: _powerpc-type-attributes:</p>
</div>
<div class="section" id="powerpc-type-attributes">
<h2>PowerPC Type Attributes<a class="headerlink" href="#powerpc-type-attributes" title="Permalink to this headline">¶</a></h2>
<p>Three attributes currently are defined for PowerPC configurations:
<tt class="docutils literal"><span class="pre">altivec</span></tt>, <tt class="docutils literal"><span class="pre">ms_struct</span></tt> and <tt class="docutils literal"><span class="pre">gcc_struct</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">ms_struct</span></tt> type attribute, PowerPC``gcc_struct`` type attribute, PowerPCFor full documentation of the <tt class="docutils literal"><span class="pre">ms_struct</span></tt> and <tt class="docutils literal"><span class="pre">gcc_struct</span></tt>
attributes please see the documentation in x86 Type Attributes.</p>
<p><tt class="docutils literal"><span class="pre">altivec</span></tt> type attribute, PowerPCThe <tt class="docutils literal"><span class="pre">altivec</span></tt> attribute allows one to declare AltiVec vector data
types supported by the AltiVec Programming Interface Manual.  The
attribute requires an argument to specify one of three vector types:
<tt class="docutils literal"><span class="pre">vector__</span></tt>, <tt class="docutils literal"><span class="pre">pixel__</span></tt> (always followed by unsigned short),
and <tt class="docutils literal"><span class="pre">bool__</span></tt> (always followed by unsigned).</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">__attribute__</span><span class="p">((</span><span class="n">altivec</span><span class="p">(</span><span class="n">vector__</span><span class="p">)))</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">altivec</span><span class="p">(</span><span class="n">pixel__</span><span class="p">)))</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">altivec</span><span class="p">(</span><span class="n">bool__</span><span class="p">)))</span> <span class="kt">unsigned</span>
</pre></div>
</div>
<p>These attributes mainly are intended to support the <tt class="docutils literal"><span class="pre">__vector</span></tt>,
<tt class="docutils literal"><span class="pre">__pixel</span></tt>, and <tt class="docutils literal"><span class="pre">__bool</span></tt> AltiVec keywords.</p>
<p>:: _spu-type-attributes:</p>
</div>
<div class="section" id="spu-type-attributes">
<h2>SPU Type Attributes<a class="headerlink" href="#spu-type-attributes" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">spu_vector</span></tt> type attribute, SPUThe SPU supports the <tt class="docutils literal"><span class="pre">spu_vector</span></tt> attribute for types.  This attribute
allows one to declare vector data types supported by the Sony/Toshiba/IBM SPU
Language Extensions Specification.  It is intended to support the
<tt class="docutils literal"><span class="pre">__vector</span></tt> keyword.</p>
<p>:: _x86-type-attributes:</p>
</div>
<div class="section" id="x86-type-attributes">
<h2>x86 Type Attributes<a class="headerlink" href="#x86-type-attributes" title="Permalink to this headline">¶</a></h2>
<p>Two attributes are currently defined for x86 configurations:
<tt class="docutils literal"><span class="pre">ms_struct</span></tt> and <tt class="docutils literal"><span class="pre">gcc_struct</span></tt>.</p>
<dl class="docutils">
<dt>ms_struct gcc_struct</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">ms_struct</span></tt> type attribute, x86``gcc_struct`` type attribute, x86If <tt class="docutils literal"><span class="pre">packed</span></tt> is used on a structure, or if bit-fields are used
it may be that the Microsoft ABI packs them differently
than GCC normally packs them.  Particularly when moving packed
data between functions compiled with GCC and the native Microsoft compiler
(either via function call or as data in a file), it may be necessary to access
either format.</p>
<p class="last">Currently <em class="xref std std-option">-m[no-]ms-bitfields</em> is provided for the Microsoft Windows x86
compilers to match the native Microsoft compiler.</p>
</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="label-attributes.html" title="Label Attributes"
             >next</a> |</li>
        <li class="right" >
          <a href="specifying-attributes-of-variables.html" title="Specifying Attributes of Variables"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" >Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>