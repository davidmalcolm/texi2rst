

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>How to Use Inline Assembly Language in C Code &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="Extensions to the C Language Family" href="extensions-to-the-c-language-family.html" />
    <link rel="next" title="Alternate Keywords" href="alternate-keywords.html" />
    <link rel="prev" title="When is a Volatile Object Accessed?" href="when-is-a-volatile-object-accessed?.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="alternate-keywords.html" title="Alternate Keywords"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="when-is-a-volatile-object-accessed?.html" title="When is a Volatile Object Accessed?"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" accesskey="U">Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">How to Use Inline Assembly Language in C Code</a><ul>
<li><a class="reference internal" href="#basic-asm-assembler-instructions-without-operands">Basic Asm - Assembler Instructions Without Operands</a></li>
<li><a class="reference internal" href="#qualifiers">Qualifiers</a></li>
<li><a class="reference internal" href="#parameters">Parameters</a></li>
<li><a class="reference internal" href="#remarks">Remarks</a></li>
<li><a class="reference internal" href="#extended-asm-assembler-instructions-with-c-expression-operands">Extended Asm - Assembler Instructions with C Expression Operands</a></li>
<li><a class="reference internal" href="#id1">Qualifiers</a></li>
<li><a class="reference internal" href="#id2">Parameters</a></li>
<li><a class="reference internal" href="#id3">Remarks</a><ul>
<li><a class="reference internal" href="#volatile">Volatile</a></li>
<li><a class="reference internal" href="#assembler-template">Assembler Template</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-format-strings">Special format strings</a><ul>
<li><a class="reference internal" href="#output-operands">Output Operands</a></li>
<li><a class="reference internal" href="#input-operands">Input Operands</a></li>
<li><a class="reference internal" href="#clobbers">Clobbers</a></li>
<li><a class="reference internal" href="#goto-labels">Goto Labels</a></li>
<li><a class="reference internal" href="#x86-operand-modifiers">x86 Operand Modifiers</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#simple-constraints">Simple Constraints</a></li>
<li><a class="reference internal" href="#multiple-alternative-constraints">Multiple Alternative Constraints</a></li>
<li><a class="reference internal" href="#constraint-modifier-characters">Constraint Modifier Characters</a></li>
<li><a class="reference internal" href="#constraints-for-particular-machines">Constraints for Particular Machines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#controlling-names-used-in-assembler-code">Controlling Names Used in Assembler Code</a></li>
<li><a class="reference internal" href="#variables-in-specified-registers">Variables in Specified Registers</a><ul>
<li><a class="reference internal" href="#defining-global-register-variables">Defining Global Register Variables</a></li>
<li><a class="reference internal" href="#specifying-registers-for-local-variables">Specifying Registers for Local Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="when-is-a-volatile-object-accessed?.html"
                        title="previous chapter">When is a Volatile Object Accessed?</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="alternate-keywords.html"
                        title="next chapter">Alternate Keywords</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/how-to-use-inline-assembly-language-in-c-code.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="how-to-use-inline-assembly-language-in-c-code">
<span id="using-assembly-language-with-c"></span><h1>How to Use Inline Assembly Language in C Code<a class="headerlink" href="#how-to-use-inline-assembly-language-in-c-code" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><span class="target" id="index-2"></span><p id="index-3">The <tt class="docutils literal"><span class="pre">asm</span></tt> keyword allows you to embed assembler instructions
within C code.  GCC provides two forms of inline <tt class="docutils literal"><span class="pre">asm</span></tt>
statements.  A <em class="dfn">basic ``asm``</em> statement is one with no
operands (see <a class="reference internal" href="#basic-asm"><em>Basic Asm - Assembler Instructions Without Operands</em></a>), while an <em class="dfn">extended ``asm``</em>
statement (see <a class="reference internal" href="#extended-asm"><em>Extended Asm - Assembler Instructions with C Expression Operands</em></a>) includes one or more operands.
The extended form is preferred for mixing C and assembly language
within a function, but to include assembly language at
top level you must use basic <tt class="docutils literal"><span class="pre">asm</span></tt>.</p>
<p>You can also use the <tt class="docutils literal"><span class="pre">asm</span></tt> keyword to override the assembler name
for a C symbol, or to place a C variable in a specific register.</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="basic-asm-assembler-instructions-without-operands">
<span id="basic-asm"></span><h2>Basic Asm - Assembler Instructions Without Operands<a class="headerlink" href="#basic-asm-assembler-instructions-without-operands" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-4"></span><p id="index-5">A basic <tt class="docutils literal"><span class="pre">asm</span></tt> statement has the following syntax:</p>
<div class="highlight-c++"><pre>asm [ volatile ] ( ``AssemblerInstructions`` )</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">asm</span></tt> keyword is a GNU extension.
When writing code that can be compiled with <a class="reference internal" href="options-controlling-c-dialect.html#cmdoption-ansi"><em class="xref std std-option">-ansi</em></a> and the
various <a class="reference internal" href="options-controlling-the-preprocessor.html#cmdoption-std"><em class="xref std std-option">-std</em></a> options, use <tt class="docutils literal"><span class="pre">__asm__</span></tt> instead of
<tt class="docutils literal"><span class="pre">asm</span></tt> (see <a class="reference internal" href="alternate-keywords.html#alternate-keywords"><em>Alternate Keywords</em></a>).</p>
</div>
<div class="section" id="qualifiers">
<h2>Qualifiers<a class="headerlink" href="#qualifiers" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>volatile</dt>
<dd>The optional <tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier has no effect.
All basic <tt class="docutils literal"><span class="pre">asm</span></tt> blocks are implicitly volatile.</dd>
</dl>
</div>
<div class="section" id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>AssemblerInstructions</dt>
<dd><p class="first">This is a literal string that specifies the assembler code. The string can
contain any instructions recognized by the assembler, including directives.
GCC does not parse the assembler instructions themselves and
does not know what they mean or even whether they are valid assembler input.</p>
<p class="last">You may place multiple assembler instructions together in a single <tt class="docutils literal"><span class="pre">asm</span></tt>
string, separated by the characters normally used in assembly code for the
system. A combination that works in most places is a newline to break the
line, plus a tab character (written as nt).
Some assemblers allow semicolons as a line separator. However,
note that some assembler dialects use semicolons to start a comment.</p>
</dd>
</dl>
</div>
<div class="section" id="remarks">
<h2>Remarks<a class="headerlink" href="#remarks" title="Permalink to this headline">¶</a></h2>
<p>Using extended <tt class="docutils literal"><span class="pre">asm</span></tt> typically produces smaller, safer, and more
efficient code, and in most cases it is a better solution than basic
<tt class="docutils literal"><span class="pre">asm</span></tt>.  However, there are two situations where only basic <tt class="docutils literal"><span class="pre">asm</span></tt>
can be used:</p>
<ul class="simple">
<li>Extended <tt class="docutils literal"><span class="pre">asm</span></tt> statements have to be inside a C
function, so to write inline assembly language at file scope (&#8216;top-level&#8217;),
outside of C functions, you must use basic <tt class="docutils literal"><span class="pre">asm</span></tt>.
You can use this technique to emit assembler directives,
define assembly language macros that can be invoked elsewhere in the file,
or write entire functions in assembly language.</li>
<li>Functions declared
with the <tt class="docutils literal"><span class="pre">naked</span></tt> attribute also require basic <tt class="docutils literal"><span class="pre">asm</span></tt>
(see <a class="reference internal" href="declaring-attributes-of-functions.html#function-attributes"><em>Declaring Attributes of Functions</em></a>).</li>
</ul>
<p>Safely accessing C data and calling functions from basic <tt class="docutils literal"><span class="pre">asm</span></tt> is more
complex than it may appear. To access C data, it is better to use extended
<tt class="docutils literal"><span class="pre">asm</span></tt>.</p>
<p>Do not expect a sequence of <tt class="docutils literal"><span class="pre">asm</span></tt> statements to remain perfectly
consecutive after compilation. If certain instructions need to remain
consecutive in the output, put them in a single multi-instruction <tt class="docutils literal"><span class="pre">asm</span></tt>
statement. Note that GCC&#8217;s optimizers can move <tt class="docutils literal"><span class="pre">asm</span></tt> statements
relative to other code, including across jumps.</p>
<p><tt class="docutils literal"><span class="pre">asm</span></tt> statements may not perform jumps into other <tt class="docutils literal"><span class="pre">asm</span></tt> statements.
GCC does not know about these jumps, and therefore cannot take
account of them when deciding how to optimize. Jumps from <tt class="docutils literal"><span class="pre">asm</span></tt> to C
labels are only supported in extended <tt class="docutils literal"><span class="pre">asm</span></tt>.</p>
<p>Under certain circumstances, GCC may duplicate (or remove duplicates of) your
assembly code when optimizing. This can lead to unexpected duplicate
symbol errors during compilation if your assembly code defines symbols or
labels.</p>
<p>Since GCC does not parse the <tt class="docutils literal"><span class="pre">AssemblerInstructions</span></tt>, it has no
visibility of any symbols it references. This may result in GCC discarding
those symbols as unreferenced.</p>
<p>The compiler copies the assembler instructions in a basic <tt class="docutils literal"><span class="pre">asm</span></tt>
verbatim to the assembly language output file, without
processing dialects or any of the % operators that are available with
extended <tt class="docutils literal"><span class="pre">asm</span></tt>. This results in minor differences between basic
<tt class="docutils literal"><span class="pre">asm</span></tt> strings and extended <tt class="docutils literal"><span class="pre">asm</span></tt> templates. For example, to refer to
registers you might use %eax in basic <tt class="docutils literal"><span class="pre">asm</span></tt> and
%%eax in extended <tt class="docutils literal"><span class="pre">asm</span></tt>.</p>
<p>On targets such as x86 that support multiple assembler dialects,
all basic <tt class="docutils literal"><span class="pre">asm</span></tt> blocks use the assembler dialect specified by the
<a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-masm"><em class="xref std std-option">-masm</em></a> command-line option (see <a class="reference internal" href="hardware-models-and-configurations.html#x86-options"><em>x86 Options</em></a>).
Basic <tt class="docutils literal"><span class="pre">asm</span></tt> provides no
mechanism to provide different assembler strings for different dialects.</p>
<p>Here is an example of basic <tt class="docutils literal"><span class="pre">asm</span></tt> for i386:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/* Note that this code will not compile with -masm=intel */</span>
<span class="cp">#define DebugBreak() asm(&quot;int $3&quot;)</span>
</pre></div>
</div>
</div>
<div class="section" id="extended-asm-assembler-instructions-with-c-expression-operands">
<span id="extended-asm"></span><h2>Extended Asm - Assembler Instructions with C Expression Operands<a class="headerlink" href="#extended-asm-assembler-instructions-with-c-expression-operands" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-6"></span><p id="index-7">With extended <tt class="docutils literal"><span class="pre">asm</span></tt> you can read and write C variables from
assembler and perform jumps from assembler code to C labels.
Extended <tt class="docutils literal"><span class="pre">asm</span></tt> syntax uses colons (:) to delimit
the operand parameters after the assembler template:</p>
<div class="highlight-c++"><pre>asm [volatile] ( ``AssemblerTemplate``
                 : ``OutputOperands``
                 [ : ``InputOperands``
                 [ : ``Clobbers`` ] ])

asm [volatile] goto ( ``AssemblerTemplate``
                      :
                      : ``InputOperands``
                      : ``Clobbers``
                      : ``GotoLabels``)</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">asm</span></tt> keyword is a GNU extension.
When writing code that can be compiled with <a class="reference internal" href="options-controlling-c-dialect.html#cmdoption-ansi"><em class="xref std std-option">-ansi</em></a> and the
various <a class="reference internal" href="options-controlling-the-preprocessor.html#cmdoption-std"><em class="xref std std-option">-std</em></a> options, use <tt class="docutils literal"><span class="pre">__asm__</span></tt> instead of
<tt class="docutils literal"><span class="pre">asm</span></tt> (see <a class="reference internal" href="alternate-keywords.html#alternate-keywords"><em>Alternate Keywords</em></a>).</p>
</div>
<div class="section" id="id1">
<h2>Qualifiers<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>volatile</dt>
<dd>The typical use of extended <tt class="docutils literal"><span class="pre">asm</span></tt> statements is to manipulate input
values to produce output values. However, your <tt class="docutils literal"><span class="pre">asm</span></tt> statements may
also produce side effects. If so, you may need to use the <tt class="docutils literal"><span class="pre">volatile</span></tt>
qualifier to disable certain optimizations. See <a class="reference internal" href="#volatile"><em>Volatile</em></a>.</dd>
<dt>goto</dt>
<dd>This qualifier informs the compiler that the <tt class="docutils literal"><span class="pre">asm</span></tt> statement may
perform a jump to one of the labels listed in the <tt class="docutils literal"><span class="pre">GotoLabels</span></tt>.
See <a class="reference internal" href="#gotolabels"><em>Goto Labels</em></a>.</dd>
</dl>
</div>
<div class="section" id="id2">
<h2>Parameters<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>AssemblerTemplate</dt>
<dd>This is a literal string that is the template for the assembler code. It is a
combination of fixed text and tokens that refer to the input, output,
and goto parameters. See <a class="reference internal" href="#assemblertemplate"><em>Assembler Template</em></a>.</dd>
<dt>OutputOperands</dt>
<dd>A comma-separated list of the C variables modified by the instructions in the
<tt class="docutils literal"><span class="pre">AssemblerTemplate</span></tt>.  An empty list is permitted.  See <a class="reference internal" href="#outputoperands"><em>Output Operands</em></a>.</dd>
<dt>InputOperands</dt>
<dd>A comma-separated list of C expressions read by the instructions in the
<tt class="docutils literal"><span class="pre">AssemblerTemplate</span></tt>.  An empty list is permitted.  See <a class="reference internal" href="#inputoperands"><em>Input Operands</em></a>.</dd>
<dt>Clobbers</dt>
<dd>A comma-separated list of registers or other values changed by the
<tt class="docutils literal"><span class="pre">AssemblerTemplate</span></tt>, beyond those listed as outputs.
An empty list is permitted.  See <a class="reference internal" href="#clobbers"><em>Clobbers</em></a>.</dd>
<dt>GotoLabels</dt>
<dd><p class="first">When you are using the <tt class="docutils literal"><span class="pre">goto</span></tt> form of <tt class="docutils literal"><span class="pre">asm</span></tt>, this section contains
the list of all C labels to which the code in the
<tt class="docutils literal"><span class="pre">AssemblerTemplate</span></tt> may jump.
See <a class="reference internal" href="#gotolabels"><em>Goto Labels</em></a>.</p>
<p><tt class="docutils literal"><span class="pre">asm</span></tt> statements may not perform jumps into other <tt class="docutils literal"><span class="pre">asm</span></tt> statements,
only to the listed <tt class="docutils literal"><span class="pre">GotoLabels</span></tt>.
GCC&#8217;s optimizers do not know about other jumps; therefore they cannot take
account of them when deciding how to optimize.</p>
<p class="last">The total number of input + output + goto operands is limited to 30.</p>
</dd>
</dl>
</div>
<div class="section" id="id3">
<h2>Remarks<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">asm</span></tt> statement allows you to include assembly instructions directly
within C code. This may help you to maximize performance in time-sensitive
code or to access assembly instructions that are not readily available to C
programs.</p>
<p>Note that extended <tt class="docutils literal"><span class="pre">asm</span></tt> statements must be inside a function. Only
basic <tt class="docutils literal"><span class="pre">asm</span></tt> may be outside functions (see <a class="reference internal" href="#basic-asm"><em>Basic Asm - Assembler Instructions Without Operands</em></a>).
Functions declared with the <tt class="docutils literal"><span class="pre">naked</span></tt> attribute also require basic
<tt class="docutils literal"><span class="pre">asm</span></tt> (see <a class="reference internal" href="declaring-attributes-of-functions.html#function-attributes"><em>Declaring Attributes of Functions</em></a>).</p>
<p>While the uses of <tt class="docutils literal"><span class="pre">asm</span></tt> are many and varied, it may help to think of an
<tt class="docutils literal"><span class="pre">asm</span></tt> statement as a series of low-level instructions that convert input
parameters to output parameters. So a simple (if not particularly useful)
example for i386 using <tt class="docutils literal"><span class="pre">asm</span></tt> might look like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">src</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dst</span><span class="p">;</span>

<span class="k">asm</span> <span class="p">(</span><span class="s">&quot;mov %1, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
    <span class="s">&quot;add $1, %0&quot;</span>
    <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">dst</span><span class="p">)</span>
    <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">src</span><span class="p">));</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
</pre></div>
</div>
<p>This code copies <tt class="docutils literal"><span class="pre">src</span></tt> to <tt class="docutils literal"><span class="pre">dst</span></tt> and add 1 to <tt class="docutils literal"><span class="pre">dst</span></tt>.</p>
<div class="section" id="volatile">
<span id="id4"></span><h3>Volatile<a class="headerlink" href="#volatile" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-8"></span><p id="index-9">GCC&#8217;s optimizers sometimes discard <tt class="docutils literal"><span class="pre">asm</span></tt> statements if they determine
there is no need for the output variables. Also, the optimizers may move
code out of loops if they believe that the code will always return the same
result (i.e. none of its input values change between calls). Using the
<tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier disables these optimizations. <tt class="docutils literal"><span class="pre">asm</span></tt> statements
that have no output operands, including <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> statements,
are implicitly volatile.</p>
<p>This i386 code demonstrates a case that does not use (or require) the
<tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier. If it is performing assertion checking, this code
uses <tt class="docutils literal"><span class="pre">asm</span></tt> to perform the validation. Otherwise, <tt class="docutils literal"><span class="pre">dwRes</span></tt> is
unreferenced by any code. As a result, the optimizers can discard the
<tt class="docutils literal"><span class="pre">asm</span></tt> statement, which in turn removes the need for the entire
<tt class="docutils literal"><span class="pre">DoCheck</span></tt> routine. By omitting the <tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier when it
isn&#8217;t needed you allow the optimizers to produce the most efficient code
possible.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">DoCheck</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">dwSomeValue</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">uint32_t</span> <span class="n">dwRes</span><span class="p">;</span>

   <span class="c1">// Assumes dwSomeValue is not zero.</span>
   <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;bsfl %1,%0&quot;</span>
     <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">dwRes</span><span class="p">)</span>
     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">dwSomeValue</span><span class="p">)</span>
     <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>

   <span class="n">assert</span><span class="p">(</span><span class="n">dwRes</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The next example shows a case where the optimizers can recognize that the input
(<tt class="docutils literal"><span class="pre">dwSomeValue</span></tt>) never changes during the execution of the function and can
therefore move the <tt class="docutils literal"><span class="pre">asm</span></tt> outside the loop to produce more efficient code.
Again, using <tt class="docutils literal"><span class="pre">volatile</span></tt> disables this type of optimization.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">do_print</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">dwSomeValue</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">uint32_t</span> <span class="n">dwRes</span><span class="p">;</span>

   <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// Assumes dwSomeValue is not zero.</span>
      <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;bsfl %1,%0&quot;</span>
        <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">dwRes</span><span class="p">)</span>
        <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">dwSomeValue</span><span class="p">)</span>
        <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>

      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%u: %u %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dwSomeValue</span><span class="p">,</span> <span class="n">dwRes</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following example demonstrates a case where you need to use the
<tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier.
It uses the x86 <tt class="docutils literal"><span class="pre">rdtsc</span></tt> instruction, which reads
the computer&#8217;s time-stamp counter. Without the <tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier,
the optimizers might assume that the <tt class="docutils literal"><span class="pre">asm</span></tt> block will always return the
same value and therefore optimize away the second call.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint64_t</span> <span class="n">msr</span><span class="p">;</span>

<span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span> <span class="s">&quot;rdtsc</span><span class="se">\n\t</span><span class="s">&quot;</span>    <span class="c1">// Returns the time in EDX:EAX.</span>
        <span class="s">&quot;shl $32, %%rdx</span><span class="se">\n\t</span><span class="s">&quot;</span>  <span class="c1">// Shift the upper bits left.</span>
        <span class="s">&quot;or %%rdx, %0&quot;</span>        <span class="c1">// &#39;Or&#39; in the lower bits.</span>
        <span class="o">:</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span>
        <span class="o">:</span>
        <span class="o">:</span> <span class="s">&quot;rdx&quot;</span><span class="p">);</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;msr: %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>

<span class="c1">// Do other work...</span>

<span class="c1">// Reprint the timestamp</span>
<span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span> <span class="s">&quot;rdtsc</span><span class="se">\n\t</span><span class="s">&quot;</span>    <span class="c1">// Returns the time in EDX:EAX.</span>
        <span class="s">&quot;shl $32, %%rdx</span><span class="se">\n\t</span><span class="s">&quot;</span>  <span class="c1">// Shift the upper bits left.</span>
        <span class="s">&quot;or %%rdx, %0&quot;</span>        <span class="c1">// &#39;Or&#39; in the lower bits.</span>
        <span class="o">:</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span>
        <span class="o">:</span>
        <span class="o">:</span> <span class="s">&quot;rdx&quot;</span><span class="p">);</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;msr: %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
</pre></div>
</div>
<p>GCC&#8217;s optimizers do not treat this code like the non-volatile code in the
earlier examples. They do not move it out of loops or omit it on the
assumption that the result from a previous call is still valid.</p>
<p>Note that the compiler can move even volatile <tt class="docutils literal"><span class="pre">asm</span></tt> instructions relative
to other code, including across jump instructions. For example, on many
targets there is a system register that controls the rounding mode of
floating-point operations. Setting it with a volatile <tt class="docutils literal"><span class="pre">asm</span></tt>, as in the
following PowerPC example, does not work reliably.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="nf">volatile</span><span class="p">(</span><span class="s">&quot;mtfsf 255, %0&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;f&quot;</span> <span class="p">(</span><span class="n">fpenv</span><span class="p">));</span>
<span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
<p>The compiler may move the addition back before the volatile <tt class="docutils literal"><span class="pre">asm</span></tt>. To
make it work as expected, add an artificial dependency to the <tt class="docutils literal"><span class="pre">asm</span></tt> by
referencing a variable in the subsequent code, for example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span><span class="s">&quot;mtfsf 255,%1&quot;</span> <span class="o">:</span> <span class="s">&quot;=X&quot;</span> <span class="p">(</span><span class="n">sum</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;f&quot;</span> <span class="p">(</span><span class="n">fpenv</span><span class="p">));</span>
<span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
<p>Under certain circumstances, GCC may duplicate (or remove duplicates of) your
assembly code when optimizing. This can lead to unexpected duplicate symbol
errors during compilation if your asm code defines symbols or labels.
Using %=
(see <a class="reference internal" href="#assemblertemplate"><em>Assembler Template</em></a>) may help resolve this problem.</p>
</div>
<div class="section" id="assembler-template">
<span id="assemblertemplate"></span><h3>Assembler Template<a class="headerlink" href="#assembler-template" title="Permalink to this headline">¶</a></h3>
<p id="index-10">An assembler template is a literal string containing assembler instructions.
The compiler replaces tokens in the template that refer
to inputs, outputs, and goto labels,
and then outputs the resulting string to the assembler. The
string can contain any instructions recognized by the assembler, including
directives. GCC does not parse the assembler instructions
themselves and does not know what they mean or even whether they are valid
assembler input. However, it does count the statements
(see <em class="xref std std-ref">size-of-an-asm</em>).</p>
<p>You may place multiple assembler instructions together in a single <tt class="docutils literal"><span class="pre">asm</span></tt>
string, separated by the characters normally used in assembly code for the
system. A combination that works in most places is a newline to break the
line, plus a tab character to move to the instruction field (written as
nt).
Some assemblers allow semicolons as a line separator. However, note
that some assembler dialects use semicolons to start a comment.</p>
<p>Do not expect a sequence of <tt class="docutils literal"><span class="pre">asm</span></tt> statements to remain perfectly
consecutive after compilation, even when you are using the <tt class="docutils literal"><span class="pre">volatile</span></tt>
qualifier. If certain instructions need to remain consecutive in the output,
put them in a single multi-instruction asm statement.</p>
<p>Accessing data from C programs without using input/output operands (such as
by using global symbols directly from the assembler template) may not work as
expected. Similarly, calling functions directly from an assembler template
requires a detailed understanding of the target assembler and ABI.</p>
<p>Since GCC does not parse the assembler template,
it has no visibility of any
symbols it references. This may result in GCC discarding those symbols as
unreferenced unless they are also listed as input, output, or goto operands.</p>
</div>
</div>
<div class="section" id="special-format-strings">
<h2>Special format strings<a class="headerlink" href="#special-format-strings" title="Permalink to this headline">¶</a></h2>
<p>In addition to the tokens described by the input, output, and goto operands,
these tokens have special meanings in the assembler template:</p>
<dl class="docutils">
<dt>%%</dt>
<dd>Outputs a single % into the assembler code.</dd>
<dt>%=</dt>
<dd>Outputs a number that is unique to each instance of the <tt class="docutils literal"><span class="pre">asm</span></tt>
statement in the entire compilation. This option is useful when creating local
labels and referring to them multiple times in a single template that
generates multiple assembler instructions.</dd>
<dt>%{ %| %}</dt>
<dd>Outputs {, <a href="#id5"><span class="problematic" id="id6">|</span></a>, and } characters (respectively)
into the assembler code.  When unescaped, these characters have special
meaning to indicate multiple assembler dialects, as described below.</dd>
</dl>
<p>Multiple assembler dialects in <tt class="docutils literal"><span class="pre">asm</span></tt> templatesOn targets such as x86, GCC supports multiple assembler dialects.
The <a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-masm"><em class="xref std std-option">-masm</em></a> option controls which dialect GCC uses as its
default for inline assembler. The target-specific documentation for the
<a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-masm"><em class="xref std std-option">-masm</em></a> option contains the list of supported dialects, as well as the
default dialect if the option is not specified. This information may be
important to understand, since assembler code that works correctly when
compiled using one dialect will likely fail if compiled using another.
See <a class="reference internal" href="hardware-models-and-configurations.html#x86-options"><em>x86 Options</em></a>.</p>
<p>If your code needs to support multiple assembler dialects (for example, if
you are writing public headers that need to support a variety of compilation
options), use constructs of this form:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">{</span> <span class="n">dialect0</span> <span class="o">|</span> <span class="n">dialect1</span> <span class="o">|</span> <span class="n">dialect2</span><span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>This construct outputs <tt class="docutils literal"><span class="pre">dialect0</span></tt>
when using dialect #0 to compile the code,
<tt class="docutils literal"><span class="pre">dialect1</span></tt> for dialect #1, etc. If there are fewer alternatives within the
braces than the number of dialects the compiler supports, the construct
outputs nothing.</p>
<p>For example, if an x86 compiler supports two dialects
(att, intel), an
assembler template such as this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;bt{l %[Offset],%[Base] | %[Base],%[Offset]}; jc %l2&quot;</span>
</pre></div>
</div>
<p>is equivalent to one of</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;btl %[Offset],%[Base] ; jc %l2&quot;</span>   <span class="cm">/* att dialect */</span>
<span class="s">&quot;bt %[Base],%[Offset]; jc %l2&quot;</span>     <span class="cm">/* intel dialect */</span>
</pre></div>
</div>
<p>Using that same compiler, this code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;xchg{l}</span><span class="se">\t</span><span class="s">{%%}ebx, %1&quot;</span>
</pre></div>
</div>
<p>corresponds to either</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;xchgl</span><span class="se">\t</span><span class="s">%%ebx, %1&quot;</span>                 <span class="cm">/* att dialect */</span>
<span class="s">&quot;xchg</span><span class="se">\t</span><span class="s">ebx, %1&quot;</span>                    <span class="cm">/* intel dialect */</span>
</pre></div>
</div>
<p>There is no support for nesting dialect alternatives.</p>
<div class="section" id="output-operands">
<span id="outputoperands"></span><h3>Output Operands<a class="headerlink" href="#output-operands" title="Permalink to this headline">¶</a></h3>
<p id="index-11">An <tt class="docutils literal"><span class="pre">asm</span></tt> statement has zero or more output operands indicating the names
of C variables modified by the assembler code.</p>
<p>In this i386 example, <tt class="docutils literal"><span class="pre">old</span></tt> (referred to in the template string as
<tt class="docutils literal"><span class="pre">%0</span></tt>) and <tt class="docutils literal"><span class="pre">*Base</span></tt> (as <tt class="docutils literal"><span class="pre">%1</span></tt>) are outputs and <tt class="docutils literal"><span class="pre">Offset</span></tt>
(<tt class="docutils literal"><span class="pre">%2</span></tt>) is an input:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">old</span><span class="p">;</span>

<span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;btsl %2,%1</span><span class="se">\n\t</span><span class="s">&quot;</span> <span class="c1">// Turn on zero-based bit #Offset in Base.</span>
         <span class="s">&quot;sbb %0,%0&quot;</span>      <span class="c1">// Use the CF to calculate old.</span>
   <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">old</span><span class="p">),</span> <span class="s">&quot;+rm&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">Base</span><span class="p">)</span>
   <span class="o">:</span> <span class="s">&quot;Ir&quot;</span> <span class="p">(</span><span class="n">Offset</span><span class="p">)</span>
   <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>

<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
</pre></div>
</div>
<p>Operands are separated by commas.  Each operand has this format:</p>
<div class="highlight-c++"><pre>[ [``asmSymbolicName``] ] ``constraint`` (``cvariablename``)</pre>
</div>
<dl class="docutils">
<dt>asmSymbolicName</dt>
<dd><p class="first">Specifies a symbolic name for the operand.
Reference the name in the assembler template
by enclosing it in square brackets
(i.e. %[Value]). The scope of the name is the <tt class="docutils literal"><span class="pre">asm</span></tt> statement
that contains the definition. Any valid C variable name is acceptable,
including names already defined in the surrounding code. No two operands
within the same <tt class="docutils literal"><span class="pre">asm</span></tt> statement can use the same symbolic name.</p>
<p class="last">When not using an <tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt>, use the (zero-based) position
of the operand
in the list of operands in the assembler template. For example if there are
three output operands, use %0 in the template to refer to the first,
%1 for the second, and %2 for the third.</p>
</dd>
<dt>constraint</dt>
<dd><p class="first">A string constant specifying constraints on the placement of the operand;
See <em class="xref std std-ref">constraints</em>, for details.</p>
<p>Output constraints must begin with either = (a variable overwriting an
existing value) or + (when reading and writing). When using
=, do not assume the location contains the existing value
on entry to the <tt class="docutils literal"><span class="pre">asm</span></tt>, except
when the operand is tied to an input; see <a class="reference internal" href="#inputoperands"><em>Input Operands</em></a>.</p>
<p class="last">After the prefix, there must be one or more additional constraints
(see <em class="xref std std-ref">constraints</em>) that describe where the value resides. Common
constraints include r for register and m for memory.
When you list more than one possible location (for example, <tt class="docutils literal"><span class="pre">&quot;=rm&quot;</span></tt>),
the compiler chooses the most efficient one based on the current context.
If you list as many alternates as the <tt class="docutils literal"><span class="pre">asm</span></tt> statement allows, you permit
the optimizers to produce the best possible code.
If you must use a specific register, but your Machine Constraints do not
provide sufficient control to select the specific register you want,
local register variables may provide a solution (see <a class="reference internal" href="#local-reg-vars"><em>Specifying Registers for Local Variables</em></a>).</p>
</dd>
<dt>cvariablename</dt>
<dd><p class="first">Specifies a C lvalue expression to hold the output, typically a variable name.
The enclosing parentheses are a required part of the syntax.</p>
<p class="last">When the compiler selects the registers to use to</p>
</dd>
</dl>
<p>represent the output operands, it does not use any of the clobbered registers
(see <a class="reference internal" href="#clobbers"><em>Clobbers</em></a>).</p>
<p>Output operand expressions must be lvalues. The compiler cannot check whether
the operands have data types that are reasonable for the instruction being
executed. For output expressions that are not directly addressable (for
example a bit-field), the constraint must allow a register. In that case, GCC
uses the register as the output of the <tt class="docutils literal"><span class="pre">asm</span></tt>, and then stores that
register into the output.</p>
<p>Operands using the + constraint modifier count as two operands
(that is, both as input and output) towards the total maximum of 30 operands
per <tt class="docutils literal"><span class="pre">asm</span></tt> statement.</p>
<p>Use the &amp; constraint modifier (see <a class="reference internal" href="#modifiers"><em>Constraint Modifier Characters</em></a>) on all output
operands that must not overlap an input.  Otherwise,
GCC may allocate the output operand in the same register as an unrelated
input operand, on the assumption that the assembler code consumes its
inputs before producing outputs. This assumption may be false if the assembler
code actually consists of more than one instruction.</p>
<p>The same problem can occur if one output parameter (<tt class="docutils literal"><span class="pre">a</span></tt>) allows a register
constraint and another output parameter (<tt class="docutils literal"><span class="pre">b</span></tt>) allows a memory constraint.
The code generated by GCC to access the memory address in <tt class="docutils literal"><span class="pre">b</span></tt> can contain
registers which might be shared by <tt class="docutils literal"><span class="pre">a</span></tt>, and GCC considers those
registers to be inputs to the asm. As above, GCC assumes that such input
registers are consumed before any outputs are written. This assumption may
result in incorrect behavior if the asm writes to <tt class="docutils literal"><span class="pre">a</span></tt> before using
<tt class="docutils literal"><span class="pre">b</span></tt>. Combining the &amp; modifier with the register constraint on <tt class="docutils literal"><span class="pre">a</span></tt>
ensures that modifying <tt class="docutils literal"><span class="pre">a</span></tt> does not affect the address referenced by
<tt class="docutils literal"><span class="pre">b</span></tt>. Otherwise, the location of <tt class="docutils literal"><span class="pre">b</span></tt>
is undefined if <tt class="docutils literal"><span class="pre">a</span></tt> is modified before using <tt class="docutils literal"><span class="pre">b</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">asm</span></tt> supports operand modifiers on operands (for example %k2
instead of simply %2). Typically these qualifiers are hardware
dependent. The list of supported modifiers for x86 is found at
x86Operandmodifiersx86 Operand modifiers.</p>
<p>If the C code that follows the <tt class="docutils literal"><span class="pre">asm</span></tt> makes no use of any of the output
operands, use <tt class="docutils literal"><span class="pre">volatile</span></tt> for the <tt class="docutils literal"><span class="pre">asm</span></tt> statement to prevent the
optimizers from discarding the <tt class="docutils literal"><span class="pre">asm</span></tt> statement as unneeded
(see Volatile).</p>
<p>This code makes no use of the optional <tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt>. Therefore it
references the first output operand as <tt class="docutils literal"><span class="pre">%0</span></tt> (were there a second, it
would be <tt class="docutils literal"><span class="pre">%1</span></tt>, etc). The number of the first input operand is one greater
than that of the last output operand. In this i386 example, that makes
<tt class="docutils literal"><span class="pre">Mask</span></tt> referenced as <tt class="docutils literal"><span class="pre">%1</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint32_t</span> <span class="n">Mask</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">Index</span><span class="p">;</span>

  <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;bsfl %1, %0&quot;</span>
     <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">Index</span><span class="p">)</span>
     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">Mask</span><span class="p">)</span>
     <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>That code overwrites the variable <tt class="docutils literal"><span class="pre">Index</span></tt> (=),
placing the value in a register (r).
Using the generic r constraint instead of a constraint for a specific
register allows the compiler to pick the register to use, which can result
in more efficient code. This may not be possible if an assembler instruction
requires a specific register.</p>
<p>The following i386 example uses the <tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt> syntax.
It produces the
same result as the code above, but some may consider it more readable or more
maintainable since reordering index numbers is not necessary when adding or
removing operands. The names <tt class="docutils literal"><span class="pre">aIndex</span></tt> and <tt class="docutils literal"><span class="pre">aMask</span></tt>
are only used in this example to emphasize which
names get used where.
It is acceptable to reuse the names <tt class="docutils literal"><span class="pre">Index</span></tt> and <tt class="docutils literal"><span class="pre">Mask</span></tt>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint32_t</span> <span class="n">Mask</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">Index</span><span class="p">;</span>

  <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;bsfl %[aMask], %[aIndex]&quot;</span>
     <span class="o">:</span> <span class="p">[</span><span class="n">aIndex</span><span class="p">]</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">Index</span><span class="p">)</span>
     <span class="o">:</span> <span class="p">[</span><span class="n">aMask</span><span class="p">]</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">Mask</span><span class="p">)</span>
     <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here are some more examples of output operands.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint32_t</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">d</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>

<span class="k">asm</span> <span class="p">(</span><span class="s">&quot;mov %[e], %[d]&quot;</span>
   <span class="o">:</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="s">&quot;=rm&quot;</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span>
   <span class="o">:</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="s">&quot;rm&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">));</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">d</span></tt> may either be in a register or in memory. Since the compiler
might already have the current value of the <tt class="docutils literal"><span class="pre">uint32_t</span></tt> location
pointed to by <tt class="docutils literal"><span class="pre">e</span></tt>
in a register, you can enable it to choose the best location
for <tt class="docutils literal"><span class="pre">d</span></tt> by specifying both constraints.</p>
</div>
<div class="section" id="input-operands">
<span id="inputoperands"></span><h3>Input Operands<a class="headerlink" href="#input-operands" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-12"></span><p id="index-13">Input operands make values from C variables and expressions available to the
assembly code.</p>
<p>Operands are separated by commas.  Each operand has this format:</p>
<div class="highlight-c++"><pre>[ [``asmSymbolicName``] ] ``constraint`` (``cexpression``)</pre>
</div>
<dl class="docutils">
<dt>asmSymbolicName</dt>
<dd><p class="first">Specifies a symbolic name for the operand.
Reference the name in the assembler template
by enclosing it in square brackets
(i.e. %[Value]). The scope of the name is the <tt class="docutils literal"><span class="pre">asm</span></tt> statement
that contains the definition. Any valid C variable name is acceptable,
including names already defined in the surrounding code. No two operands
within the same <tt class="docutils literal"><span class="pre">asm</span></tt> statement can use the same symbolic name.</p>
<p class="last">When not using an <tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt>, use the (zero-based) position
of the operand
in the list of operands in the assembler template. For example if there are
two output operands and three inputs,
use %2 in the template to refer to the first input operand,
%3 for the second, and %4 for the third.</p>
</dd>
<dt>constraint</dt>
<dd><p class="first">A string constant specifying constraints on the placement of the operand;
See <em class="xref std std-ref">constraints</em>, for details.</p>
<p>Input constraint strings may not begin with either = or +.
When you list more than one possible location (for example, &#8220;irm&#8221;),
the compiler chooses the most efficient one based on the current context.
If you must use a specific register, but your Machine Constraints do not
provide sufficient control to select the specific register you want,
local register variables may provide a solution (see <a class="reference internal" href="#local-reg-vars"><em>Specifying Registers for Local Variables</em></a>).</p>
<p class="last">Input constraints can also be digits (for example, <tt class="docutils literal"><span class="pre">&quot;0&quot;</span></tt>). This indicates
that the specified input must be in the same place as the output constraint
at the (zero-based) index in the output constraint list.
When using <tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt> syntax for the output operands,
you may use these names (enclosed in brackets []) instead of digits.</p>
</dd>
<dt>cexpression</dt>
<dd><p class="first">This is the C variable or expression being passed to the <tt class="docutils literal"><span class="pre">asm</span></tt> statement
as input.  The enclosing parentheses are a required part of the syntax.</p>
<p class="last">When the compiler selects the registers to use to represent the input</p>
</dd>
</dl>
<p>operands, it does not use any of the clobbered registers (see <a class="reference internal" href="#clobbers"><em>Clobbers</em></a>).</p>
<p>If there are no output operands but there are input operands, place two
consecutive colons where the output operands would go:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;some instructions&quot;</span>
   <span class="o">:</span> <span class="cm">/* No outputs. */</span>
   <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">Offset</span> <span class="o">/</span> <span class="mi">8</span><span class="p">));</span>
</pre></div>
</div>
<p>Warning: Do not modify the contents of input-only operands
(except for inputs tied to outputs). The compiler assumes that on exit from
the <tt class="docutils literal"><span class="pre">asm</span></tt> statement these operands contain the same values as they
had before executing the statement.
It is not possible to use clobbers
to inform the compiler that the values in these inputs are changing. One
common work-around is to tie the changing input variable to an output variable
that never gets used. Note, however, that if the code that follows the
<tt class="docutils literal"><span class="pre">asm</span></tt> statement makes no use of any of the output operands, the GCC
optimizers may discard the <tt class="docutils literal"><span class="pre">asm</span></tt> statement as unneeded
(see Volatile).</p>
<p><tt class="docutils literal"><span class="pre">asm</span></tt> supports operand modifiers on operands (for example %k2
instead of simply %2). Typically these qualifiers are hardware
dependent. The list of supported modifiers for x86 is found at
x86Operandmodifiersx86 Operand modifiers.</p>
<p>In this example using the fictitious <tt class="docutils literal"><span class="pre">combine</span></tt> instruction, the
constraint <tt class="docutils literal"><span class="pre">&quot;0&quot;</span></tt> for input operand 1 says that it must occupy the same
location as output operand 0. Only input operands may use numbers in
constraints, and they must each refer to an output operand. Only a number (or
the symbolic assembler name) in the constraint can guarantee that one operand
is in the same place as another. The mere fact that <tt class="docutils literal"><span class="pre">foo</span></tt> is the value of
both operands is not enough to guarantee that they are in the same place in
the generated assembler code.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;combine %2, %0&quot;</span>
   <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span>
   <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s">&quot;g&quot;</span> <span class="p">(</span><span class="n">bar</span><span class="p">));</span>
</pre></div>
</div>
<p>Here is an example using symbolic names.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;cmoveq %1, %2, %[result]&quot;</span>
   <span class="o">:</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
   <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">test</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="k">new</span><span class="p">),</span> <span class="s">&quot;[result]&quot;</span> <span class="p">(</span><span class="n">old</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="clobbers">
<span id="id7"></span><h3>Clobbers<a class="headerlink" href="#clobbers" title="Permalink to this headline">¶</a></h3>
<p id="index-14">While the compiler is aware of changes to entries listed in the output
operands, the inline <tt class="docutils literal"><span class="pre">asm</span></tt> code may modify more than just the outputs. For
example, calculations may require additional registers, or the processor may
overwrite a register as a side effect of a particular assembler instruction.
In order to inform the compiler of these changes, list them in the clobber
list. Clobber list items are either register names or the special clobbers
(listed below). Each clobber list item is a string constant
enclosed in double quotes and separated by commas.</p>
<p>Clobber descriptions may not in any way overlap with an input or output
operand. For example, you may not have an operand describing a register class
with one member when listing that register in the clobber list. Variables
declared to live in specific registers (see <a class="reference internal" href="#explicit-reg-vars"><em>Variables in Specified Registers</em></a>) and used
as <tt class="docutils literal"><span class="pre">asm</span></tt> input or output operands must have no part mentioned in the
clobber description. In particular, there is no way to specify that input
operands get modified without also specifying them as output operands.</p>
<p>When the compiler selects which registers to use to represent input and output
operands, it does not use any of the clobbered registers. As a result,
clobbered registers are available for any use in the assembler code.</p>
<p>Here is a realistic example for the VAX showing the use of clobbered
registers:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span><span class="s">&quot;movc3 %0, %1, %2&quot;</span>
                   <span class="o">:</span> <span class="cm">/* No outputs. */</span>
                   <span class="o">:</span> <span class="s">&quot;g&quot;</span> <span class="p">(</span><span class="n">from</span><span class="p">),</span> <span class="s">&quot;g&quot;</span> <span class="p">(</span><span class="n">to</span><span class="p">),</span> <span class="s">&quot;g&quot;</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
                   <span class="o">:</span> <span class="s">&quot;r0&quot;</span><span class="p">,</span> <span class="s">&quot;r1&quot;</span><span class="p">,</span> <span class="s">&quot;r2&quot;</span><span class="p">,</span> <span class="s">&quot;r3&quot;</span><span class="p">,</span> <span class="s">&quot;r4&quot;</span><span class="p">,</span> <span class="s">&quot;r5&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Also, there are two special clobber arguments:</p>
<dl class="docutils">
<dt>&#8220;cc&#8221;</dt>
<dd>The <tt class="docutils literal"><span class="pre">&quot;cc&quot;</span></tt> clobber indicates that the assembler code modifies the flags
register. On some machines, GCC represents the condition codes as a specific
hardware register; <tt class="docutils literal"><span class="pre">&quot;cc&quot;</span></tt> serves to name this register.
On other machines, condition code handling is different,
and specifying <tt class="docutils literal"><span class="pre">&quot;cc&quot;</span></tt> has no effect. But
it is valid no matter what the target.</dd>
<dt>&#8220;memory&#8221;</dt>
<dd><p class="first">The <tt class="docutils literal"><span class="pre">&quot;memory&quot;</span></tt> clobber tells the compiler that the assembly code
performs memory
reads or writes to items other than those listed in the input and output
operands (for example, accessing the memory pointed to by one of the input
parameters). To ensure memory contains correct values, GCC may need to flush
specific register values to memory before executing the <tt class="docutils literal"><span class="pre">asm</span></tt>. Further,
the compiler does not assume that any values read from memory before an
<tt class="docutils literal"><span class="pre">asm</span></tt> remain unchanged after that <tt class="docutils literal"><span class="pre">asm</span></tt>; it reloads them as
needed.
Using the <tt class="docutils literal"><span class="pre">&quot;memory&quot;</span></tt> clobber effectively forms a read/write
memory barrier for the compiler.</p>
<p>Note that this clobber does not prevent the processor from doing
speculative reads past the <tt class="docutils literal"><span class="pre">asm</span></tt> statement. To prevent that, you need
processor-specific fence instructions.</p>
<p>Flushing registers to memory has performance implications and may be an issue
for time-sensitive code.  You can use a trick to avoid this if the size of
the memory being accessed is known at compile time. For example, if accessing
ten bytes of a string, use a memory input like:</p>
<p class="last"><tt class="docutils literal"><span class="pre">{&quot;m&quot;(</span> <span class="pre">({</span> <span class="pre">struct</span> <span class="pre">{</span> <span class="pre">char</span> <span class="pre">x[10];</span> <span class="pre">}</span> <span class="pre">*p</span> <span class="pre">=</span> <span class="pre">(void</span> <span class="pre">*)ptr</span> <span class="pre">;</span> <span class="pre">*p;</span> <span class="pre">})</span> <span class="pre">)}</span></tt>.</p>
</dd>
</dl>
</div>
<div class="section" id="goto-labels">
<span id="gotolabels"></span><h3>Goto Labels<a class="headerlink" href="#goto-labels" title="Permalink to this headline">¶</a></h3>
<p id="index-15"><tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> allows assembly code to jump to one or more C labels.  The
<tt class="docutils literal"><span class="pre">GotoLabels</span></tt> section in an <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> statement contains
a comma-separated
list of all C labels to which the assembler code may jump. GCC assumes that
<tt class="docutils literal"><span class="pre">asm</span></tt> execution falls through to the next statement (if this is not the
case, consider using the <tt class="docutils literal"><span class="pre">__builtin_unreachable</span></tt> intrinsic after the
<tt class="docutils literal"><span class="pre">asm</span></tt> statement). Optimization of <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> may be improved by
using the <tt class="docutils literal"><span class="pre">hot</span></tt> and <tt class="docutils literal"><span class="pre">cold</span></tt> label attributes (see <em class="xref std std-ref">label&#8211;attributes</em>).</p>
<p>An <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> statement cannot have outputs.
This is due to an internal restriction of
the compiler: control transfer instructions cannot have outputs.
If the assembler code does modify anything, use the <tt class="docutils literal"><span class="pre">&quot;memory&quot;</span></tt> clobber
to force the
optimizers to flush all register values to memory and reload them if
necessary after the <tt class="docutils literal"><span class="pre">asm</span></tt> statement.</p>
<p>Also note that an <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> statement is always implicitly
considered volatile.</p>
<p>To reference a label in the assembler template,
prefix it with %l (lowercase L) followed
by its (zero-based) position in <tt class="docutils literal"><span class="pre">GotoLabels</span></tt> plus the number of input
operands.  For example, if the <tt class="docutils literal"><span class="pre">asm</span></tt> has three inputs and references two
labels, refer to the first label as %l3 and the second as %l4).</p>
<p>Alternately, you can reference labels using the actual C label name enclosed
in brackets.  For example, to reference a label named <tt class="docutils literal"><span class="pre">carry</span></tt>, you can
use %l[carry].  The label must still be listed in the <tt class="docutils literal"><span class="pre">GotoLabels</span></tt>
section when using this approach.</p>
<p>Here is an example of <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> for i386:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="nf">goto</span> <span class="p">(</span>
    <span class="s">&quot;btl %1, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
    <span class="s">&quot;jc %l2&quot;</span>
    <span class="o">:</span> <span class="cm">/* No outputs. */</span>
    <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">p2</span><span class="p">)</span>
    <span class="o">:</span> <span class="s">&quot;cc&quot;</span>
    <span class="o">:</span> <span class="n">carry</span><span class="p">);</span>

<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">carry:</span>
<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>The following example shows an <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> that uses a memory clobber.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">frob</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">asm</span> <span class="k">goto</span> <span class="p">(</span><span class="s">&quot;frob %%r5, %1; jc %l[error]; mov (%2), %%r5&quot;</span>
            <span class="o">:</span> <span class="cm">/* No outputs. */</span>
            <span class="o">:</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span>
            <span class="o">:</span> <span class="s">&quot;r5&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span>
            <span class="o">:</span> <span class="n">error</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="nl">error:</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="x86-operand-modifiers">
<span id="x86operandmodifiers"></span><h3>x86 Operand Modifiers<a class="headerlink" href="#x86-operand-modifiers" title="Permalink to this headline">¶</a></h3>
<p>References to input, output, and goto operands in the assembler template
of extended <tt class="docutils literal"><span class="pre">asm</span></tt> statements can use
modifiers to affect the way the operands are formatted in
the code output to the assembler. For example, the
following code uses the h and b modifiers for x86:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint16_t</span>  <span class="n">num</span><span class="p">;</span>
<span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span><span class="s">&quot;xchg %h0, %b0&quot;</span> <span class="o">:</span> <span class="s">&quot;+a&quot;</span> <span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>These modifiers generate this assembler code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">xchg</span> <span class="o">%</span><span class="n">ah</span><span class="p">,</span> <span class="o">%</span><span class="n">al</span>
</pre></div>
</div>
<p>The rest of this discussion uses the following code for illustrative purposes.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">iInt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">top:</span>

   <span class="k">asm</span> <span class="k">volatile</span> <span class="k">goto</span> <span class="p">(</span><span class="s">&quot;some assembler instructions here&quot;</span>
   <span class="o">:</span> <span class="cm">/* No outputs. */</span>
   <span class="o">:</span> <span class="s">&quot;q&quot;</span> <span class="p">(</span><span class="n">iInt</span><span class="p">),</span> <span class="s">&quot;X&quot;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
   <span class="o">:</span> <span class="cm">/* No clobbers. */</span>
   <span class="o">:</span> <span class="n">top</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With no modifiers, this is what the output from the operands would be for the
att and intel dialects of assembler:</p>
<p>Operandmasm=attOFFSET FLAT:.L2Operand</p>
<p>masm=att</p>
<p>masm=intel</p>
<p><tt class="docutils literal"><span class="pre">%0</span></tt></p>
<p><tt class="docutils literal"><span class="pre">%eax</span></tt></p>
<p><tt class="docutils literal"><span class="pre">eax</span></tt></p>
<p><tt class="docutils literal"><span class="pre">%1</span></tt></p>
<p><tt class="docutils literal"><span class="pre">$2</span></tt></p>
<p><tt class="docutils literal"><span class="pre">2</span></tt></p>
<p><tt class="docutils literal"><span class="pre">%2</span></tt></p>
<p><tt class="docutils literal"><span class="pre">$.L2</span></tt></p>
<p><tt class="docutils literal"><span class="pre">OFFSET</span> <span class="pre">FLAT:.L2</span></tt></p>
<p>The table below shows the list of supported modifiers and their effects.</p>
<p>ModifierPrint the opcode suffix for the size of thOperandmasm=attmasm=intelModifier</p>
<p>Description</p>
<p>Operand</p>
<p>masm=att</p>
<p>masm=intel</p>
<p><tt class="docutils literal"><span class="pre">z</span></tt></p>
<p>Print the opcode suffix for the size of the current integer operand (one of <tt class="docutils literal"><span class="pre">b</span></tt>/<tt class="docutils literal"><span class="pre">w</span></tt>/<tt class="docutils literal"><span class="pre">l</span></tt>/<tt class="docutils literal"><span class="pre">q</span></tt>).</p>
<p><tt class="docutils literal"><span class="pre">%z0</span></tt></p>
<p><tt class="docutils literal"><span class="pre">l</span></tt></p>
<p><tt class="docutils literal"><span class="pre">b</span></tt></p>
<p>Print the QImode name of the register.</p>
<p><tt class="docutils literal"><span class="pre">%b0</span></tt></p>
<p><tt class="docutils literal"><span class="pre">%al</span></tt></p>
<p><tt class="docutils literal"><span class="pre">al</span></tt></p>
<p><tt class="docutils literal"><span class="pre">h</span></tt></p>
<p>Print the QImode name for a &#8216;high&#8217; register.</p>
<p><tt class="docutils literal"><span class="pre">%h0</span></tt></p>
<p><tt class="docutils literal"><span class="pre">%ah</span></tt></p>
<p><tt class="docutils literal"><span class="pre">ah</span></tt></p>
<p><tt class="docutils literal"><span class="pre">w</span></tt></p>
<p>Print the HImode name of the register.</p>
<p><tt class="docutils literal"><span class="pre">%w0</span></tt></p>
<p><tt class="docutils literal"><span class="pre">%ax</span></tt></p>
<p><tt class="docutils literal"><span class="pre">ax</span></tt></p>
<p><tt class="docutils literal"><span class="pre">k</span></tt></p>
<p>Print the SImode name of the register.</p>
<p><tt class="docutils literal"><span class="pre">%k0</span></tt></p>
<p><tt class="docutils literal"><span class="pre">%eax</span></tt></p>
<p><tt class="docutils literal"><span class="pre">eax</span></tt></p>
<p><tt class="docutils literal"><span class="pre">q</span></tt></p>
<p>Print the DImode name of the register.</p>
<p><tt class="docutils literal"><span class="pre">%q0</span></tt></p>
<p><tt class="docutils literal"><span class="pre">%rax</span></tt></p>
<p><tt class="docutils literal"><span class="pre">rax</span></tt></p>
<p><tt class="docutils literal"><span class="pre">l</span></tt></p>
<p>Print the label name with no punctuation.</p>
<p><tt class="docutils literal"><span class="pre">%l2</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.L2</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.L2</span></tt></p>
<p><tt class="docutils literal"><span class="pre">c</span></tt></p>
<p>Require a constant operand and print the constant expression with no punctuation.</p>
<p><tt class="docutils literal"><span class="pre">%c1</span></tt></p>
<p><tt class="docutils literal"><span class="pre">2</span></tt></p>
<p><tt class="docutils literal"><span class="pre">2</span></tt></p>
<p id="x86floatingpointasmoperands">x86 Floating-Point <tt class="docutils literal"><span class="pre">asm</span></tt> OperandsOn x86 targets, there are several rules on the usage of stack-like registers
in the operands of an <tt class="docutils literal"><span class="pre">asm</span></tt>.  These rules apply only to the operands
that are stack-like registers:</p>
<ul>
<li><p class="first">Given a set of input registers that die in an <tt class="docutils literal"><span class="pre">asm</span></tt>, it is
necessary to know which are implicitly popped by the <tt class="docutils literal"><span class="pre">asm</span></tt>, and
which must be explicitly popped by GCC.</p>
<p>An input register that is implicitly popped by the <tt class="docutils literal"><span class="pre">asm</span></tt> must be
explicitly clobbered, unless it is constrained to match an
output operand.</p>
</li>
<li><p class="first">For any input register that is implicitly popped by an <tt class="docutils literal"><span class="pre">asm</span></tt>, it is
necessary to know how to adjust the stack to compensate for the pop.
If any non-popped input is closer to the top of the reg-stack than
the implicitly popped register, it would not be possible to know what the
stack looked like-it&#8217;s not clear how the rest of the stack &#8216;slides
up&#8217;.</p>
<p>All implicitly popped input registers must be closer to the top of
the reg-stack than any input that is not implicitly popped.</p>
<p>It is possible that if an input dies in an <tt class="docutils literal"><span class="pre">asm</span></tt>, the compiler might
use the input register for an output reload.  Consider this example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;foo&quot;</span> <span class="o">:</span> <span class="s">&quot;=t&quot;</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;f&quot;</span> <span class="p">(</span><span class="n">b</span><span class="p">));</span>
</pre></div>
</div>
<p>This code says that input <tt class="docutils literal"><span class="pre">b</span></tt> is not popped by the <tt class="docutils literal"><span class="pre">asm</span></tt>, and that
the <tt class="docutils literal"><span class="pre">asm</span></tt> pushes a result onto the reg-stack, i.e., the stack is one
deeper after the <tt class="docutils literal"><span class="pre">asm</span></tt> than it was before.  But, it is possible that
reload may think that it can use the same register for both the input and
the output.</p>
<p>To prevent this from happening,
if any input operand uses the f constraint, all output register
constraints must use the &amp; early-clobber modifier.</p>
<p>The example above is correctly written as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;foo&quot;</span> <span class="o">:</span> <span class="s">&quot;=&amp;t&quot;</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;f&quot;</span> <span class="p">(</span><span class="n">b</span><span class="p">));</span>
</pre></div>
</div>
</li>
<li><p class="first">Some operands need to be in particular places on the stack.  All
output operands fall in this category-GCC has no other way to
know which registers the outputs appear in unless you indicate
this in the constraints.</p>
<p>Output operands must specifically indicate which register an output
appears in after an <tt class="docutils literal"><span class="pre">asm</span></tt>.  =f is not allowed: the operand
constraints must select a class with a single register.</p>
</li>
<li><p class="first">Output operands may not be &#8216;inserted&#8217; between existing stack registers.
Since no 387 opcode uses a read/write operand, all output operands
are dead before the <tt class="docutils literal"><span class="pre">asm</span></tt>, and are pushed by the <tt class="docutils literal"><span class="pre">asm</span></tt>.
It makes no sense to push anywhere but the top of the reg-stack.</p>
<p>Output operands must start at the top of the reg-stack: output
operands may not &#8216;skip&#8217; a register.</p>
</li>
<li><p class="first">Some <tt class="docutils literal"><span class="pre">asm</span></tt> statements may need extra stack space for internal
calculations.  This can be guaranteed by clobbering stack registers
unrelated to the inputs and outputs.</p>
</li>
</ul>
<p>This <tt class="docutils literal"><span class="pre">asm</span></tt>
takes one input, which is internally popped, and produces two outputs.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;fsincos&quot;</span> <span class="o">:</span> <span class="s">&quot;=t&quot;</span> <span class="p">(</span><span class="n">cos</span><span class="p">),</span> <span class="s">&quot;=u&quot;</span> <span class="p">(</span><span class="n">sin</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">inp</span><span class="p">));</span>
</pre></div>
</div>
<p>This <tt class="docutils literal"><span class="pre">asm</span></tt> takes two inputs, which are popped by the <tt class="docutils literal"><span class="pre">fyl2xp1</span></tt> opcode,
and replaces them with one output.  The <tt class="docutils literal"><span class="pre">st(1)</span></tt> clobber is necessary
for the compiler to know that <tt class="docutils literal"><span class="pre">fyl2xp1</span></tt> pops both inputs.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;fyl2xp1&quot;</span> <span class="o">:</span> <span class="s">&quot;=t&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&quot;u&quot;</span> <span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;st(1)&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p id="constraints">Constraints for <tt class="docutils literal"><span class="pre">asm</span></tt> Operands
.. index:: operand constraints, asm</p>
<span class="target" id="index-16"></span><p id="index-17">Here are specific details on what constraint letters you can use with
<tt class="docutils literal"><span class="pre">asm</span></tt> operands.
Constraints can say whether
an operand may be in a register, and which kinds of register; whether the
operand can be a memory reference, and which kinds of address; whether the
operand may be an immediate constant, and which possible values it may
have.  Constraints can also require two operands to match.
Side-effects aren&#8217;t allowed in operands of inline <tt class="docutils literal"><span class="pre">asm</span></tt>, unless
&lt; or &gt; constraints are used, because there is no guarantee
that the side-effects will happen exactly once in an instruction that can update
the addressing register.</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
</div>
<div class="section" id="simple-constraints">
<span id="id8"></span><h3>Simple Constraints<a class="headerlink" href="#simple-constraints" title="Permalink to this headline">¶</a></h3>
<p id="index-18">The simplest kind of constraint is a string full of letters, each of
which describes one kind of operand that is permitted.  Here are
the letters that are allowed:</p>
<dl class="docutils">
<dt>whitespace</dt>
<dd>Whitespace characters are ignored and can be inserted at any position
except the first.  This enables each alternative for different operands to
be visually aligned in the machine description even if they have different
number of constraints and modifiers.<span class="target" id="index-19"></span></dd>
<dt>m</dt>
<dd>A memory operand is allowed, with any kind of address that the machine
supports in general.
Note that the letter used for the general memory constraint can be
re-defined by a back end using the <tt class="docutils literal"><span class="pre">TARGET_MEM_CONSTRAINT</span></tt> macro.<span class="target" id="index-21"></span></dd>
<dt>o</dt>
<dd><p class="first">A memory operand is allowed, but only if the address is
<em class="dfn">offsettable</em>.  This means that adding a small integer (actually,
the width in bytes of the operand, as determined by its machine mode)
may be added to the address and the result is also a valid memory
address.</p>
<p id="index-23">For example, an address which is constant is offsettable; so is an
address that is the sum of a register and a constant (as long as a
slightly larger constant is also within the range of address-offsets
supported by the machine); but an autoincrement or autodecrement
address is not offsettable.  More complicated indirect/indexed
addresses may or may not be offsettable depending on the other
addressing modes that the machine supports.</p>
<p class="last">Note that in an output operand which can be matched by another
operand, the constraint letter o is valid only when accompanied
by both &lt; (if the target machine has predecrement addressing)
and &gt; (if the target machine has preincrement addressing).</p>
</dd>
<dt>V</dt>
<dd>A memory operand that is not offsettable.  In other words, anything that
would fit the m constraint but not the o constraint.</dd>
</dl>
<dl class="docutils">
<dt>&lt;</dt>
<dd>A memory operand with autodecrement addressing (either predecrement or
postdecrement) is allowed.  In inline <tt class="docutils literal"><span class="pre">asm</span></tt> this constraint is only
allowed if the operand is used exactly once in an instruction that can
handle the side-effects.  Not using an operand with &lt; in constraint
string in the inline <tt class="docutils literal"><span class="pre">asm</span></tt> pattern at all or using it in multiple
instructions isn&#8217;t valid, because the side-effects wouldn&#8217;t be performed
or would be performed more than once.  Furthermore, on some targets
the operand with &lt; in constraint string must be accompanied by
special instruction suffixes like <tt class="docutils literal"><span class="pre">%U0</span></tt> instruction suffix on PowerPC
or <tt class="docutils literal"><span class="pre">%P0</span></tt> on IA-64.</dd>
</dl>
<dl class="docutils">
<dt>&gt;</dt>
<dd>A memory operand with autoincrement addressing (either preincrement or
postincrement) is allowed.  In inline <tt class="docutils literal"><span class="pre">asm</span></tt> the same restrictions
as for &lt; apply.<span class="target" id="index-27"></span></dd>
<dt>r</dt>
<dd>A register operand is allowed provided that it is in a general
register.<span class="target" id="index-29"></span></dd>
<dt>i</dt>
<dd>An immediate integer operand (one with constant value) is allowed.
This includes symbolic constants whose values will be known only at
assembly time or later.</dd>
<dt>n</dt>
<dd>An immediate integer operand with a known numeric value is allowed.
Many systems cannot support assembly-time constants for operands less
than a word wide.  Constraints for these operands should use n
rather than i.</dd>
<dt>I, J, K, ... P</dt>
<dd>Other letters in the range I through P may be defined in
a machine-dependent fashion to permit immediate integer operands with
explicit integer values in specified ranges.  For example, on the
68000, I is defined to stand for the range of values 1 to 8.
This is the range permitted as a shift count in the shift
instructions.</dd>
<dt>E</dt>
<dd>An immediate floating operand (expression code <tt class="docutils literal"><span class="pre">const_double</span></tt>) is
allowed, but only if the target floating point format is the same as
that of the host machine (on which the compiler is running).</dd>
<dt>F</dt>
<dd>An immediate floating operand (expression code <tt class="docutils literal"><span class="pre">const_double</span></tt> or
<tt class="docutils literal"><span class="pre">const_vector</span></tt>) is allowed.<span class="target" id="index-35"></span></dd>
<dt>G, H</dt>
<dd>G and H may be defined in a machine-dependent fashion to
permit immediate floating operands in particular ranges of values.</dd>
<dt>s</dt>
<dd><p class="first">An immediate integer operand whose value is not an explicit integer is
allowed.</p>
<p>This might appear strange; if an insn allows a constant operand with a
value not known at compile time, it certainly must allow any known
value.  So why use s instead of i?  Sometimes it allows
better code to be generated.</p>
<p class="last">For example, on the 68000 in a fullword instruction it is possible to
use an immediate operand; but if the immediate value is between -128
and 127, better code results from loading the value into a register and
using the register.  This is because the load into the register can be
done with a moveq instruction.  We arrange for this to happen
by defining the letter K to mean &#8216;any integer outside the
range -128 to 127&#8217;, and then specifying Ks in the operand
constraints.</p>
</dd>
<dt>g</dt>
<dd>Any register, memory or immediate integer operand is allowed, except for
registers that are not general registers.</dd>
<dt>X</dt>
<dd>Any operand whatsoever is allowed.<span class="target" id="index-40"></span></dd>
<dt>0, 1, 2, ... 9</dt>
<dd><p class="first">An operand that matches the specified operand number is allowed.  If a
digit is used together with letters within the same alternative, the
digit should come last.</p>
<p>This number is allowed to be more than a single digit.  If multiple
digits are encountered consecutively, they are interpreted as a single
decimal integer.  There is scant chance for ambiguity, since to-date
it has never been desirable that 10 be interpreted as matching
either operand 1 or operand 0.  Should this be desired, one
can use multiple alternatives instead.</p>
<span class="target" id="index-42"></span><p id="index-43">This is called a <em class="dfn">matching constraint</em> and what it really means is
that the assembler has only a single operand that fills two roles
which <tt class="docutils literal"><span class="pre">asm</span></tt> distinguishes.  For example, an add instruction uses
two input operands and an output operand, but on most CISC
machines an add instruction really has only two operands, one of them an
input-output operand:</p>
<div class="highlight-c++"><pre>addl #35,r12</pre>
</div>
<p class="last">Matching constraints are used in these circumstances.
More precisely, the two operands that match must include one input-only
operand and one output-only operand.  Moreover, the digit must be a
smaller number than the number of the operand that uses it in the
constraint.</p>
<span class="target" id="index-44"></span><span class="target" id="index-45"></span><span class="target" id="index-46"></span></dd>
<dt>p</dt>
<dd><p class="first">An operand that is a valid memory address is allowed.  This is
for &#8216;load address&#8217; and &#8216;push address&#8217; instructions.</p>
<p class="last" id="index-48">p in the constraint must be accompanied by <tt class="docutils literal"><span class="pre">address_operand</span></tt>
as the predicate in the <tt class="docutils literal"><span class="pre">match_operand</span></tt>.  This predicate interprets
the mode specified in the <tt class="docutils literal"><span class="pre">match_operand</span></tt> as the mode of the memory
reference for which the address would be valid.</p>
<span class="target" id="index-49"></span></dd>
<dt><tt class="docutils literal"><span class="pre">other-letters</span></tt></dt>
<dd>Other letters can be defined in machine-dependent fashion to stand for
particular classes of registers or other arbitrary operand types.
d, a and f are defined on the 68000/68020 to stand
for data, address and floating point registers.</dd>
</dl>
</div>
<div class="section" id="multiple-alternative-constraints">
<span id="multi-alternative"></span><h3>Multiple Alternative Constraints<a class="headerlink" href="#multiple-alternative-constraints" title="Permalink to this headline">¶</a></h3>
<p id="index-51">Sometimes a single instruction has multiple alternative sets of possible
operands.  For example, on the 68000, a logical-or instruction can combine
register or an immediate value into memory, or it can combine any kind of
operand into a register; but it cannot combine one memory location into
another.</p>
<p>These constraints are represented as multiple alternatives.  An alternative
can be described by a series of letters for each operand.  The overall
constraint for an operand is made from the letters for this operand
from the first alternative, a comma, the letters for this operand from
the second alternative, a comma, and so on until the last alternative.</p>
<p>If all the operands fit any one alternative, the instruction is valid.
Otherwise, for each alternative, the compiler counts how many instructions
must be added to copy the operands so that that alternative applies.
The alternative requiring the least copying is chosen.  If two alternatives
need the same amount of copying, the one that comes first is chosen.
These choices can be altered with the ? and ! characters:</p>
<span class="target" id="index-52"></span><dl class="docutils">
<dt>?</dt>
<dd>Disparage slightly the alternative that the ? appears in,
as a choice when no alternative applies exactly.  The compiler regards
this alternative as one unit more costly for each ? that appears
in it.<span class="target" id="index-54"></span></dd>
</dl>
<dl class="docutils">
<dt>!</dt>
<dd>Disparage severely the alternative that the ! appears in.
This alternative can still be used if it fits without reloading,
but if reloading is needed, some other alternative will be used.<span class="target" id="index-56"></span></dd>
</dl>
<dl class="docutils">
<dt>^</dt>
<dd>This constraint is analogous to ? but it disparages slightly
the alternative only if the operand with the ^ needs a reload.<span class="target" id="index-58"></span></dd>
</dl>
<dl class="docutils">
<dt>$</dt>
<dd>This constraint is analogous to ! but it disparages severely
the alternative only if the operand with the $ needs a reload.</dd>
</dl>
</div>
<div class="section" id="constraint-modifier-characters">
<span id="modifiers"></span><h3>Constraint Modifier Characters<a class="headerlink" href="#constraint-modifier-characters" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-60"></span><span class="target" id="index-61"></span><p>Here are constraint modifier characters.</p>
<dl class="docutils">
<dt>=</dt>
<dd>Means that this operand is written to by this instruction:
the previous value is discarded and replaced by new data.</dd>
</dl>
<ul id="index-63">
<li><p class="first">Means that this operand is both read and written by the instruction.</p>
<p>When the compiler fixes up the operands to satisfy the constraints,
it needs to know which operands are read by the instruction and
which are written by it.  = identifies an operand which is only
written; + identifies an operand that is both read and written; all
other operands are assumed to only be read.</p>
<p>If you specify = or + in a constraint, you put it in the
first character of the constraint string.</p>
<span class="target" id="index-64"></span></li>
</ul>
<dl class="docutils">
<dt>&amp;</dt>
<dd><p class="first">Means (in a particular alternative) that this operand is an
<em class="dfn">earlyclobber</em> operand, which is written before the instruction is
finished using the input operands.  Therefore, this operand may not lie
in a register that is read by the instruction or as part of any memory
address.</p>
<p>&amp; applies only to the alternative in which it is written.  In
constraints with multiple alternatives, sometimes one alternative
requires &amp; while others do not.  See, for example, the
movdf insn of the 68000.</p>
<p>A operand which is read by the instruction can be tied to an earlyclobber
operand if its only use as an input occurs before the early result is
written.  Adding alternatives of this form often allows GCC to produce
better code when only some of the read operands can be affected by the
earlyclobber. See, for example, the mulsi3 insn of the ARM.</p>
<p>Furthermore, if the <em class="dfn">earlyclobber</em> operand is also a read/write
operand, then that operand is written only after it&#8217;s used.</p>
<p class="last">&amp; does not obviate the need to write = or +.  As
<em class="dfn">earlyclobber</em> operands are always written, a read-only
<em class="dfn">earlyclobber</em> operand is ill-formed and will be rejected by the
compiler.</p>
</dd>
</dl>
<dl class="docutils">
<dt>%</dt>
<dd><p class="first">Declares the instruction to be commutative for this operand and the
following operand.  This means that the compiler may interchange the
two operands if that is the cheapest way to make all operands fit the
constraints.  % applies to all alternatives and must appear as
the first character in the constraint.  Only read-only operands can use
%.</p>
<p class="last">GCC can only handle one commutative pair in an asm; if you use more,
the compiler may fail.  Note that you need not use the modifier if
the two alternatives are strictly identical; this would only waste
time in the reload pass.  The modifier is not operational after
register allocation, so the result of <tt class="docutils literal"><span class="pre">define_peephole2</span></tt>
and <a href="#id9"><span class="problematic" id="id10">``</span></a>define_split``s performed after reload cannot rely on
% to make the intended insn match.</p>
</dd>
</dl>
<dl class="docutils">
<dt>#</dt>
<dd>Says that all following characters, up to the next comma, are to be
ignored as a constraint.  They are significant only for choosing
register preferences.</dd>
</dl>
<ul class="simple" id="index-68">
<li>Says that the following character should be ignored when choosing
register preferences.  * has no effect on the meaning of the
constraint as a constraint, and no effect on reloading.  For LRA
* additionally disparages slightly the alternative if the
following character matches the operand.</li>
</ul>
</div>
<div class="section" id="constraints-for-particular-machines">
<span id="machine-constraints"></span><h3>Constraints for Particular Machines<a class="headerlink" href="#constraints-for-particular-machines" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-69"></span><p id="index-70">Whenever possible, you should use the general-purpose constraint letters
in <tt class="docutils literal"><span class="pre">asm</span></tt> arguments, since they will convey meaning more readily to
people reading your code.  Failing that, use the constraint letters
that usually have very similar meanings across architectures.  The most
commonly used constraints are m and r (for memory and
general-purpose registers respectively; see <a class="reference internal" href="#simple-constraints"><em>Simple Constraints</em></a>), and
I, usually the letter indicating the most common
immediate-constant format.</p>
<p>Each architecture defines additional constraints.  These constraints
are used by the compiler itself for instruction generation, as well as
for <tt class="docutils literal"><span class="pre">asm</span></tt> statements; therefore, some of the constraints are not
particularly useful for <tt class="docutils literal"><span class="pre">asm</span></tt>.  Here is a summary of some of the
machine-dependent constraints available on some particular machines;
it includes both constraints that are useful for <tt class="docutils literal"><span class="pre">asm</span></tt> and
constraints that aren&#8217;t.  The compiler source file mentioned in the
table heading for each architecture is the definitive reference for
the meanings of that architecture&#8217;s constraints.</p>
<p>AArch64 family-config/aarch64/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>k</dt>
<dd>The stack pointer register (<tt class="docutils literal"><span class="pre">SP</span></tt>)</dd>
<dt>w</dt>
<dd>Floating point or SIMD vector register</dd>
<dt>I</dt>
<dd>Integer constant that is valid as an immediate operand in an <tt class="docutils literal"><span class="pre">ADD</span></tt>
instruction</dd>
<dt>J</dt>
<dd>Integer constant that is valid as an immediate operand in a <tt class="docutils literal"><span class="pre">SUB</span></tt>
instruction (once negated)</dd>
<dt>K</dt>
<dd>Integer constant that can be used with a 32-bit logical instruction</dd>
<dt>L</dt>
<dd>Integer constant that can be used with a 64-bit logical instruction</dd>
<dt>M</dt>
<dd>Integer constant that is valid as an immediate operand in a 32-bit <tt class="docutils literal"><span class="pre">MOV</span></tt>
pseudo instruction. The <tt class="docutils literal"><span class="pre">MOV</span></tt> may be assembled to one of several different
machine instructions depending on the value</dd>
<dt>N</dt>
<dd>Integer constant that is valid as an immediate operand in a 64-bit <tt class="docutils literal"><span class="pre">MOV</span></tt>
pseudo instruction</dd>
<dt>S</dt>
<dd>An absolute symbolic address or a label reference</dd>
<dt>Y</dt>
<dd>Floating point constant zero</dd>
<dt>Z</dt>
<dd>Integer constant zero</dd>
<dt>Ush</dt>
<dd>The high part (bits 12 and upwards) of the pc-relative address of a symbol
within 4GB of the instruction</dd>
<dt>Q</dt>
<dd>A memory address which uses a single base register with no offset</dd>
<dt>Ump</dt>
<dd>A memory address suitable for a load/store pair instruction in SI, DI, SF and
DF modes</dd>
</dl>
</div></blockquote>
<p>ARC -config/arc/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>q</dt>
<dd>Registers usable in ARCompact 16-bit instructions: <tt class="docutils literal"><span class="pre">r0</span></tt>-<tt class="docutils literal"><span class="pre">r3</span></tt>,
<tt class="docutils literal"><span class="pre">r12</span></tt>-<tt class="docutils literal"><span class="pre">r15</span></tt>.  This constraint can only match when the <em class="xref std std-option">-mq</em>
option is in effect.</dd>
<dt>e</dt>
<dd>Registers usable as base-regs of memory addresses in ARCompact 16-bit memory
instructions: <tt class="docutils literal"><span class="pre">r0</span></tt>-<tt class="docutils literal"><span class="pre">r3</span></tt>, <tt class="docutils literal"><span class="pre">r12</span></tt>-<tt class="docutils literal"><span class="pre">r15</span></tt>, <tt class="docutils literal"><span class="pre">sp</span></tt>.
This constraint can only match when the <em class="xref std std-option">-mq</em>
option is in effect.</dd>
<dt>D</dt>
<dd>ARC FPX (dpfp) 64-bit registers. <tt class="docutils literal"><span class="pre">D0</span></tt>, <tt class="docutils literal"><span class="pre">D1</span></tt>.</dd>
<dt>I</dt>
<dd>A signed 12-bit integer constant.</dd>
<dt>Cal</dt>
<dd>constant for arithmetic/logical operations.  This might be any constant
that can be put into a long immediate by the assmbler or linker without
involving a PIC relocation.</dd>
<dt>K</dt>
<dd>A 3-bit unsigned integer constant.</dd>
<dt>L</dt>
<dd>A 6-bit unsigned integer constant.</dd>
<dt>CnL</dt>
<dd>One&#8217;s complement of a 6-bit unsigned integer constant.</dd>
<dt>CmL</dt>
<dd>Two&#8217;s complement of a 6-bit unsigned integer constant.</dd>
<dt>M</dt>
<dd>A 5-bit unsigned integer constant.</dd>
<dt>O</dt>
<dd>A 7-bit unsigned integer constant.</dd>
<dt>P</dt>
<dd>A 8-bit unsigned integer constant.</dd>
<dt>H</dt>
<dd>Any const_double value.</dd>
</dl>
</div></blockquote>
<p>ARM family-config/arm/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>h</dt>
<dd>In Thumb state, the core registers <tt class="docutils literal"><span class="pre">r8</span></tt>-<tt class="docutils literal"><span class="pre">r15</span></tt>.</dd>
<dt>k</dt>
<dd>The stack pointer register.</dd>
<dt>l</dt>
<dd>In Thumb State the core registers <tt class="docutils literal"><span class="pre">r0</span></tt>-<tt class="docutils literal"><span class="pre">r7</span></tt>.  In ARM state this
is an alias for the <tt class="docutils literal"><span class="pre">r</span></tt> constraint.</dd>
<dt>t</dt>
<dd>VFP floating-point registers <tt class="docutils literal"><span class="pre">s0</span></tt>-<tt class="docutils literal"><span class="pre">s31</span></tt>.  Used for 32 bit values.</dd>
<dt>w</dt>
<dd>VFP floating-point registers <tt class="docutils literal"><span class="pre">d0</span></tt>-<tt class="docutils literal"><span class="pre">d31</span></tt> and the appropriate
subset <tt class="docutils literal"><span class="pre">d0</span></tt>-<tt class="docutils literal"><span class="pre">d15</span></tt> based on command line options.
Used for 64 bit values only.  Not valid for Thumb1.</dd>
<dt>y</dt>
<dd>The iWMMX co-processor registers.</dd>
<dt>z</dt>
<dd>The iWMMX GR registers.</dd>
<dt>G</dt>
<dd>The floating-point constant 0.0</dd>
<dt>I</dt>
<dd>Integer that is valid as an immediate operand in a data processing
instruction.  That is, an integer in the range 0 to 255 rotated by a
multiple of 2</dd>
<dt>J</dt>
<dd>Integer in the range -4095 to 4095</dd>
<dt>K</dt>
<dd>Integer that satisfies constraint I when inverted (ones complement)</dd>
<dt>L</dt>
<dd>Integer that satisfies constraint I when negated (twos complement)</dd>
<dt>M</dt>
<dd>Integer in the range 0 to 32</dd>
<dt>Q</dt>
<dd>A memory reference where the exact address is in a single register
(&#8216;m&#8217; is preferable for <tt class="docutils literal"><span class="pre">asm</span></tt> statements)</dd>
<dt>R</dt>
<dd>An item in the constant pool</dd>
<dt>S</dt>
<dd>A symbol in the text segment of the current file</dd>
<dt>Uv</dt>
<dd>A memory reference suitable for VFP load/store insns (reg+constant offset)</dd>
<dt>Uy</dt>
<dd>A memory reference suitable for iWMMXt load/store instructions.</dd>
<dt>Uq</dt>
<dd>A memory reference suitable for the ARMv4 ldrsb instruction.</dd>
</dl>
</div></blockquote>
<p>AVR family-config/avr/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>l</dt>
<dd>Registers from r0 to r15</dd>
<dt>a</dt>
<dd>Registers from r16 to r23</dd>
<dt>d</dt>
<dd>Registers from r16 to r31</dd>
<dt>w</dt>
<dd>Registers from r24 to r31.  These registers can be used in adiw command</dd>
<dt>e</dt>
<dd>Pointer register (r26-r31)</dd>
<dt>b</dt>
<dd>Base pointer register (r28-r31)</dd>
<dt>q</dt>
<dd>Stack pointer register (SPH:SPL)</dd>
<dt>t</dt>
<dd>Temporary register r0</dd>
<dt>x</dt>
<dd>Register pair X (r27:r26)</dd>
<dt>y</dt>
<dd>Register pair Y (r29:r28)</dd>
<dt>z</dt>
<dd>Register pair Z (r31:r30)</dd>
<dt>I</dt>
<dd>Constant greater than -1, less than 64</dd>
<dt>J</dt>
<dd>Constant greater than -64, less than 1</dd>
<dt>K</dt>
<dd>Constant integer 2</dd>
<dt>L</dt>
<dd>Constant integer 0</dd>
<dt>M</dt>
<dd>Constant that fits in 8 bits</dd>
<dt>N</dt>
<dd>Constant integer -1</dd>
<dt>O</dt>
<dd>Constant integer 8, 16, or 24</dd>
<dt>P</dt>
<dd>Constant integer 1</dd>
<dt>G</dt>
<dd>A floating point constant 0.0</dd>
<dt>Q</dt>
<dd>A memory address based on Y or Z pointer with displacement.</dd>
</dl>
</div></blockquote>
<p>Blackfin family-config/bfin/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>P register</dd>
<dt>d</dt>
<dd>D register</dd>
<dt>z</dt>
<dd>A call clobbered P register.</dd>
<dt>q``n``</dt>
<dd>A single register.  If <tt class="docutils literal"><span class="pre">n</span></tt> is in the range 0 to 7, the corresponding D
register.  If it is <tt class="docutils literal"><span class="pre">A</span></tt>, then the register P0.</dd>
<dt>D</dt>
<dd>Even-numbered D register</dd>
<dt>W</dt>
<dd>Odd-numbered D register</dd>
<dt>e</dt>
<dd>Accumulator register.</dd>
<dt>A</dt>
<dd>Even-numbered accumulator register.</dd>
<dt>B</dt>
<dd>Odd-numbered accumulator register.</dd>
<dt>b</dt>
<dd>I register</dd>
<dt>v</dt>
<dd>B register</dd>
<dt>f</dt>
<dd>M register</dd>
<dt>c</dt>
<dd>Registers used for circular buffering, i.e. I, B, or L registers.</dd>
<dt>C</dt>
<dd>The CC register.</dd>
<dt>t</dt>
<dd>LT0 or LT1.</dd>
<dt>k</dt>
<dd>LC0 or LC1.</dd>
<dt>u</dt>
<dd>LB0 or LB1.</dd>
<dt>x</dt>
<dd>Any D, P, B, M, I or L register.</dd>
<dt>y</dt>
<dd>Additional registers typically used only in prologues and epilogues: RETS,
RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.</dd>
<dt>w</dt>
<dd>Any register except accumulators or CC.</dd>
<dt>Ksh</dt>
<dd>Signed 16 bit integer (in the range -32768 to 32767)</dd>
<dt>Kuh</dt>
<dd>Unsigned 16 bit integer (in the range 0 to 65535)</dd>
<dt>Ks7</dt>
<dd>Signed 7 bit integer (in the range -64 to 63)</dd>
<dt>Ku7</dt>
<dd>Unsigned 7 bit integer (in the range 0 to 127)</dd>
<dt>Ku5</dt>
<dd>Unsigned 5 bit integer (in the range 0 to 31)</dd>
<dt>Ks4</dt>
<dd>Signed 4 bit integer (in the range -8 to 7)</dd>
<dt>Ks3</dt>
<dd>Signed 3 bit integer (in the range -3 to 4)</dd>
<dt>Ku3</dt>
<dd>Unsigned 3 bit integer (in the range 0 to 7)</dd>
<dt>P``n``</dt>
<dd>Constant <tt class="docutils literal"><span class="pre">n</span></tt>, where <tt class="docutils literal"><span class="pre">n</span></tt> is a single-digit constant in the range 0 to 4.</dd>
<dt>PA</dt>
<dd>An integer equal to one of the MACFLAG_XXX constants that is suitable for
use with either accumulator.</dd>
<dt>PB</dt>
<dd>An integer equal to one of the MACFLAG_XXX constants that is suitable for
use only with accumulator A1.</dd>
<dt>M1</dt>
<dd>Constant 255.</dd>
<dt>M2</dt>
<dd>Constant 65535.</dd>
<dt>J</dt>
<dd>An integer constant with exactly a single bit set.</dd>
<dt>L</dt>
<dd>An integer constant with all bits set except exactly one.</dd>
</dl>
<p>H</p>
<dl class="docutils">
<dt>Q</dt>
<dd>Any SYMBOL_REF.</dd>
</dl>
</div></blockquote>
<p>CR16 Architecture-config/cr16/cr16.h</p>
<blockquote>
<div><dl class="docutils">
<dt>b</dt>
<dd>Registers from r0 to r14 (registers without stack pointer)</dd>
<dt>t</dt>
<dd>Register from r0 to r11 (all 16-bit registers)</dd>
<dt>p</dt>
<dd>Register from r12 to r15 (all 32-bit registers)</dd>
<dt>I</dt>
<dd>Signed constant that fits in 4 bits</dd>
<dt>J</dt>
<dd>Signed constant that fits in 5 bits</dd>
<dt>K</dt>
<dd>Signed constant that fits in 6 bits</dd>
<dt>L</dt>
<dd>Unsigned constant that fits in 4 bits</dd>
<dt>M</dt>
<dd>Signed constant that fits in 32 bits</dd>
<dt>N</dt>
<dd>Check for 64 bits wide constants for add/sub instructions</dd>
<dt>G</dt>
<dd>Floating point constant that is legal for store immediate</dd>
</dl>
</div></blockquote>
<p>Epiphany-config/epiphany/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>U16</dt>
<dd>An unsigned 16-bit constant.</dd>
<dt>K</dt>
<dd>An unsigned 5-bit constant.</dd>
<dt>L</dt>
<dd>A signed 11-bit constant.</dd>
<dt>Cm1</dt>
<dd>A signed 11-bit constant added to -1.
Can only match when the <em class="xref std std-option">-m1reg-``reg``</em> option is active.</dd>
<dt>Cl1</dt>
<dd>Left-shift of -1, i.e., a bit mask with a block of leading ones, the rest
being a block of trailing zeroes.
Can only match when the <em class="xref std std-option">-m1reg-``reg``</em> option is active.</dd>
<dt>Cr1</dt>
<dd>Right-shift of -1, i.e., a bit mask with a trailing block of ones, the
rest being zeroes.  Or to put it another way, one less than a power of two.
Can only match when the <em class="xref std std-option">-m1reg-``reg``</em> option is active.</dd>
<dt>Cal</dt>
<dd>Constant for arithmetic/logical operations.
This is like <tt class="docutils literal"><span class="pre">i</span></tt>, except that for position independent code,
no symbols / expressions needing relocations are allowed.</dd>
<dt>Csy</dt>
<dd>Symbolic constant for call/jump instruction.</dd>
<dt>Rcs</dt>
<dd>The register class usable in short insns.  This is a register class
constraint, and can thus drive register allocation.
This constraint won&#8217;t match unless <a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-mprefer-short-insn-regs"><em class="xref std std-option">-mprefer-short-insn-regs</em></a> is
in effect.</dd>
<dt>Rsc</dt>
<dd>The the register class of registers that can be used to hold a
sibcall call address.  I.e., a caller-saved register.</dd>
<dt>Rct</dt>
<dd>Core control register class.</dd>
<dt>Rgs</dt>
<dd>The register group usable in short insns.
This constraint does not use a register class, so that it only
passively matches suitable registers, and doesn&#8217;t drive register allocation.</dd>
<dt>Rra</dt>
<dd>Matches the return address if it can be replaced with the link register.</dd>
<dt>Rcc</dt>
<dd>Matches the integer condition code register.</dd>
<dt>Sra</dt>
<dd>Matches the return address if it is in a stack slot.</dd>
<dt>Cfm</dt>
<dd>Matches control register values to switch fp mode, which are encapsulated in
<tt class="docutils literal"><span class="pre">UNSPEC_FP_MODE</span></tt>.</dd>
</dl>
</div></blockquote>
<p>FRV-config/frv/frv.h</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">ACC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">acc0</span></tt> to <tt class="docutils literal"><span class="pre">acc7</span></tt>).</dd>
<dt>b</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">EVEN_ACC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">acc0</span></tt> to <tt class="docutils literal"><span class="pre">acc7</span></tt>).</dd>
<dt>c</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">CC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">fcc0</span></tt> to <tt class="docutils literal"><span class="pre">fcc3</span></tt> and
<tt class="docutils literal"><span class="pre">icc0</span></tt> to <tt class="docutils literal"><span class="pre">icc3</span></tt>).</dd>
<dt>d</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">GPR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">gr0</span></tt> to <tt class="docutils literal"><span class="pre">gr63</span></tt>).</dd>
<dt>e</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">EVEN_REGS</span></tt> (<tt class="docutils literal"><span class="pre">gr0</span></tt> to <tt class="docutils literal"><span class="pre">gr63</span></tt>).
Odd registers are excluded not in the class but through the use of a machine
mode larger than 4 bytes.</dd>
<dt>f</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">FPR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">fr0</span></tt> to <tt class="docutils literal"><span class="pre">fr63</span></tt>).</dd>
<dt>h</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">FEVEN_REGS</span></tt> (<tt class="docutils literal"><span class="pre">fr0</span></tt> to <tt class="docutils literal"><span class="pre">fr63</span></tt>).
Odd registers are excluded not in the class but through the use of a machine
mode larger than 4 bytes.</dd>
<dt>l</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">LR_REG</span></tt> (the <tt class="docutils literal"><span class="pre">lr</span></tt> register).</dd>
<dt>q</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">QUAD_REGS</span></tt> (<tt class="docutils literal"><span class="pre">gr2</span></tt> to <tt class="docutils literal"><span class="pre">gr63</span></tt>).
Register numbers not divisible by 4 are excluded not in the class but through
the use of a machine mode larger than 8 bytes.</dd>
<dt>t</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">ICC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">icc0</span></tt> to <tt class="docutils literal"><span class="pre">icc3</span></tt>).</dd>
<dt>u</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">FCC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">fcc0</span></tt> to <tt class="docutils literal"><span class="pre">fcc3</span></tt>).</dd>
<dt>v</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">ICR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">cc4</span></tt> to <tt class="docutils literal"><span class="pre">cc7</span></tt>).</dd>
<dt>w</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">FCR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">cc0</span></tt> to <tt class="docutils literal"><span class="pre">cc3</span></tt>).</dd>
<dt>x</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">QUAD_FPR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">fr0</span></tt> to <tt class="docutils literal"><span class="pre">fr63</span></tt>).
Register numbers not divisible by 4 are excluded not in the class but through
the use of a machine mode larger than 8 bytes.</dd>
<dt>z</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">SPR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">lcr</span></tt> and <tt class="docutils literal"><span class="pre">lr</span></tt>).</dd>
<dt>A</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">QUAD_ACC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">acc0</span></tt> to <tt class="docutils literal"><span class="pre">acc7</span></tt>).</dd>
<dt>B</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">ACCG_REGS</span></tt> (<tt class="docutils literal"><span class="pre">accg0</span></tt> to <tt class="docutils literal"><span class="pre">accg7</span></tt>).</dd>
<dt>C</dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">CR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">cc0</span></tt> to <tt class="docutils literal"><span class="pre">cc7</span></tt>).</dd>
<dt>G</dt>
<dd>Floating point constant zero</dd>
<dt>I</dt>
<dd>6-bit signed integer constant</dd>
<dt>J</dt>
<dd>10-bit signed integer constant</dd>
<dt>L</dt>
<dd>16-bit signed integer constant</dd>
<dt>M</dt>
<dd>16-bit unsigned integer constant</dd>
<dt>N</dt>
<dd>12-bit signed integer constant that is negative-i.e. in the
range of -2048 to -1</dd>
<dt>O</dt>
<dd>Constant zero</dd>
<dt>P</dt>
<dd>12-bit signed integer constant that is greater than zero-i.e. in the
range of 1 to 2047.</dd>
</dl>
</div></blockquote>
<p>Hewlett-Packard PA-RISC-config/pa/pa.h</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>General register 1</dd>
<dt>f</dt>
<dd>Floating point register</dd>
<dt>q</dt>
<dd>Shift amount register</dd>
<dt>x</dt>
<dd>Floating point register (deprecated)</dd>
<dt>y</dt>
<dd>Upper floating point register (32-bit), floating point register (64-bit)</dd>
<dt>Z</dt>
<dd>Any register</dd>
<dt>I</dt>
<dd>Signed 11-bit integer constant</dd>
<dt>J</dt>
<dd>Signed 14-bit integer constant</dd>
<dt>K</dt>
<dd>Integer constant that can be deposited with a <tt class="docutils literal"><span class="pre">zdepi</span></tt> instruction</dd>
<dt>L</dt>
<dd>Signed 5-bit integer constant</dd>
<dt>M</dt>
<dd>Integer constant 0</dd>
<dt>N</dt>
<dd>Integer constant that can be loaded with a <tt class="docutils literal"><span class="pre">ldil</span></tt> instruction</dd>
<dt>O</dt>
<dd>Integer constant whose value plus one is a power of 2</dd>
<dt>P</dt>
<dd>Integer constant that can be used for <tt class="docutils literal"><span class="pre">and</span></tt> operations in <tt class="docutils literal"><span class="pre">depi</span></tt>
and <tt class="docutils literal"><span class="pre">extru</span></tt> instructions</dd>
<dt>S</dt>
<dd>Integer constant 31</dd>
<dt>U</dt>
<dd>Integer constant 63</dd>
<dt>G</dt>
<dd>Floating-point constant 0.0</dd>
<dt>A</dt>
<dd>A <tt class="docutils literal"><span class="pre">lo_sum</span></tt> data-linkage-table memory operand</dd>
<dt>Q</dt>
<dd>A memory operand that can be used as the destination operand of an
integer store instruction</dd>
<dt>R</dt>
<dd>A scaled or unscaled indexed memory operand</dd>
<dt>T</dt>
<dd>A memory operand for floating-point loads and stores</dd>
<dt>W</dt>
<dd>A register indirect memory operand</dd>
</dl>
</div></blockquote>
<p>Intel IA-64-config/ia64/ia64.h</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>General register <tt class="docutils literal"><span class="pre">r0</span></tt> to <tt class="docutils literal"><span class="pre">r3</span></tt> for <tt class="docutils literal"><span class="pre">addl</span></tt> instruction</dd>
<dt>b</dt>
<dd>Branch register</dd>
<dt>c</dt>
<dd>Predicate register (c as in &#8216;conditional&#8217;)</dd>
<dt>d</dt>
<dd>Application register residing in M-unit</dd>
<dt>e</dt>
<dd>Application register residing in I-unit</dd>
<dt>f</dt>
<dd>Floating-point register</dd>
<dt>m</dt>
<dd>Memory operand.  If used together with &lt; or &gt;,
the operand can have postincrement and postdecrement which
require printing with %Pn on IA-64.</dd>
<dt>G</dt>
<dd>Floating-point constant 0.0 or 1.0</dd>
<dt>I</dt>
<dd>14-bit signed integer constant</dd>
<dt>J</dt>
<dd>22-bit signed integer constant</dd>
<dt>K</dt>
<dd>8-bit signed integer constant for logical instructions</dd>
<dt>L</dt>
<dd>8-bit adjusted signed integer constant for compare pseudo-ops</dd>
<dt>M</dt>
<dd>6-bit unsigned integer constant for shift counts</dd>
<dt>N</dt>
<dd>9-bit signed integer constant for load and store postincrements</dd>
<dt>O</dt>
<dd>The constant zero</dd>
<dt>P</dt>
<dd>0 or -1 for <tt class="docutils literal"><span class="pre">dep</span></tt> instruction</dd>
<dt>Q</dt>
<dd>Non-volatile memory for floating-point loads and stores</dd>
<dt>R</dt>
<dd>Integer constant in the range 1 to 4 for <tt class="docutils literal"><span class="pre">shladd</span></tt> instruction</dd>
<dt>S</dt>
<dd>Memory operand except postincrement and postdecrement.  This is
now roughly the same as m when not used together with &lt;
or &gt;.</dd>
</dl>
</div></blockquote>
<p>M32C-config/m32c/m32c.c</p>
<blockquote>
<div><dl class="docutils">
<dt>Rsp Rfb Rsb</dt>
<dd>$sp, $fb, $sb.</dd>
<dt>Rcr</dt>
<dd>Any control register, when they&#8217;re 16 bits wide (nothing if control
registers are 24 bits wide)</dd>
<dt>Rcl</dt>
<dd>Any control register, when they&#8217;re 24 bits wide.</dd>
<dt>R0w R1w R2w R3w</dt>
<dd>$r0, $r1, $r2, $r3.</dd>
<dt>R02</dt>
<dd>$r0 or $r2, or $r2r0 for 32 bit values.</dd>
<dt>R13</dt>
<dd>$r1 or $r3, or $r3r1 for 32 bit values.</dd>
<dt>Rdi</dt>
<dd>A register that can hold a 64 bit value.</dd>
<dt>Rhl</dt>
<dd>$r0 or $r1 (registers with addressable high/low bytes)</dd>
<dt>R23</dt>
<dd>$r2 or $r3</dd>
<dt>Raa</dt>
<dd>Address registers</dd>
<dt>Raw</dt>
<dd>Address registers when they&#8217;re 16 bits wide.</dd>
<dt>Ral</dt>
<dd>Address registers when they&#8217;re 24 bits wide.</dd>
<dt>Rqi</dt>
<dd>Registers that can hold QI values.</dd>
<dt>Rad</dt>
<dd>Registers that can be used with displacements ($a0, $a1, $sb).</dd>
<dt>Rsi</dt>
<dd>Registers that can hold 32 bit values.</dd>
<dt>Rhi</dt>
<dd>Registers that can hold 16 bit values.</dd>
<dt>Rhc</dt>
<dd>Registers chat can hold 16 bit values, including all control
registers.</dd>
<dt>Rra</dt>
<dd>$r0 through R1, plus $a0 and $a1.</dd>
<dt>Rfl</dt>
<dd>The flags register.</dd>
<dt>Rmm</dt>
<dd>The memory-based pseudo-registers $mem0 through $mem15.</dd>
<dt>Rpi</dt>
<dd>Registers that can hold pointers (16 bit registers for r8c, m16c; 24
bit registers for m32cm, m32c).</dd>
<dt>Rpa</dt>
<dd>Matches multiple registers in a PARALLEL to form a larger register.
Used to match function return values.</dd>
<dt>Is3</dt>
<dd>-8 ... 7</dd>
<dt>IS1</dt>
<dd>-128 ... 127</dd>
<dt>IS2</dt>
<dd>-32768 ... 32767</dd>
<dt>IU2</dt>
<dd>0 ... 65535</dd>
<dt>In4</dt>
<dd>-8 ... -1 or 1 ... 8</dd>
<dt>In5</dt>
<dd>-16 ... -1 or 1 ... 16</dd>
<dt>In6</dt>
<dd>-32 ... -1 or 1 ... 32</dd>
<dt>IM2</dt>
<dd>-65536 ... -1</dd>
<dt>Ilb</dt>
<dd>An 8 bit value with exactly one bit set.</dd>
<dt>Ilw</dt>
<dd>A 16 bit value with exactly one bit set.</dd>
<dt>Sd</dt>
<dd>The common src/dest memory addressing modes.</dd>
<dt>Sa</dt>
<dd>Memory addressed using $a0 or $a1.</dd>
<dt>Si</dt>
<dd>Memory addressed with immediate addresses.</dd>
<dt>Ss</dt>
<dd>Memory addressed using the stack pointer ($sp).</dd>
<dt>Sf</dt>
<dd>Memory addressed using the frame base register ($fb).</dd>
<dt>Ss</dt>
<dd>Memory addressed using the small base register ($sb).</dd>
<dt>S1</dt>
<dd>$r1h</dd>
</dl>
</div></blockquote>
<p>MeP-config/mep/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>The $sp register.</dd>
<dt>b</dt>
<dd>The $tp register.</dd>
<dt>c</dt>
<dd>Any control register.</dd>
<dt>d</dt>
<dd>Either the $hi or the $lo register.</dd>
<dt>em</dt>
<dd>Coprocessor registers that can be directly loaded ($c0-$c15).</dd>
<dt>ex</dt>
<dd>Coprocessor registers that can be moved to each other.</dd>
<dt>er</dt>
<dd>Coprocessor registers that can be moved to core registers.</dd>
<dt>h</dt>
<dd>The $hi register.</dd>
<dt>j</dt>
<dd>The $rpc register.</dd>
<dt>l</dt>
<dd>The $lo register.</dd>
<dt>t</dt>
<dd>Registers which can be used in $tp-relative addressing.</dd>
<dt>v</dt>
<dd>The $gp register.</dd>
<dt>x</dt>
<dd>The coprocessor registers.</dd>
<dt>y</dt>
<dd>The coprocessor control registers.</dd>
<dt>z</dt>
<dd>The $0 register.</dd>
<dt>A</dt>
<dd>User-defined register set A.</dd>
<dt>B</dt>
<dd>User-defined register set B.</dd>
<dt>C</dt>
<dd>User-defined register set C.</dd>
<dt>D</dt>
<dd>User-defined register set D.</dd>
<dt>I</dt>
<dd>Offsets for $gp-rel addressing.</dd>
<dt>J</dt>
<dd>Constants that can be used directly with boolean insns.</dd>
<dt>K</dt>
<dd>Constants that can be moved directly to registers.</dd>
<dt>L</dt>
<dd>Small constants that can be added to registers.</dd>
<dt>M</dt>
<dd>Long shift counts.</dd>
<dt>N</dt>
<dd>Small constants that can be compared to registers.</dd>
<dt>O</dt>
<dd>Constants that can be loaded into the top half of registers.</dd>
<dt>S</dt>
<dd>Signed 8-bit immediates.</dd>
<dt>T</dt>
<dd>Symbols encoded for $tp-rel or $gp-rel addressing.</dd>
<dt>U</dt>
<dd>Non-constant addresses for loading/saving coprocessor registers.</dd>
<dt>W</dt>
<dd>The top half of a symbol&#8217;s value.</dd>
<dt>Y</dt>
<dd>A register indirect address without offset.</dd>
<dt>Z</dt>
<dd>Symbolic references to the control bus.</dd>
</dl>
</div></blockquote>
<p>MicroBlaze-config/microblaze/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>d</dt>
<dd>A general register (<tt class="docutils literal"><span class="pre">r0</span></tt> to <tt class="docutils literal"><span class="pre">r31</span></tt>).</dd>
<dt>z</dt>
<dd>A status register (<tt class="docutils literal"><span class="pre">rmsr</span></tt>, <tt class="docutils literal"><span class="pre">$fcc1</span></tt> to <tt class="docutils literal"><span class="pre">$fcc7</span></tt>).</dd>
</dl>
</div></blockquote>
<p>MIPS-config/mips/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>d</dt>
<dd>An address register.  This is equivalent to <tt class="docutils literal"><span class="pre">r</span></tt> unless
generating MIPS16 code.</dd>
<dt>f</dt>
<dd>A floating-point register (if available).</dd>
<dt>h</dt>
<dd>Formerly the <tt class="docutils literal"><span class="pre">hi</span></tt> register.  This constraint is no longer supported.</dd>
<dt>l</dt>
<dd>The <tt class="docutils literal"><span class="pre">lo</span></tt> register.  Use this register to store values that are
no bigger than a word.</dd>
<dt>x</dt>
<dd>The concatenated <tt class="docutils literal"><span class="pre">hi</span></tt> and <tt class="docutils literal"><span class="pre">lo</span></tt> registers.  Use this register
to store doubleword values.</dd>
<dt>c</dt>
<dd>A register suitable for use in an indirect jump.  This will always be
<tt class="docutils literal"><span class="pre">$25</span></tt> for <a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-mabicalls"><em class="xref std std-option">-mabicalls</em></a>.</dd>
<dt>v</dt>
<dd>Register <tt class="docutils literal"><span class="pre">$3</span></tt>.  Do not use this constraint in new code;
it is retained only for compatibility with glibc.</dd>
<dt>y</dt>
<dd>Equivalent to <tt class="docutils literal"><span class="pre">r</span></tt>; retained for backwards compatibility.</dd>
<dt>z</dt>
<dd>A floating-point condition code register.</dd>
<dt>I</dt>
<dd>A signed 16-bit constant (for arithmetic instructions).</dd>
<dt>J</dt>
<dd>Integer zero.</dd>
<dt>K</dt>
<dd>An unsigned 16-bit constant (for logic instructions).</dd>
<dt>L</dt>
<dd>A signed 32-bit constant in which the lower 16 bits are zero.
Such constants can be loaded using <tt class="docutils literal"><span class="pre">lui</span></tt>.</dd>
<dt>M</dt>
<dd>A constant that cannot be loaded using <tt class="docutils literal"><span class="pre">lui</span></tt>, <tt class="docutils literal"><span class="pre">addiu</span></tt>
or <tt class="docutils literal"><span class="pre">ori</span></tt>.</dd>
<dt>N</dt>
<dd>A constant in the range -65535 to -1 (inclusive).</dd>
<dt>O</dt>
<dd>A signed 15-bit constant.</dd>
<dt>P</dt>
<dd>A constant in the range 1 to 65535 (inclusive).</dd>
<dt>G</dt>
<dd>Floating-point zero.</dd>
<dt>R</dt>
<dd>An address that can be used in a non-macro load or store.</dd>
<dt>ZC</dt>
<dd>A memory operand whose address is formed by a base register and offset
that is suitable for use in instructions with the same addressing mode
as <tt class="docutils literal"><span class="pre">ll</span></tt> and <tt class="docutils literal"><span class="pre">sc</span></tt>.</dd>
<dt>ZD</dt>
<dd>An address suitable for a <tt class="docutils literal"><span class="pre">prefetch</span></tt> instruction, or for any other
instruction with the same addressing mode as <tt class="docutils literal"><span class="pre">prefetch</span></tt>.</dd>
</dl>
</div></blockquote>
<p>Motorola 680x0-config/m68k/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>Address register</dd>
<dt>d</dt>
<dd>Data register</dd>
<dt>f</dt>
<dd>68881 floating-point register, if available</dd>
<dt>I</dt>
<dd>Integer in the range 1 to 8</dd>
<dt>J</dt>
<dd>16-bit signed number</dd>
<dt>K</dt>
<dd>Signed number whose magnitude is greater than 0x80</dd>
<dt>L</dt>
<dd>Integer in the range -8 to -1</dd>
<dt>M</dt>
<dd>Signed number whose magnitude is greater than 0x100</dd>
<dt>N</dt>
<dd>Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate</dd>
<dt>O</dt>
<dd>16 (for rotate using swap)</dd>
<dt>P</dt>
<dd>Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate</dd>
<dt>R</dt>
<dd>Numbers that mov3q can handle</dd>
<dt>G</dt>
<dd>Floating point constant that is not a 68881 constant</dd>
<dt>S</dt>
<dd>Operands that satisfy &#8216;m&#8217; when -mpcrel is in effect</dd>
<dt>T</dt>
<dd>Operands that satisfy &#8216;s&#8217; when -mpcrel is not in effect</dd>
<dt>Q</dt>
<dd>Address register indirect addressing mode</dd>
<dt>U</dt>
<dd>Register offset addressing</dd>
<dt>W</dt>
<dd>const_call_operand</dd>
<dt>Cs</dt>
<dd>symbol_ref or const</dd>
<dt>Ci</dt>
<dd>const_int</dd>
<dt>C0</dt>
<dd>const_int 0</dd>
<dt>Cj</dt>
<dd>Range of signed numbers that don&#8217;t fit in 16 bits</dd>
<dt>Cmvq</dt>
<dd>Integers valid for mvq</dd>
<dt>Capsw</dt>
<dd>Integers valid for a moveq followed by a swap</dd>
<dt>Cmvz</dt>
<dd>Integers valid for mvz</dd>
<dt>Cmvs</dt>
<dd>Integers valid for mvs</dd>
<dt>Ap</dt>
<dd>push_operand</dd>
<dt>Ac</dt>
<dd>Non-register operands allowed in clr</dd>
</dl>
</div></blockquote>
<p>Moxie-config/moxie/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>A</dt>
<dd>An absolute address</dd>
<dt>B</dt>
<dd>An offset address</dd>
<dt>W</dt>
<dd>A register indirect memory operand</dd>
<dt>I</dt>
<dd>A constant in the range of 0 to 255.</dd>
<dt>N</dt>
<dd>A constant in the range of 0 to -255.</dd>
</dl>
</div></blockquote>
<p>MSP430-config/msp430/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>R12</dt>
<dd>Register R12.</dd>
<dt>R13</dt>
<dd>Register R13.</dd>
<dt>K</dt>
<dd>Integer constant 1.</dd>
<dt>L</dt>
<dd>Integer constant -1^20..1^19.</dd>
<dt>M</dt>
<dd>Integer constant 1-4.</dd>
<dt>Ya</dt>
<dd>Memory references which do not require an extended MOVX instruction.</dd>
<dt>Yl</dt>
<dd>Memory reference, labels only.</dd>
<dt>Ys</dt>
<dd>Memory reference, stack only.</dd>
</dl>
</div></blockquote>
<p>NDS32-config/nds32/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>w</dt>
<dd>LOW register class $r0 to $r7 constraint for V3/V3M ISA.</dd>
<dt>l</dt>
<dd>LOW register class $r0 to $r7.</dd>
<dt>d</dt>
<dd>MIDDLE register class $r0 to $r11, $r16 to $r19.</dd>
<dt>h</dt>
<dd>HIGH register class $r12 to $r14, $r20 to $r31.</dd>
<dt>t</dt>
<dd>Temporary assist register $ta (i.e. $r15).</dd>
<dt>k</dt>
<dd>Stack register $sp.</dd>
<dt>Iu03</dt>
<dd>Unsigned immediate 3-bit value.</dd>
<dt>In03</dt>
<dd>Negative immediate 3-bit value in the range of -7-0.</dd>
<dt>Iu04</dt>
<dd>Unsigned immediate 4-bit value.</dd>
<dt>Is05</dt>
<dd>Signed immediate 5-bit value.</dd>
<dt>Iu05</dt>
<dd>Unsigned immediate 5-bit value.</dd>
<dt>In05</dt>
<dd>Negative immediate 5-bit value in the range of -31-0.</dd>
<dt>Ip05</dt>
<dd>Unsigned immediate 5-bit value for movpi45 instruction with range 16-47.</dd>
<dt>Iu06</dt>
<dd>Unsigned immediate 6-bit value constraint for addri36.sp instruction.</dd>
<dt>Iu08</dt>
<dd>Unsigned immediate 8-bit value.</dd>
<dt>Iu09</dt>
<dd>Unsigned immediate 9-bit value.</dd>
<dt>Is10</dt>
<dd>Signed immediate 10-bit value.</dd>
<dt>Is11</dt>
<dd>Signed immediate 11-bit value.</dd>
<dt>Is15</dt>
<dd>Signed immediate 15-bit value.</dd>
<dt>Iu15</dt>
<dd>Unsigned immediate 15-bit value.</dd>
<dt>Ic15</dt>
<dd>A constant which is not in the range of imm15u but ok for bclr instruction.</dd>
<dt>Ie15</dt>
<dd>A constant which is not in the range of imm15u but ok for bset instruction.</dd>
<dt>It15</dt>
<dd>A constant which is not in the range of imm15u but ok for btgl instruction.</dd>
<dt>Ii15</dt>
<dd>A constant whose compliment value is in the range of imm15u
and ok for bitci instruction.</dd>
<dt>Is16</dt>
<dd>Signed immediate 16-bit value.</dd>
<dt>Is17</dt>
<dd>Signed immediate 17-bit value.</dd>
<dt>Is19</dt>
<dd>Signed immediate 19-bit value.</dd>
<dt>Is20</dt>
<dd>Signed immediate 20-bit value.</dd>
<dt>Ihig</dt>
<dd>The immediate value that can be simply set high 20-bit.</dd>
<dt>Izeb</dt>
<dd>The immediate value 0xff.</dd>
<dt>Izeh</dt>
<dd>The immediate value 0xffff.</dd>
<dt>Ixls</dt>
<dd>The immediate value 0x01.</dd>
<dt>Ix11</dt>
<dd>The immediate value 0x7ff.</dd>
<dt>Ibms</dt>
<dd>The immediate value with power of 2.</dd>
<dt>Ifex</dt>
<dd>The immediate value with power of 2 minus 1.</dd>
<dt>U33</dt>
<dd>Memory constraint for 333 format.</dd>
<dt>U45</dt>
<dd>Memory constraint for 45 format.</dd>
<dt>U37</dt>
<dd>Memory constraint for 37 format.</dd>
</dl>
</div></blockquote>
<p>Nios II family-config/nios2/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>I</dt>
<dd>Integer that is valid as an immediate operand in an
instruction taking a signed 16-bit number. Range
-32768 to 32767.</dd>
<dt>J</dt>
<dd>Integer that is valid as an immediate operand in an
instruction taking an unsigned 16-bit number. Range
0 to 65535.</dd>
<dt>K</dt>
<dd>Integer that is valid as an immediate operand in an
instruction taking only the upper 16-bits of a
32-bit number. Range 32-bit numbers with the lower
16-bits being 0.</dd>
<dt>L</dt>
<dd>Integer that is valid as an immediate operand for a
shift instruction. Range 0 to 31.</dd>
<dt>M</dt>
<dd>Integer that is valid as an immediate operand for
only the value 0. Can be used in conjunction with
the format modifier <tt class="docutils literal"><span class="pre">z</span></tt> to use <tt class="docutils literal"><span class="pre">r0</span></tt>
instead of <tt class="docutils literal"><span class="pre">0</span></tt> in the assembly output.</dd>
<dt>N</dt>
<dd>Integer that is valid as an immediate operand for
a custom instruction opcode. Range 0 to 255.</dd>
<dt>S</dt>
<dd>Matches immediates which are addresses in the small
data section and therefore can be added to <tt class="docutils literal"><span class="pre">gp</span></tt>
as a 16-bit immediate to re-create their 32-bit value.</dd>
</dl>
</div></blockquote>
<p>PDP-11-config/pdp11/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>Floating point registers AC0 through AC3.  These can be loaded from/to
memory with a single instruction.</dd>
<dt>d</dt>
<dd>Odd numbered general registers (R1, R3, R5).  These are used for
16-bit multiply operations.</dd>
<dt>f</dt>
<dd>Any of the floating point registers (AC0 through AC5).</dd>
<dt>G</dt>
<dd>Floating point constant 0.</dd>
<dt>I</dt>
<dd>An integer constant that fits in 16 bits.</dd>
<dt>J</dt>
<dd>An integer constant whose low order 16 bits are zero.</dd>
<dt>K</dt>
<dd>An integer constant that does not meet the constraints for codes
I or J.</dd>
<dt>L</dt>
<dd>The integer constant 1.</dd>
<dt>M</dt>
<dd>The integer constant -1.</dd>
<dt>N</dt>
<dd>The integer constant 0.</dd>
<dt>O</dt>
<dd>Integer constants -4 through -1 and 1 through 4; shifts by these
amounts are handled as multiple single-bit shifts rather than a single
variable-length shift.</dd>
<dt>Q</dt>
<dd>A memory reference which requires an additional word (address or
offset) after the opcode.</dd>
<dt>R</dt>
<dd>A memory reference that is encoded within the opcode.</dd>
</dl>
</div></blockquote>
<p>PowerPC and IBM RS6000-config/rs6000/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>b</dt>
<dd>Address base register</dd>
<dt>d</dt>
<dd>Floating point register (containing 64-bit value)</dd>
<dt>f</dt>
<dd>Floating point register (containing 32-bit value)</dd>
<dt>v</dt>
<dd>Altivec vector register</dd>
<dt>wa</dt>
<dd>Any VSX register if the -mvsx option was used or NO_REGS.</dd>
<dt>wd</dt>
<dd>VSX vector register to hold vector double data or NO_REGS.</dd>
<dt>wf</dt>
<dd>VSX vector register to hold vector float data or NO_REGS.</dd>
<dt>wg</dt>
<dd>If <em class="xref std std-option">-mmfpgpr</em> was used, a floating point register or NO_REGS.</dd>
<dt>wh</dt>
<dd>Floating point register if direct moves are available, or NO_REGS.</dd>
<dt>wi</dt>
<dd>FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS.</dd>
<dt>wj</dt>
<dd>FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.</dd>
<dt>wk</dt>
<dd>FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.</dd>
<dt>wl</dt>
<dd>Floating point register if the LFIWAX instruction is enabled or NO_REGS.</dd>
<dt>wm</dt>
<dd>VSX register if direct move instructions are enabled, or NO_REGS.</dd>
<dt>wn</dt>
<dd>No register (NO_REGS).</dd>
<dt>wr</dt>
<dd>General purpose register if 64-bit instructions are enabled or NO_REGS.</dd>
<dt>ws</dt>
<dd>VSX vector register to hold scalar double values or NO_REGS.</dd>
<dt>wt</dt>
<dd>VSX vector register to hold 128 bit integer or NO_REGS.</dd>
<dt>wu</dt>
<dd>Altivec register to use for float/32-bit int loads/stores  or NO_REGS.</dd>
<dt>wv</dt>
<dd>Altivec register to use for double loads/stores  or NO_REGS.</dd>
<dt>ww</dt>
<dd>FP or VSX register to perform float operations under <a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-mvsx"><em class="xref std std-option">-mvsx</em></a> or NO_REGS.</dd>
<dt>wx</dt>
<dd>Floating point register if the STFIWX instruction is enabled or NO_REGS.</dd>
<dt>wy</dt>
<dd>FP or VSX register to perform ISA 2.07 float ops or NO_REGS.</dd>
<dt>wz</dt>
<dd>Floating point register if the LFIWZX instruction is enabled or NO_REGS.</dd>
<dt>wD</dt>
<dd>Int constant that is the element number of the 64-bit scalar in a vector.</dd>
<dt>wQ</dt>
<dd>A memory address that will work with the <tt class="docutils literal"><span class="pre">lq</span></tt> and <tt class="docutils literal"><span class="pre">stq</span></tt>
instructions.</dd>
<dt>h</dt>
<dd>MQ, CTR, or LINK register</dd>
<dt>q</dt>
<dd>MQ register</dd>
<dt>c</dt>
<dd>CTR register</dd>
<dt>l</dt>
<dd>LINK register</dd>
<dt>x</dt>
<dd>CR register (condition register) number 0</dd>
<dt>y</dt>
<dd>CR register (condition register)</dd>
<dt>z</dt>
<dd>XER[CA] carry bit (part of the XER register)</dd>
<dt>I</dt>
<dd>Signed 16-bit constant</dd>
<dt>J</dt>
<dd>Unsigned 16-bit constant shifted left 16 bits (use L instead for
<tt class="docutils literal"><span class="pre">SImode</span></tt> constants)</dd>
<dt>K</dt>
<dd>Unsigned 16-bit constant</dd>
<dt>L</dt>
<dd>Signed 16-bit constant shifted left 16 bits</dd>
<dt>M</dt>
<dd>Constant larger than 31</dd>
<dt>N</dt>
<dd>Exact power of 2</dd>
<dt>O</dt>
<dd>Zero</dd>
<dt>P</dt>
<dd>Constant whose negation is a signed 16-bit constant</dd>
<dt>G</dt>
<dd>Floating point constant that can be loaded into a register with one
instruction per word</dd>
<dt>H</dt>
<dd>Integer/Floating point constant that can be loaded into a register using
three instructions</dd>
<dt>m</dt>
<dd><p class="first">Memory operand.
Normally, <tt class="docutils literal"><span class="pre">m</span></tt> does not allow addresses that update the base register.
If &lt; or &gt; constraint is also used, they are allowed and
therefore on PowerPC targets in that case it is only safe
to use m&lt;&gt; in an <tt class="docutils literal"><span class="pre">asm</span></tt> statement if that <tt class="docutils literal"><span class="pre">asm</span></tt> statement
accesses the operand exactly once.  The <tt class="docutils literal"><span class="pre">asm</span></tt> statement must also
use %U``&lt;opno&gt;`` as a placeholder for the &#8216;update&#8217; flag in the
corresponding load or store instruction.  For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;st%U0 %1,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;=m&lt;&gt;&quot;</span> <span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">val</span><span class="p">));</span>
</pre></div>
</div>
<p>is correct but:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;st %1,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;=m&lt;&gt;&quot;</span> <span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">val</span><span class="p">));</span>
</pre></div>
</div>
<p class="last">is not.</p>
</dd>
<dt>es</dt>
<dd>A &#8216;stable&#8217; memory operand; that is, one which does not include any
automodification of the base register.  This used to be useful when
m allowed automodification of the base register, but as those are now only
allowed when &lt; or &gt; is used, es is basically the same
as m without &lt; and &gt;.</dd>
<dt>Q</dt>
<dd>Memory operand that is an offset from a register (it is usually better
to use m or es in <tt class="docutils literal"><span class="pre">asm</span></tt> statements)</dd>
<dt>Z</dt>
<dd>Memory operand that is an indexed or indirect from a register (it is
usually better to use m or es in <tt class="docutils literal"><span class="pre">asm</span></tt> statements)</dd>
<dt>R</dt>
<dd>AIX TOC entry</dd>
<dt>a</dt>
<dd>Address operand that is an indexed or indirect from a register (p is
preferable for <tt class="docutils literal"><span class="pre">asm</span></tt> statements)</dd>
<dt>S</dt>
<dd>Constant suitable as a 64-bit mask operand</dd>
<dt>T</dt>
<dd>Constant suitable as a 32-bit mask operand</dd>
<dt>U</dt>
<dd>System V Release 4 small data area reference</dd>
<dt>t</dt>
<dd>AND masks that can be performed by two rldic{l, r} instructions</dd>
<dt>W</dt>
<dd>Vector constant that does not require memory</dd>
<dt>j</dt>
<dd>Vector constant that is all zeros.</dd>
</dl>
</div></blockquote>
<p>RL78-config/rl78/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>Int3</dt>
<dd>An integer constant in the range 1 ... 7.</dd>
<dt>Int8</dt>
<dd>An integer constant in the range 0 ... 255.</dd>
<dt>J</dt>
<dd>An integer constant in the range -255 ... 0</dd>
<dt>K</dt>
<dd>The integer constant 1.</dd>
<dt>L</dt>
<dd>The integer constant -1.</dd>
<dt>M</dt>
<dd>The integer constant 0.</dd>
<dt>N</dt>
<dd>The integer constant 2.</dd>
<dt>O</dt>
<dd>The integer constant -2.</dd>
<dt>P</dt>
<dd>An integer constant in the range 1 ... 15.</dd>
<dt>Qbi</dt>
<dd>The built-in compare types-eq, ne, gtu, ltu, geu, and leu.</dd>
<dt>Qsc</dt>
<dd>The synthetic compare types-gt, lt, ge, and le.</dd>
<dt>Wab</dt>
<dd>A memory reference with an absolute address.</dd>
<dt>Wbc</dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">BC</span></tt> as a base register, with an optional offset.</dd>
<dt>Wca</dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">AX</span></tt>, <tt class="docutils literal"><span class="pre">BC</span></tt>, <tt class="docutils literal"><span class="pre">DE</span></tt>, or <tt class="docutils literal"><span class="pre">HL</span></tt> for the address, for calls.</dd>
<dt>Wcv</dt>
<dd>A memory reference using any 16-bit register pair for the address, for calls.</dd>
<dt>Wd2</dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">DE</span></tt> as a base register, with an optional offset.</dd>
<dt>Wde</dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">DE</span></tt> as a base register, without any offset.</dd>
<dt>Wfr</dt>
<dd>Any memory reference to an address in the far address space.</dd>
<dt>Wh1</dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">HL</span></tt> as a base register, with an optional one-byte offset.</dd>
<dt>Whb</dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">HL</span></tt> as a base register, with <tt class="docutils literal"><span class="pre">B</span></tt> or <tt class="docutils literal"><span class="pre">C</span></tt> as the index register.</dd>
<dt>Whl</dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">HL</span></tt> as a base register, without any offset.</dd>
<dt>Ws1</dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">SP</span></tt> as a base register, with an optional one-byte offset.</dd>
<dt>Y</dt>
<dd>Any memory reference to an address in the near address space.</dd>
<dt>A</dt>
<dd>The <tt class="docutils literal"><span class="pre">AX</span></tt> register.</dd>
<dt>B</dt>
<dd>The <tt class="docutils literal"><span class="pre">BC</span></tt> register.</dd>
<dt>D</dt>
<dd>The <tt class="docutils literal"><span class="pre">DE</span></tt> register.</dd>
<dt>R</dt>
<dd><tt class="docutils literal"><span class="pre">A</span></tt> through <tt class="docutils literal"><span class="pre">L</span></tt> registers.</dd>
<dt>S</dt>
<dd>The <tt class="docutils literal"><span class="pre">SP</span></tt> register.</dd>
<dt>T</dt>
<dd>The <tt class="docutils literal"><span class="pre">HL</span></tt> register.</dd>
<dt>Z08W</dt>
<dd>The 16-bit <tt class="docutils literal"><span class="pre">R8</span></tt> register.</dd>
<dt>Z10W</dt>
<dd>The 16-bit <tt class="docutils literal"><span class="pre">R10</span></tt> register.</dd>
<dt>Zint</dt>
<dd>The registers reserved for interrupts (<tt class="docutils literal"><span class="pre">R24</span></tt> to <tt class="docutils literal"><span class="pre">R31</span></tt>).</dd>
<dt>a</dt>
<dd>The <tt class="docutils literal"><span class="pre">A</span></tt> register.</dd>
<dt>b</dt>
<dd>The <tt class="docutils literal"><span class="pre">B</span></tt> register.</dd>
<dt>c</dt>
<dd>The <tt class="docutils literal"><span class="pre">C</span></tt> register.</dd>
<dt>d</dt>
<dd>The <tt class="docutils literal"><span class="pre">D</span></tt> register.</dd>
<dt>e</dt>
<dd>The <tt class="docutils literal"><span class="pre">E</span></tt> register.</dd>
<dt>h</dt>
<dd>The <tt class="docutils literal"><span class="pre">H</span></tt> register.</dd>
<dt>l</dt>
<dd>The <tt class="docutils literal"><span class="pre">L</span></tt> register.</dd>
<dt>v</dt>
<dd>The virtual registers.</dd>
<dt>w</dt>
<dd>The <tt class="docutils literal"><span class="pre">PSW</span></tt> register.</dd>
<dt>x</dt>
<dd>The <tt class="docutils literal"><span class="pre">X</span></tt> register.</dd>
</dl>
</div></blockquote>
<p>RX-config/rx/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>Q</dt>
<dd>An address which does not involve register indirect addressing or
pre/post increment/decrement addressing.</dd>
<dt>Symbol</dt>
<dd>A symbol reference.</dd>
<dt>Int08</dt>
<dd>A constant in the range -256 to 255, inclusive.</dd>
<dt>Sint08</dt>
<dd>A constant in the range -128 to 127, inclusive.</dd>
<dt>Sint16</dt>
<dd>A constant in the range -32768 to 32767, inclusive.</dd>
<dt>Sint24</dt>
<dd>A constant in the range -8388608 to 8388607, inclusive.</dd>
<dt>Uint04</dt>
<dd>A constant in the range 0 to 15, inclusive.</dd>
</dl>
</div></blockquote>
<p>S/390 and zSeries-config/s390/s390.h</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>Address register (general purpose register except r0)</dd>
<dt>c</dt>
<dd>Condition code register</dd>
<dt>d</dt>
<dd>Data register (arbitrary general purpose register)</dd>
<dt>f</dt>
<dd>Floating-point register</dd>
<dt>I</dt>
<dd>Unsigned 8-bit constant (0-255)</dd>
<dt>J</dt>
<dd>Unsigned 12-bit constant (0-4095)</dd>
<dt>K</dt>
<dd>Signed 16-bit constant (-32768-32767)</dd>
<dt>L</dt>
<dd><p class="first">Value appropriate as displacement.</p>
<dl class="last docutils">
<dt>(0..4095)</dt>
<dd>for short displacement</dd>
<dt>(-524288..524287)</dt>
<dd>for long displacement</dd>
</dl>
</dd>
<dt>M</dt>
<dd>Constant integer with a value of 0x7fffffff.</dd>
<dt>N</dt>
<dd><p class="first">Multiple letter constraint followed by 4 parameter letters.</p>
<dl class="docutils">
<dt>0..9:</dt>
<dd>number of the part counting from most to least significant</dd>
<dt>H,Q:</dt>
<dd>mode of the part</dd>
<dt>D,S,H:</dt>
<dd>mode of the containing operand</dd>
<dt>0,F:</dt>
<dd><p class="first">value of the other parts (F-all bits set)</p>
<p class="last">The constraint matches if the specified part of a constant</p>
</dd>
</dl>
<p class="last">has a value different from its other parts.</p>
</dd>
<dt>Q</dt>
<dd>Memory reference without index register and with short displacement.</dd>
<dt>R</dt>
<dd>Memory reference with index register and short displacement.</dd>
<dt>S</dt>
<dd>Memory reference without index register but with long displacement.</dd>
<dt>T</dt>
<dd>Memory reference with index register and long displacement.</dd>
<dt>U</dt>
<dd>Pointer with short displacement.</dd>
<dt>W</dt>
<dd>Pointer with long displacement.</dd>
<dt>Y</dt>
<dd>Shift count operand.</dd>
</dl>
</div></blockquote>
<p>SPARC-config/sparc/sparc.h</p>
<blockquote>
<div><dl class="docutils">
<dt>f</dt>
<dd>Floating-point register on the SPARC-V8 architecture and
lower floating-point register on the SPARC-V9 architecture.</dd>
<dt>e</dt>
<dd>Floating-point register.  It is equivalent to f on the
SPARC-V8 architecture and contains both lower and upper
floating-point registers on the SPARC-V9 architecture.</dd>
<dt>c</dt>
<dd>Floating-point condition code register.</dd>
<dt>d</dt>
<dd>Lower floating-point register.  It is only valid on the SPARC-V9
architecture when the Visual Instruction Set is available.</dd>
<dt>b</dt>
<dd>Floating-point register.  It is only valid on the SPARC-V9 architecture
when the Visual Instruction Set is available.</dd>
<dt>h</dt>
<dd>64-bit global or out register for the SPARC-V8+ architecture.</dd>
<dt>C</dt>
<dd>The constant all-ones, for floating-point.</dd>
<dt>A</dt>
<dd>Signed 5-bit constant</dd>
<dt>D</dt>
<dd>A vector constant</dd>
<dt>I</dt>
<dd>Signed 13-bit constant</dd>
<dt>J</dt>
<dd>Zero</dd>
<dt>K</dt>
<dd>32-bit constant with the low 12 bits clear (a constant that can be
loaded with the <tt class="docutils literal"><span class="pre">sethi</span></tt> instruction)</dd>
<dt>L</dt>
<dd>A constant in the range supported by <tt class="docutils literal"><span class="pre">movcc</span></tt> instructions (11-bit
signed immediate)</dd>
<dt>M</dt>
<dd>A constant in the range supported by <tt class="docutils literal"><span class="pre">movrcc</span></tt> instructions (10-bit
signed immediate)</dd>
<dt>N</dt>
<dd>Same as K, except that it verifies that bits that are not in the
lower 32-bit range are all zero.  Must be used instead of K for
modes wider than <tt class="docutils literal"><span class="pre">SImode</span></tt></dd>
<dt>O</dt>
<dd>The constant 4096</dd>
<dt>G</dt>
<dd>Floating-point zero</dd>
<dt>H</dt>
<dd>Signed 13-bit constant, sign-extended to 32 or 64 bits</dd>
<dt>P</dt>
<dd>The constant -1</dd>
<dt>Q</dt>
<dd>Floating-point constant whose integral representation can
be moved into an integer register using a single sethi
instruction</dd>
<dt>R</dt>
<dd>Floating-point constant whose integral representation can
be moved into an integer register using a single mov
instruction</dd>
<dt>S</dt>
<dd>Floating-point constant whose integral representation can
be moved into an integer register using a high/lo_sum
instruction sequence</dd>
<dt>T</dt>
<dd>Memory address aligned to an 8-byte boundary</dd>
<dt>U</dt>
<dd>Even register</dd>
<dt>W</dt>
<dd>Memory address for e constraint registers</dd>
<dt>w</dt>
<dd>Memory address with only a base register</dd>
<dt>Y</dt>
<dd>Vector zero</dd>
</dl>
</div></blockquote>
<p>SPU-config/spu/spu.h</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 64 bit value.</dd>
<dt>c</dt>
<dd>An immediate for and/xor/or instructions.  const_int is treated as a 64 bit value.</dd>
<dt>d</dt>
<dd>An immediate for the <tt class="docutils literal"><span class="pre">iohl</span></tt> instruction.  const_int is treated as a 64 bit value.</dd>
<dt>f</dt>
<dd>An immediate which can be loaded with <tt class="docutils literal"><span class="pre">fsmbi</span></tt>.</dd>
<dt>A</dt>
<dd>An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 32 bit value.</dd>
<dt>B</dt>
<dd>An immediate for most arithmetic instructions.  const_int is treated as a 32 bit value.</dd>
<dt>C</dt>
<dd>An immediate for and/xor/or instructions.  const_int is treated as a 32 bit value.</dd>
<dt>D</dt>
<dd>An immediate for the <tt class="docutils literal"><span class="pre">iohl</span></tt> instruction.  const_int is treated as a 32 bit value.</dd>
<dt>I</dt>
<dd>A constant in the range [-64, 63] for shift/rotate instructions.</dd>
<dt>J</dt>
<dd>An unsigned 7-bit constant for conversion/nop/channel instructions.</dd>
<dt>K</dt>
<dd>A signed 10-bit constant for most arithmetic instructions.</dd>
<dt>M</dt>
<dd>A signed 16 bit immediate for <tt class="docutils literal"><span class="pre">stop</span></tt>.</dd>
<dt>N</dt>
<dd>An unsigned 16-bit constant for <tt class="docutils literal"><span class="pre">iohl</span></tt> and <tt class="docutils literal"><span class="pre">fsmbi</span></tt>.</dd>
<dt>O</dt>
<dd>An unsigned 7-bit constant whose 3 least significant bits are 0.</dd>
<dt>P</dt>
<dd>An unsigned 3-bit constant for 16-byte rotates and shifts</dd>
<dt>R</dt>
<dd>Call operand, reg, for indirect calls</dd>
<dt>S</dt>
<dd>Call operand, symbol, for relative calls.</dd>
<dt>T</dt>
<dd>Call operand, const_int, for absolute calls.</dd>
<dt>U</dt>
<dd>An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is sign extended to 128 bit.</dd>
<dt>W</dt>
<dd>An immediate for shift and rotate instructions.  const_int is treated as a 32 bit value.</dd>
<dt>Y</dt>
<dd>An immediate for and/xor/or instructions.  const_int is sign extended as a 128 bit.</dd>
<dt>Z</dt>
<dd>An immediate for the <tt class="docutils literal"><span class="pre">iohl</span></tt> instruction.  const_int is sign extended to 128 bit.</dd>
</dl>
</div></blockquote>
<p>TI C6X family-config/c6x/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>Register file A (A0-A31).</dd>
<dt>b</dt>
<dd>Register file B (B0-B31).</dd>
<dt>A</dt>
<dd>Predicate registers in register file A (A0-A2 on C64X and
higher, A1 and A2 otherwise).</dd>
<dt>B</dt>
<dd>Predicate registers in register file B (B0-B2).</dd>
<dt>C</dt>
<dd>A call-used register in register file B (B0-B9, B16-B31).</dd>
<dt>Da</dt>
<dd>Register file A, excluding predicate registers (A3-A31,
plus A0 if not C64X or higher).</dd>
<dt>Db</dt>
<dd>Register file B, excluding predicate registers (B3-B31).</dd>
<dt>Iu4</dt>
<dd>Integer constant in the range 0 ... 15.</dd>
<dt>Iu5</dt>
<dd>Integer constant in the range 0 ... 31.</dd>
<dt>In5</dt>
<dd>Integer constant in the range -31 ... 0.</dd>
<dt>Is5</dt>
<dd>Integer constant in the range -16 ... 15.</dd>
<dt>I5x</dt>
<dd>Integer constant that can be the operand of an ADDA or a SUBA insn.</dd>
<dt>IuB</dt>
<dd>Integer constant in the range 0 ... 65535.</dd>
<dt>IsB</dt>
<dd>Integer constant in the range -32768 ... 32767.</dd>
<dt>IsC</dt>
<dd>Integer constant in the range -2^{20} ... 2^{20} - 1.</dd>
<dt>Jc</dt>
<dd>Integer constant that is a valid mask for the clr instruction.</dd>
<dt>Js</dt>
<dd>Integer constant that is a valid mask for the set instruction.</dd>
<dt>Q</dt>
<dd>Memory location with A base register.</dd>
<dt>R</dt>
<dd>Memory location with B base register.</dd>
<dt>Z</dt>
<dd>Register B14 (aka DP).</dd>
</dl>
</div></blockquote>
<p>TILE-Gx-config/tilegx/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>R00 R01 R02 R03 R04 R05 R06 R07 R08 R09 R10</dt>
<dd>Each of these represents a register constraint for an individual
register, from r0 to r10.</dd>
<dt>I</dt>
<dd>Signed 8-bit integer constant.</dd>
<dt>J</dt>
<dd>Signed 16-bit integer constant.</dd>
<dt>K</dt>
<dd>Unsigned 16-bit integer constant.</dd>
<dt>L</dt>
<dd>Integer constant that fits in one signed byte when incremented by one
(-129 ... 126).</dd>
<dt>m</dt>
<dd><p class="first">Memory operand.  If used together with &lt; or &gt;, the
operand can have postincrement which requires printing with %In
and %in on TILE-Gx.  For example:</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;st_add %I0,%1,%i0&quot;</span> <span class="o">:</span> <span class="s">&quot;=m&lt;&gt;&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">mem</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">val</span><span class="p">));</span>
</pre></div>
</div>
</dd>
<dt>M</dt>
<dd>A bit mask suitable for the BFINS instruction.</dd>
<dt>N</dt>
<dd>Integer constant that is a byte tiled out eight times.</dd>
<dt>O</dt>
<dd>The integer zero constant.</dd>
<dt>P</dt>
<dd>Integer constant that is a sign-extended byte tiled out as four shorts.</dd>
<dt>Q</dt>
<dd>Integer constant that fits in one signed byte when incremented
(-129 ... 126), but excluding -1.</dd>
<dt>S</dt>
<dd>Integer constant that has all 1 bits consecutive and starting at bit 0.</dd>
<dt>T</dt>
<dd>A 16-bit fragment of a got, tls, or pc-relative reference.</dd>
<dt>U</dt>
<dd>Memory operand except postincrement.  This is roughly the same as
m when not used together with &lt; or &gt;.</dd>
<dt>W</dt>
<dd>An 8-element vector constant with identical elements.</dd>
<dt>Y</dt>
<dd>A 4-element vector constant with identical elements.</dd>
<dt>Z0</dt>
<dd>The integer constant 0xffffffff.</dd>
<dt>Z1</dt>
<dd>The integer constant 0xffffffff00000000.</dd>
</dl>
</div></blockquote>
<p>TILEPro-config/tilepro/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>R00 R01 R02 R03 R04 R05 R06 R07 R08 R09 R10</dt>
<dd>Each of these represents a register constraint for an individual
register, from r0 to r10.</dd>
<dt>I</dt>
<dd>Signed 8-bit integer constant.</dd>
<dt>J</dt>
<dd>Signed 16-bit integer constant.</dd>
<dt>K</dt>
<dd>Nonzero integer constant with low 16 bits zero.</dd>
<dt>L</dt>
<dd>Integer constant that fits in one signed byte when incremented by one
(-129 ... 126).</dd>
<dt>m</dt>
<dd><p class="first">Memory operand.  If used together with &lt; or &gt;, the
operand can have postincrement which requires printing with %In
and %in on TILEPro.  For example:</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;swadd %I0,%1,%i0&quot;</span> <span class="o">:</span> <span class="s">&quot;=m&lt;&gt;&quot;</span> <span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">val</span><span class="p">));</span>
</pre></div>
</div>
</dd>
<dt>M</dt>
<dd>A bit mask suitable for the MM instruction.</dd>
<dt>N</dt>
<dd>Integer constant that is a byte tiled out four times.</dd>
<dt>O</dt>
<dd>The integer zero constant.</dd>
<dt>P</dt>
<dd>Integer constant that is a sign-extended byte tiled out as two shorts.</dd>
<dt>Q</dt>
<dd>Integer constant that fits in one signed byte when incremented
(-129 ... 126), but excluding -1.</dd>
<dt>T</dt>
<dd>A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative
reference.</dd>
<dt>U</dt>
<dd>Memory operand except postincrement.  This is roughly the same as
m when not used together with &lt; or &gt;.</dd>
<dt>W</dt>
<dd>A 4-element vector constant with identical elements.</dd>
<dt>Y</dt>
<dd>A 2-element vector constant with identical elements.</dd>
</dl>
</div></blockquote>
<p>Visium-config/visium/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>b</dt>
<dd>EAM register <tt class="docutils literal"><span class="pre">mdb</span></tt></dd>
<dt>c</dt>
<dd>EAM register <tt class="docutils literal"><span class="pre">mdc</span></tt></dd>
<dt>f</dt>
<dd>Floating point register</dd>
<dt>l</dt>
<dd>General register, but not <tt class="docutils literal"><span class="pre">r29</span></tt>, <tt class="docutils literal"><span class="pre">r30</span></tt> and <tt class="docutils literal"><span class="pre">r31</span></tt></dd>
<dt>t</dt>
<dd>Register <tt class="docutils literal"><span class="pre">r1</span></tt></dd>
<dt>u</dt>
<dd>Register <tt class="docutils literal"><span class="pre">r2</span></tt></dd>
<dt>v</dt>
<dd>Register <tt class="docutils literal"><span class="pre">r3</span></tt></dd>
<dt>G</dt>
<dd>Floating-point constant 0.0</dd>
<dt>J</dt>
<dd>Integer constant in the range 0 .. 65535 (16-bit immediate)</dd>
<dt>K</dt>
<dd>Integer constant in the range 1 .. 31 (5-bit immediate)</dd>
<dt>L</dt>
<dd>Integer constant in the range -65535 .. -1 (16-bit negative immediate)</dd>
<dt>M</dt>
<dd>Integer constant -1</dd>
<dt>O</dt>
<dd>Integer constant 0</dd>
<dt>P</dt>
<dd>Integer constant 32</dd>
</dl>
</div></blockquote>
<p>x86 family-config/i386/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>R</dt>
<dd>Legacy register-the eight integer registers available on all
i386 processors (<tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">b</span></tt>, <tt class="docutils literal"><span class="pre">c</span></tt>, <tt class="docutils literal"><span class="pre">d</span></tt>,
<tt class="docutils literal"><span class="pre">si</span></tt>, <tt class="docutils literal"><span class="pre">di</span></tt>, <tt class="docutils literal"><span class="pre">bp</span></tt>, <tt class="docutils literal"><span class="pre">sp</span></tt>).</dd>
<dt>q</dt>
<dd>Any register accessible as <tt class="docutils literal"><span class="pre">``r``l</span></tt>.  In 32-bit mode, <tt class="docutils literal"><span class="pre">a</span></tt>,
<tt class="docutils literal"><span class="pre">b</span></tt>, <tt class="docutils literal"><span class="pre">c</span></tt>, and <tt class="docutils literal"><span class="pre">d</span></tt>; in 64-bit mode, any integer register.</dd>
<dt>Q</dt>
<dd>Any register accessible as <tt class="docutils literal"><span class="pre">``r``h</span></tt>: <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">b</span></tt>,
<tt class="docutils literal"><span class="pre">c</span></tt>, and <tt class="docutils literal"><span class="pre">d</span></tt>.</dd>
<dt>a</dt>
<dd>The <tt class="docutils literal"><span class="pre">a</span></tt> register.</dd>
<dt>b</dt>
<dd>The <tt class="docutils literal"><span class="pre">b</span></tt> register.</dd>
<dt>c</dt>
<dd>The <tt class="docutils literal"><span class="pre">c</span></tt> register.</dd>
<dt>d</dt>
<dd>The <tt class="docutils literal"><span class="pre">d</span></tt> register.</dd>
<dt>S</dt>
<dd>The <tt class="docutils literal"><span class="pre">si</span></tt> register.</dd>
<dt>D</dt>
<dd>The <tt class="docutils literal"><span class="pre">di</span></tt> register.</dd>
<dt>A</dt>
<dd><p class="first">The <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">d</span></tt> registers.  This class is used for instructions
that return double word results in the <tt class="docutils literal"><span class="pre">ax:dx</span></tt> register pair.  Single
word values will be allocated either in <tt class="docutils literal"><span class="pre">ax</span></tt> or <tt class="docutils literal"><span class="pre">dx</span></tt>.
For example on i386 the following implements <tt class="docutils literal"><span class="pre">rdtsc</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">rdtsc</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">tick</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;rdtsc&quot;</span><span class="o">:</span><span class="s">&quot;=A&quot;</span><span class="p">(</span><span class="n">tick</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">tick</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is not correct on x86-64 as it would allocate tick in either <tt class="docutils literal"><span class="pre">ax</span></tt>
or <tt class="docutils literal"><span class="pre">dx</span></tt>.  You have to use the following variant instead:</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">rdtsc</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tickl</span><span class="p">,</span> <span class="n">tickh</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;rdtsc&quot;</span><span class="o">:</span><span class="s">&quot;=a&quot;</span><span class="p">(</span><span class="n">tickl</span><span class="p">),</span><span class="s">&quot;=d&quot;</span><span class="p">(</span><span class="n">tickh</span><span class="p">));</span>
  <span class="k">return</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">tickh</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span><span class="o">|</span><span class="n">tickl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>f</dt>
<dd>Any 80387 floating-point (stack) register.</dd>
<dt>t</dt>
<dd>Top of 80387 floating-point stack (<tt class="docutils literal"><span class="pre">%st(0)</span></tt>).</dd>
<dt>u</dt>
<dd>Second from top of 80387 floating-point stack (<tt class="docutils literal"><span class="pre">%st(1)</span></tt>).</dd>
<dt>y</dt>
<dd>Any MMX register.</dd>
<dt>x</dt>
<dd>Any SSE register.</dd>
<dt>Yz</dt>
<dd>First SSE register (<tt class="docutils literal"><span class="pre">%xmm0</span></tt>).</dd>
<dt>I</dt>
<dd>Integer constant in the range 0 ... 31, for 32-bit shifts.</dd>
<dt>J</dt>
<dd>Integer constant in the range 0 ... 63, for 64-bit shifts.</dd>
<dt>K</dt>
<dd>Signed 8-bit integer constant.</dd>
<dt>L</dt>
<dd><tt class="docutils literal"><span class="pre">0xFF</span></tt> or <tt class="docutils literal"><span class="pre">0xFFFF</span></tt>, for andsi as a zero-extending move.</dd>
<dt>M</dt>
<dd>0, 1, 2, or 3 (shifts for the <tt class="docutils literal"><span class="pre">lea</span></tt> instruction).</dd>
<dt>N</dt>
<dd>Unsigned 8-bit integer constant (for <tt class="docutils literal"><span class="pre">in</span></tt> and <tt class="docutils literal"><span class="pre">out</span></tt>
instructions).</dd>
<dt>G</dt>
<dd>Standard 80387 floating point constant.</dd>
<dt>C</dt>
<dd>Standard SSE floating point constant.</dd>
<dt>e</dt>
<dd>32-bit signed integer constant, or a symbolic reference known
to fit that range (for immediate operands in sign-extending x86-64
instructions).</dd>
<dt>Z</dt>
<dd>32-bit unsigned integer constant, or a symbolic reference known
to fit that range (for immediate operands in zero-extending x86-64
instructions).</dd>
</dl>
</div></blockquote>
<p>Xstormy16-config/stormy16/stormy16.h</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>Register r0.</dd>
<dt>b</dt>
<dd>Register r1.</dd>
<dt>c</dt>
<dd>Register r2.</dd>
<dt>d</dt>
<dd>Register r8.</dd>
<dt>e</dt>
<dd>Registers r0 through r7.</dd>
<dt>t</dt>
<dd>Registers r0 and r1.</dd>
<dt>y</dt>
<dd>The carry register.</dd>
<dt>z</dt>
<dd>Registers r8 and r9.</dd>
<dt>I</dt>
<dd>A constant between 0 and 3 inclusive.</dd>
<dt>J</dt>
<dd>A constant that has exactly one bit set.</dd>
<dt>K</dt>
<dd>A constant that has exactly one bit clear.</dd>
<dt>L</dt>
<dd>A constant between 0 and 255 inclusive.</dd>
<dt>M</dt>
<dd>A constant between -255 and 0 inclusive.</dd>
<dt>N</dt>
<dd>A constant between -3 and 0 inclusive.</dd>
<dt>O</dt>
<dd>A constant between 1 and 4 inclusive.</dd>
<dt>P</dt>
<dd>A constant between -4 and -1 inclusive.</dd>
<dt>Q</dt>
<dd>A memory reference that is a stack push.</dd>
<dt>R</dt>
<dd>A memory reference that is a stack pop.</dd>
<dt>S</dt>
<dd>A memory reference that refers to a constant address of known value.</dd>
<dt>T</dt>
<dd>The register indicated by Rx (not implemented yet).</dd>
<dt>U</dt>
<dd>A constant that is not between 2 and 15 inclusive.</dd>
<dt>Z</dt>
<dd>The constant 0.</dd>
</dl>
</div></blockquote>
<p>Xtensa-config/xtensa/constraints.md</p>
<blockquote>
<div><dl class="docutils">
<dt>a</dt>
<dd>General-purpose 32-bit register</dd>
<dt>b</dt>
<dd>One-bit boolean register</dd>
<dt>A</dt>
<dd>MAC16 40-bit accumulator register</dd>
<dt>I</dt>
<dd>Signed 12-bit integer constant, for use in MOVI instructions</dd>
<dt>J</dt>
<dd>Signed 8-bit integer constant, for use in ADDI instructions</dd>
<dt>K</dt>
<dd>Integer constant valid for BccI instructions</dd>
<dt>L</dt>
<dd>Unsigned constant valid for BccUI instructions</dd>
</dl>
</div></blockquote>
</div>
</div>
<div class="section" id="controlling-names-used-in-assembler-code">
<span id="asm-labels"></span><h2>Controlling Names Used in Assembler Code<a class="headerlink" href="#controlling-names-used-in-assembler-code" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-71"></span><span class="target" id="index-72"></span><p id="index-73">You can specify the name to be used in the assembler code for a C
function or variable by writing the <tt class="docutils literal"><span class="pre">asm</span></tt> (or <tt class="docutils literal"><span class="pre">__asm__</span></tt>)
keyword after the declarator as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">foo</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;myfoo&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>This specifies that the name to be used for the variable <tt class="docutils literal"><span class="pre">foo</span></tt> in
the assembler code should be myfoo rather than the usual
_foo.</p>
<p>On systems where an underscore is normally prepended to the name of a C
function or variable, this feature allows you to define names for the
linker that do not start with an underscore.</p>
<p>It does not make sense to use this feature with a non-static local
variable since such variables do not have assembler names.  If you are
trying to put the variable in a particular register, see Explicit
Reg Vars.  GCC presently accepts such code with a warning, but will
probably be changed to issue an error, rather than a warning, in the
future.</p>
<p>You cannot use <tt class="docutils literal"><span class="pre">asm</span></tt> in this way in a function definition; but
you can get the same effect by writing a declaration for the function
before its definition and putting <tt class="docutils literal"><span class="pre">asm</span></tt> there, like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="nf">func</span> <span class="p">()</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;FUNC&quot;</span><span class="p">);</span>

<span class="n">func</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
     <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="cm">/* ... */</span>
</pre></div>
</div>
<p>It is up to you to make sure that the assembler names you choose do not
conflict with any other assembler symbols.  Also, you must not use a
register name; that would produce completely invalid assembler code.  GCC
does not as yet have the ability to store static variables in registers.
Perhaps that will be added.</p>
</div>
<div class="section" id="variables-in-specified-registers">
<span id="explicit-reg-vars"></span><h2>Variables in Specified Registers<a class="headerlink" href="#variables-in-specified-registers" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-74"></span><span class="target" id="index-75"></span><span class="target" id="index-76"></span><p id="index-77">GNU C allows you to put a few global variables into specified hardware
registers.  You can also specify the register in which an ordinary
register variable should be allocated.</p>
<ul>
<li><p class="first">Global register variables reserve registers throughout the program.
This may be useful in programs such as programming language
interpreters that have a couple of global variables that are accessed
very often.</p>
</li>
<li><p class="first">Local register variables in specific registers do not reserve the
registers, except at the point where they are used as input or output
operands in an <tt class="docutils literal"><span class="pre">asm</span></tt> statement and the <tt class="docutils literal"><span class="pre">asm</span></tt> statement itself is
not deleted.  The compiler&#8217;s data flow analysis is capable of determining
where the specified registers contain live values, and where they are
available for other uses.  Stores into local register variables may be deleted
when they appear to be dead according to dataflow analysis.  References
to local register variables may be deleted or moved or simplified.</p>
<p>These local variables are sometimes convenient for use with the extended
<tt class="docutils literal"><span class="pre">asm</span></tt> feature (see <a class="reference internal" href="#extended-asm"><em>Extended Asm - Assembler Instructions with C Expression Operands</em></a>), if you want to write one
output of the assembler instruction directly into a particular register.
(This works provided the register you specify fits the constraints
specified for that operand in the <tt class="docutils literal"><span class="pre">asm</span></tt>.)</p>
</li>
</ul>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="defining-global-register-variables">
<span id="global-reg-vars"></span><h3>Defining Global Register Variables<a class="headerlink" href="#defining-global-register-variables" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-78"></span><p id="index-79">You can define a global register variable in GNU C like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">foo</span> <span class="nf">asm</span> <span class="p">(</span><span class="s">&quot;a5&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">a5</span></tt> is the name of the register that should be used.  Choose a
register that is normally saved and restored by function calls on your
machine, so that library routines will not clobber it.</p>
<p>Naturally the register name is CPU-dependent, so you need to
conditionalize your program according to CPU type.  The register
<tt class="docutils literal"><span class="pre">a5</span></tt> is a good choice on a 68000 for a variable of pointer
type.  On machines with register windows, be sure to choose a &#8216;global&#8217;
register that is not affected magically by the function call mechanism.</p>
<p>In addition, different operating systems on the same CPU may differ in how they
name the registers; then you need additional conditionals.  For
example, some 68000 operating systems call this register <tt class="docutils literal"><span class="pre">%a5</span></tt>.</p>
<p>Eventually there may be a way of asking the compiler to choose a register
automatically, but first we need to figure out how it should choose and
how to enable you to guide the choice.  No solution is evident.</p>
<p>Defining a global register variable in a certain register reserves that
register entirely for this use, at least within the current compilation.
The register is not allocated for any other purpose in the functions
in the current compilation, and is not saved and restored by
these functions.  Stores into this register are never deleted even if they
appear to be dead, but references may be deleted or moved or
simplified.</p>
<p>It is not safe to access the global register variables from signal
handlers, or from more than one thread of control, because the system
library routines may temporarily use the register for other things (unless
you recompile them specially for the task at hand).</p>
<p id="index-80">It is not safe for one function that uses a global register variable to
call another such function <tt class="docutils literal"><span class="pre">foo</span></tt> by way of a third function
<tt class="docutils literal"><span class="pre">lose</span></tt> that is compiled without knowledge of this variable (i.e. in a
different source file in which the variable isn&#8217;t declared).  This is
because <tt class="docutils literal"><span class="pre">lose</span></tt> might save the register and put some other value there.
For example, you can&#8217;t expect a global register variable to be available in
the comparison-function that you pass to <tt class="docutils literal"><span class="pre">qsort</span></tt>, since <tt class="docutils literal"><span class="pre">qsort</span></tt>
might have put something else in that register.  (If you are prepared to
recompile <tt class="docutils literal"><span class="pre">qsort</span></tt> with the same global register variable, you can
solve this problem.)</p>
<p>If you want to recompile <tt class="docutils literal"><span class="pre">qsort</span></tt> or other source files that do not
actually use your global register variable, so that they do not use that
register for any other purpose, then it suffices to specify the compiler
option <em class="xref std std-option">-ffixed-``reg``</em>.  You need not actually add a global
register declaration to their source code.</p>
<p>A function that can alter the value of a global register variable cannot
safely be called from a function compiled without this variable, because it
could clobber the value the caller expects to find there on return.
Therefore, the function that is the entry point into the part of the
program that uses the global register variable must explicitly save and
restore the value that belongs to its caller.</p>
<span class="target" id="index-81"></span><span class="target" id="index-82"></span><span class="target" id="index-83"></span><span class="target" id="index-84"></span><p id="index-85">On most machines, <tt class="docutils literal"><span class="pre">longjmp</span></tt> restores to each global register
variable the value it had at the time of the <tt class="docutils literal"><span class="pre">setjmp</span></tt>.  On some
machines, however, <tt class="docutils literal"><span class="pre">longjmp</span></tt> does not change the value of global
register variables.  To be portable, the function that called <tt class="docutils literal"><span class="pre">setjmp</span></tt>
should make other arrangements to save the values of the global register
variables, and to restore them in a <tt class="docutils literal"><span class="pre">longjmp</span></tt>.  This way, the same
thing happens regardless of what <tt class="docutils literal"><span class="pre">longjmp</span></tt> does.</p>
<p>All global register variable declarations must precede all function
definitions.  If such a declaration could appear after function
definitions, the declaration would be too late to prevent the register from
being used for other purposes in the preceding functions.</p>
<p>Global register variables may not have initial values, because an
executable file has no means to supply initial contents for a register.</p>
<p>On the SPARC, there are reports that g3 ... g7 are suitable
registers, but certain library functions, such as <tt class="docutils literal"><span class="pre">getwd</span></tt>, as well
as the subroutines for division and remainder, modify g3 and g4.  g1 and
g2 are local temporaries.</p>
<p>On the 68000, a2 ... a5 should be suitable, as should d2 ... d7.
Of course, it does not do to use more than a few of those.</p>
</div>
<div class="section" id="specifying-registers-for-local-variables">
<span id="local-reg-vars"></span><h3>Specifying Registers for Local Variables<a class="headerlink" href="#specifying-registers-for-local-variables" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-86"></span><span class="target" id="index-87"></span><p id="index-88">You can define a local register variable with a specified register
like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">foo</span> <span class="nf">asm</span> <span class="p">(</span><span class="s">&quot;a5&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">a5</span></tt> is the name of the register that should be used.  Note
that this is the same syntax used for defining global register
variables, but for a local variable it appears within a function.</p>
<p>Naturally the register name is CPU-dependent, but this is not a
problem, since specific registers are most often useful with explicit
assembler instructions (see <a class="reference internal" href="#extended-asm"><em>Extended Asm - Assembler Instructions with C Expression Operands</em></a>).  Both of these things
generally require that you conditionalize your program according to
CPU type.</p>
<p>In addition, operating systems on one type of CPU may differ in how they
name the registers; then you need additional conditionals.  For
example, some 68000 operating systems call this register <tt class="docutils literal"><span class="pre">%a5</span></tt>.</p>
<p>Defining such a register variable does not reserve the register; it
remains available for other uses in places where flow control determines
the variable&#8217;s value is not live.</p>
<p>This option does not guarantee that GCC generates code that has
this variable in the register you specify at all times.  You may not
code an explicit reference to this register in the assembler
instruction template part of an <tt class="docutils literal"><span class="pre">asm</span></tt> statement and assume it
always refers to this variable.
However, using the variable as an input or output operand to the <tt class="docutils literal"><span class="pre">asm</span></tt>
guarantees that the specified register is used for that operand.
See <a class="reference internal" href="#extended-asm"><em>Extended Asm - Assembler Instructions with C Expression Operands</em></a>, for more information.</p>
<p>Stores into local register variables may be deleted when they appear to be dead
according to dataflow analysis.  References to local register variables may
be deleted or moved or simplified.</p>
<p>As with global register variables, it is recommended that you choose a
register that is normally saved and restored by function calls on
your machine, so that library routines will not clobber it.</p>
<p>Sometimes when writing inline <tt class="docutils literal"><span class="pre">asm</span></tt> code, you need to make an operand be a
specific register, but there&#8217;s no matching constraint letter for that
register. To force the operand into that register, create a local variable
and specify the register in the variable&#8217;s declaration. Then use the local
variable for the asm operand and specify any constraint letter that matches
the register:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;r0&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;r1&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span> <span class="nf">asm</span> <span class="p">(</span><span class="s">&quot;r0&quot;</span><span class="p">);</span>
<span class="k">asm</span> <span class="p">(</span><span class="s">&quot;sysint&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">p2</span><span class="p">));</span>
</pre></div>
</div>
<p>Warning: In the above example, be aware that a register (for example r0) can be
call-clobbered by subsequent code, including function calls and library calls
for arithmetic operators on other variables (for example the initialization
of p2). In this case, use temporary variables for expressions between the
register assignments:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">t1</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;r0&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;r1&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">t1</span><span class="p">;</span>
<span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span> <span class="nf">asm</span> <span class="p">(</span><span class="s">&quot;r0&quot;</span><span class="p">);</span>
<span class="k">asm</span> <span class="p">(</span><span class="s">&quot;sysint&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">p2</span><span class="p">));</span>
</pre></div>
</div>
<p id="size-of-an-asm">Size of an <tt class="docutils literal"><span class="pre">asm``Some</span> <span class="pre">targets</span> <span class="pre">require</span> <span class="pre">that</span> <span class="pre">GCC</span> <span class="pre">track</span> <span class="pre">the</span> <span class="pre">size</span> <span class="pre">of</span> <span class="pre">each</span> <span class="pre">instruction</span> <span class="pre">used</span>
<span class="pre">in</span> <span class="pre">order</span> <span class="pre">to</span> <span class="pre">generate</span> <span class="pre">correct</span> <span class="pre">code.</span>&nbsp; <span class="pre">Because</span> <span class="pre">the</span> <span class="pre">final</span> <span class="pre">length</span> <span class="pre">of</span> <span class="pre">the</span>
<span class="pre">code</span> <span class="pre">produced</span> <span class="pre">by</span> <span class="pre">an</span> <span class="pre">``asm</span></tt> statement is only known by the
assembler, GCC must make an estimate as to how big it will be.  It
does this by counting the number of instructions in the pattern of the
<tt class="docutils literal"><span class="pre">asm</span></tt> and multiplying that by the length of the longest
instruction supported by that processor.  (When working out the number
of instructions, it assumes that any occurrence of a newline or of
whatever statement separator character is supported by the assembler -
typically ; - indicates the end of an instruction.)</p>
<p>Normally, GCC&#8217;s estimate is adequate to ensure that correct
code is generated, but it is possible to confuse the compiler if you use
pseudo instructions or assembler macros that expand into multiple real
instructions, or if you use assembler directives that expand to more
space in the object file than is needed for a single instruction.
If this happens then the assembler may produce a diagnostic saying that
a label is unreachable.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="alternate-keywords.html" title="Alternate Keywords"
             >next</a> |</li>
        <li class="right" >
          <a href="when-is-a-volatile-object-accessed?.html" title="When is a Volatile Object Accessed?"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" >Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>